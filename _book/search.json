[
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "An Introduction to R",
    "section": "License",
    "text": "License\nThis textbook is free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction to R and Rstudio",
    "section": "",
    "text": "First things first. We need to download and install both R and RStudio (an integrated development environment for R) on our personal computer. First, we install R, then we will need to install RStudio.\n\nFirst, we must Download and install R:\n\n\nIf our operating system (OS) is Windows: we click on “Download R for Windows”, then click on “base”, then click on the Download link.\nIf our operating system (OS) is macOS: we click on “Download R for (Mac) OS X”, then under “Latest release:” click on R-X.X.X.pkg, where R-X.X.X is the version number.\n\n\nSecond, we must Download and install RStudio:\n\n\nWe scroll down near the bottom of the page.\nWe click on the download link corresponding to your computer’s operating system.\n\nWe follow the usual installation procedures for R and RSudio."
  },
  {
    "objectID": "introduction.html#what-are-r-and-rstudio",
    "href": "introduction.html#what-are-r-and-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.2 What are R and RStudio?",
    "text": "1.2 What are R and RStudio?\nWe will use R via RStudio. Beginners often confuse the two applications. Using an analogy, R is like an airplane’s engine while RStudio is like an airplane’s dashboard (Figure 1.1).\nSpecifically, R is a statistical programming language (an implementation of the S programming language) and a powerful graphics engine, which was created by Ross Ihahka and Robert Gentleman at the University of Auckland in 1993.\nThe name R for the language was coined after the initials of the forenames of the inventors, plus the influence of the S language.\nR does all the heavy work (like an airplane engine) while RStudio is an integrated development environment (IDE) that was founded by J.J. Allaire in 2009. RStudio provides a friendly interface by adding a plenty of great features, auto-complete functions and tools (like an airplane dashboard with electronic monitors, and navigation systems) and makes life a lot easier.\n\n\nFigure 1.1: Analogy of difference between R and RStudio\n\n\nAfter we install R and RStudio on our computer, we’ll have two new programs (also called applications) we can open. In this textbook, we’ll always work in RStudio.\n\n\n\n\n\n\nWhy R Programming Language?\n\n\n\n\nR programming is used as a leading tool for machine learning, statistics, and data analysis. Objects, functions, and packages can easily be created by R.\nIt’s a platform-independent language. This means it can be applied to all operating systems.\nIt’s an open-source free language. That means anyone can install it in any organization without purchasing a license.\nR programming language is not only a statistic software but also allows us to integrate with other languages (C, C++). Thus, we can easily interact with many data sources and statistical tools.\nThe R programming language has a vast community of users and it’s growing day by day.\nR is currently one of the most requested programming languages in the Data Science job market that makes it the hottest trend nowadays."
  },
  {
    "objectID": "introduction.html#starting-r-rstudio",
    "href": "introduction.html#starting-r-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.3 Starting R & RStudio",
    "text": "1.3 Starting R & RStudio\nAfter the RStudio installation is finished, click the RStudio icon \nR starts automatically when we open RStudio Figure 1.2 and we are greeted by three panes:\n\n\nFigure 1.2: RStudio Screenshot with Console on the left and Help tab in the bottom right.\n\n\nThe three main panes that divide the screen are:\n\nthe large Console pane on the left runs R code.\n\nthe workspace pane, which includes the Environment and History tabs, in the upper right.\n\nThe Environment tab keeps track of the objects we create as we work with R (a major part of our tasks involves creating objects).\nThe History tab tracks all of the commands that we have sent to the R console in the session.\n\n\n\nthe Files/Plots/Packages/Help/Viewer pane in the lower right.\n\nThe Files tab lets us create new folders (directories) on our computer, as well as copy, move, delete, or rename files.\nThe Plots tab holds graphs and charts we generate from our data and during the analysis.\nThe Packages tab lists of all the R packages installed on our hard drive and indicates whether or not they are currently loaded. We’ll discuss packages in more detail in the next sections.\nThe Help tab, provides links to search for help directly from our RStudio window.\nThe Viewer tab in RStudio allows us to view local web content (e.g., to view an html table).\n\n\n\nThroughout this textbook, we’ll come to learn what purpose each of these panes serve.\n\n\n\n\n\n\nCommand prompt  >\n\n\n\nThe Console pane starts with information about the version number, license and contributors, and provides some guidance on how to get help. The last line is a standard command prompt (the greater than sign > symbol) that indicates R is ready and expecting instructions to do something.\n\n\n \nLet’s type 14 + 16 at the R command prompt and press Enter:\n\n14 + 16\n\n[1] 30\n\n\nSo what happened?\nWell, R gave us a response (output) to our input (14 + 16). That response came after we pressed the Enter key. It was [1] 30. It’s clear that 30 is the answer to the 14 + 16. However, what does the [1] mean? At this point we can pretty much ignore it, but technically it refers to the index of the first item on each line. (Sometimes R prints out many lines as an output. The number inside the brackets helps us figure out where in the sequence we are per line)."
  },
  {
    "objectID": "introduction.html#r-scripts",
    "href": "introduction.html#r-scripts",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.4 R scripts",
    "text": "1.4 R scripts\nUsually, we do our programming by writing our code in script files. An R script (with the “.R” extension) is simply a text file in which our R code is stored, and then can be “sent” to the console, where R will execute it.\nIf we go to:\n\n\n\n\n\nflowchart LR\n  A[File] -.-> B(New File) -.-> C(R Script)\n\n\n\n\n\n\n\n\nin the RStudio menu, we should see another pane (Q1) opened on the left above the interactive console Figure 1.3. This is where we can write a length script with lots of lines of code, and save the file for future use.\n\n\nFigure 1.3: RStudio Screenshot with four panes.\n\n\nTherefore, the RStudio window is divided into four panes (quadrants) that contain:\n\nQ1 - code editor (script)\nQ2 - console\nQ3 - environment (workspace), history\nQ4 - files, plots, packages, help, viewer (for local web content)\n\n\n\n\n\n\n\nLayout of the panes\n\n\n\nThe four panes might be in a different order that those in Figure 1.3. If we’d like, we can change the order of the windows under RStudio preferences. We select from RStudio menu:\n\n\n\n\n\nflowchart LR\n  A[Tools] -.-> B(Global Options) -.-> C(Pane layout)\n\n\n\n\n\n\n\n\nWe can also change their shape by either clicking the minimize or maximize buttons on the top right of each pane, or by clicking and dragging the middle of the borders of the windows.\n\n\nIn Rscript, we can execute our code line by line by putting the cursor on the line or selecting a chunk of lines (by highlighting the text) and pressing the run button  in the source window. We can also run our selected code using the keywboard shortcut Ctrl + Enter.\n\n\n\n\n\n\nAdvantages writing our R code as an R script file\n\n\n\n\nWe can save and reuse our code\nWe can document our work (however, we can only include one-line comments and these must be prefixed with the hash symbol,  #)\nWe can share our work with others\nWe can move beyond writing one line of code at a time"
  },
  {
    "objectID": "introduction.html#errors-warnings-and-messages-in-r",
    "href": "introduction.html#errors-warnings-and-messages-in-r",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.5 Errors, warnings, and messages in R",
    "text": "1.5 Errors, warnings, and messages in R\nLet’s type the following at the R command prompt and press Enter:\n\nhello\n\nwe get the following error:Error: object ‘hello’ not found\nOne thing that intimidates new R and RStudio users is how it reports errors, warnings, and messages. R reports errors, warnings, and messages in a glaring red font, which makes it seem like it is scolding us. However, seeing red text in the console is not always bad.\nR will show in the console pane in three different situations:\n\nErrors: When the red text is a legitimate error, it will be prefaced with “Error…” and try to explain what went wrong. Generally when there’s an error, the code will not run.\nWarnings: When the red text is a warning, it will be prefaced with “Warning:” and R will try to explain why there’s a warning. Generally our code will still work, but with some caveats.\nMessages: When the red text doesn’t start with either “Error” or “Warning”, it’s just a friendly message.\n\nNow, let’s type the following:\n\n1 + 2 -\n+\n\n\n\n\n\n\n\nIf a command is not complete then R will show a Plus sign (+) prompt\n\n\n\nIf an R command is not complete then R will show a plus sign (+) prompt on second and subsequent lines until the command syntax is correct (this means that we can type something to finish the command we are trying to execute). We can also hit the escape key (ESC) to cancel whatever command R is waiting for us to finish."
  },
  {
    "objectID": "introduction.html#r-help-resources",
    "href": "introduction.html#r-help-resources",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.6 R Help resources",
    "text": "1.6 R Help resources\nBefore asking others for help, it’s generally a good idea for us to try to help ourself. It is strongly recommended to learn how to use R’s useful and extensive built-in help system which is an essential part of finding solutions to our R programming problems.\nWe can use the help() function or ? help operator which provide access to the R documentation pages for a specific term. For example, if we want information for the mean we type the following commands (which give the same result):\n\nhelp(mean)\n\nor\n\n?mean\n\n\n\nFigure 1.4: R help() function search for specific term such as mean\n\n\nSo, R tried to find something called mean (Figure 1.4).\n\n\n\n\n\n\nRecall a previously typed command in console\n\n\n\nIn console to recall a previously typed commands use the up arrow key (\\(\\uparrow\\)). To go between previously typed commands use the up and down arrow (\\(\\downarrow\\)) keys. To modify or correct a command use the left (\\(\\leftarrow\\)) and right arrow (\\(\\rightarrow\\)) keys.\n\n\nTwo question marks (??) will search R documentation for a phrase or term and it is a shortcut to help.search() function. So for example, let’s say we want to search documentation for linear regression analysis. Keep in mind if our phrase is more than one word long, we must put it in quotation marks.\n\n??\"linear regression\"\n\nTo do a keyword search use the apropos() command with the keyword in double quotes, \"keyword\", or single quote, 'keyword'. For example:\n\napropos(\"mean\")\n\nUse the example() command to run the examples at the end of the help for a function:\n\nexample(mean)\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nRStudio also provides search box in the “Help” tab to make our life easier (Figure 1.2).\nLike Google, but for R is the RSeek.Org. This is not included in R but is a great search engine built specifically for R-related queries.\nAdditionally, there are a lot of on-line resources that can help (e.g., R-bloggers). However, we must understand that blindly copying and pasting could be harmful and further it won’t help us to learn and develop."
  },
  {
    "objectID": "introduction.html#working-with-rstudio-projects",
    "href": "introduction.html#working-with-rstudio-projects",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.7 Working with RStudio Projects",
    "text": "1.7 Working with RStudio Projects\nWhen we are working in R, the program needs to know where to find inputs and deliver outputs, and will look first in what is called a “working directory”. Moreover, we want to organize all of the files for a given project in one folder, and that particular folder should be established as our working directory.\nCreate a new RStudio Project\nKeeping all the files associated with a project organized together – input data, R scripts, documents and figures – is such a wise and common practice that RStudio has built-in support for this via its projects. RStudio projects are associated with R working directories Figure 1.5.\nWe can create an RStudio project:\n\nIn a new directory\nIn an existing directory where we already have R code and data\nBy cloning a version control (Git or Subversion) repository\n\nLet’s create one to use for the rest of this textbook. From the RStudio menu:\n\n\n\n\n\nflowchart LR\n  A[File] -.-> B(New Project)\n\n\n\n\n\n\n\n\nThe directory name we choose here will be the project name. We call it whatever we want (e.g., introR).\n\n\nFigure 1.5: RStudio projects are associated with R working directories\n\n\n\n\n\n\n\n\nStore the RStudio Project somewhere sensible\n\n\n\nWe must think carefully in which subdirectory we will create the RStudio project. If we don’t store it somewhere sensible, it will be hard to find it in the future!"
  },
  {
    "objectID": "introduction.html#rstudio-project-folder-structure",
    "href": "introduction.html#rstudio-project-folder-structure",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.8 RStudio Project folder structure",
    "text": "1.8 RStudio Project folder structure\nThe files on our computer are organised into folders. RStudio Projects live in our computer’s normal folders - they placemark the working directory of each analysis project. These project folders can be viewed or moved around the same way we normally work with files and folders on our computer.\nThe proposed RStudio Project should contain the following sub-folders Figure 1.6:\n\ndata: data files of any kind, such as .csv, .xlsx, .txt, etc.\ndocuments: documents of any formats, such as .docx, .pdf, .tex, .Rmd, etc.\nfigures: plots, diagrams, and other figures\nscripts: all your R scripts and codes (.R extension)\n\nAdditionally, there are two important files in the project folder that are created automatically by Rstudio: name_of_project.Rproj, and .Rhistory:\n\nname_of_project.Rproj: contains options and meta-data of the project (encoding, the number of spaces used for indentation, whether or not to restore a workspace with launch, etc) and can also be used as a shortcut for opening the project directly from the filesystem.\n.Rhistory: contains a history of code executed\n\n\n\nFigure 1.6: Project folder structure\n\n\nIt is recommended to work with RStudio Projects. This enables us to switch between different projects without getting the data, scripts, or output files all mixed up. Everything gets read in or saved to the correct place. No more exporting a plot and then going through the various Documents, etc., folders on our computer trying to figure out where our plot might have been saved to. It got saved to the project folder."
  },
  {
    "objectID": "introduction.html#quitting-r-rstudio",
    "href": "introduction.html#quitting-r-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.9 Quitting R & RStudio",
    "text": "1.9 Quitting R & RStudio\nWhen we quit RStudio we will be asked whether to save workspace with two options:\n\n“Yes” – Our current R workspace (containing the work that we have done) will be restored next time we open RStudio.\n“No” – We will start with a fresh R session next time we open RStudio. For now select “No” to prevent errors being carried over from previous sessions."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "2  R functions",
    "section": "",
    "text": "In programming, we use functions to incorporate sets of commands that we want to use repeatedly or that, because of their complexity, are better self-contained in a sub program and called when needed.\nWe have already used some R functions searching for help (i.e., help(), example(), apropos()). Most of the computations in R involves using functions. The base version of R includes many other functions, and thousands of others can be added (by installing packages or by creating them from scratch).\nwhere arg1, arg2, … are called the arguments of the function, whereas value1 is the value given to the argument arg1, etc."
  },
  {
    "objectID": "functions.html#characteristics-of-r-functions",
    "href": "functions.html#characteristics-of-r-functions",
    "title": "2  R functions",
    "section": "\n2.1 Characteristics of R Functions",
    "text": "2.1 Characteristics of R Functions\nA. Name and argumnets of a function\n\nA function essentially has a name and a list of arguments separated by a comma.\n\nLet’s have look at an example:\n\nseq(from = 5, to = 8, by = 0.5)\n\n[1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\n\nThe function name is seq and it has three explicitly named arguments from, to and by. The arguments from and to are the start and end values of a sequence that we want to create, and by is the increment of the sequence.\nThe above result can also be obtained without naming the arguments as follows:\n\nseq(5, 8, 0.5)\n\n[1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\n\n\n\n\n\n\n\nName the arguments in the functions\n\n\n\nWe do not necessarily need to indicate the names of the arguments, but only the values, as long as we follow their order. However, it’s a good idea to name at least some of the arguments in the functions. This practice minimizes errors assigning unnamed arguments to options and makes code more readable.\n\n\n \nB. Positional matching of arguments\nAnd what about this?\n\nseq(5, 8)\n\n[1] 5 6 7 8\n\n\nThis result demonstrates something about how R resolves function arguments.\n\nIf we don’t use argument names, R will match the arguments in the order that they appeared (positional matching).\n\nHere, it is assumed that we want a sequence from = 5 that goes to = 8. Since we didn’t specify step size, the default value of by in the function definition is used, which ends up being 1 in this case.\nMoreover, the seq() function has other arguments that we could use which are documented in the help page running ?seq. For example, we could use the argument length.out (instead of by) to fix the length of the sequence as follows:\n\nseq(from = 5, to = 8, length.out = 16)\n\n [1] 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0\n\n\n \nC. Required and optional arguments\n\nSome arguments in a function are required while others may be optional. We can use args() for displaying the argument names and corresponding default values of a function.\n\nLet’s see for example the log() function:\n\nargs(log)\n\nfunction (x, base = exp(1)) \nNULL\n\n\nIn the log() function x is a required argument while base is an optional argument and comes with a default value exp(1).\nIf we don’t supply a value for base, R will use the default value exp(1):\n\nlog(15)  # R uses the default value of `exp(1)`\n\n[1] 2.70805\n\n\nOtherwise, R will use for base the value that we supply:\n\nlog(15, base = 10)  # R uses our value 10\n\n[1] 1.176091\n\n\nIn contrast, x is a required argument because if we don’t supply x argument the log() function will fail:\n\nlog(base=10)\n\nError: argument x is missing, with no default\n\n\n\n\n\n\nRequired and optional arguments\n\n\n\nFor R functions, some arguments must be specified (they are required) and others are optional (because a default value is already given in the code of the function).\n\n\n \nNot all functions have (or require) arguments.\nFor example:\n\ndate()\n\n[1] \"Tue Sep  6 17:21:59 2022\"\n\n\n\n\n\n\n\n\nPlaying with the arguments in several different ways\n\n\n\nTo calculate the natural logarithm of 3, any of the following expressions can be used:\n\nlog(3)\nlog(x=3)\nlog(x=3, base=exp(1))\nlog(x=3, exp(1))\nlog(3, base=exp(1))\nlog(3, exp(1))\n\nlog(base=exp(1), 3)\nlog(base=exp(1), x=3)\n\n\n\n \n\n\n\n\n\n\nCaution\n\n\n\nNote that calling\n\nlog(exp(1), 3)\n\ncalculates the logarithm of exp(1) in base 3.\n\n\n \nD. Functions “live” in packages\n\nFunctions “live” in Base R and in R packages!\n\n\n\nFigure 2.1: Functions live inside the R packages that can be downloaded from the internet"
  },
  {
    "objectID": "functions.html#the-sessioninfo-and-option-functions",
    "href": "functions.html#the-sessioninfo-and-option-functions",
    "title": "2  R functions",
    "section": "\n2.2 The sessionInfo() and option() Functions",
    "text": "2.2 The sessionInfo() and option() Functions\nWe can obtain information about R, the OS and attached or loaded packages running the following function:\n\nsessionInfo()\n\n \nAdditionally, the options() function in R can be used to change various default behaviors. For example, the digits argument controls the number of digits to display in output. The current options are returned when options() is called, to allow them to be restored. The command help(options) lists all of the set table options.\n\nhelp(options)"
  },
  {
    "objectID": "functions.html#user-defined-functions-udf",
    "href": "functions.html#user-defined-functions-udf",
    "title": "2  R functions",
    "section": "\n2.3 User Defined Functions (UDF)",
    "text": "2.3 User Defined Functions (UDF)\nWe can create our own functions, using the function(), which is a very powerful way to extend R. Figure 2.2 displays the syntax for creating an R function.\n \n\n\nFigure 2.2: The syntax of a function in R\n\n\n \n\n\n\n\n\n\nWhat do we need to create a function?\n\n\n\n\nthe function’s name\nthe arguments of the function\nthe code of the function (statements)\n\n\n\nFor example a function that convert Celsius to Kelvin is:\n\ncelsius_to_kelvin <- function(temp_C) {\n  temp_K <- temp_C + 273.15\n  return(temp_K)\n}\n# freezing point of water in Kelvin\ncelsius_to_kelvin(0)\n\n[1] 273.15\n\n\nWe defined the function by “assigning” the function(temp_C) to the name celsius_to_kelvin using the assignment operator <- (see ).\nSo, in most cases, a function has a name (e.g., celsius_to_kelvin), some arguments used as input to the function, within the () following the keyword ‘function’ (e.g., temp_C); a body, which is the code within the curly braces {}, where we carry out the computation; and can have one or more return values (the output here is the temp_K which is a numeric value).\n\n\n\n\n\n\n Function components\n\n\n\n\n\nA function has three components:\n\nThe formals(), the list of arguments that control how you call the function.\nThe body(), the code inside the function.\nThe environment(), the data structure that determines how the function finds the values associated with the names.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where we defined the function. The function environment always exists, but it is only printed when the function isn’t defined in the R global environment. For example:\n\nformals(celsius_to_kelvin)         # the argument of the function\n\n$temp_C\n\nbody(celsius_to_kelvin)            # the code of the function\n\n{\n    temp_K <- temp_C + 273.15\n    return(temp_K)\n}\n\nenvironment(celsius_to_kelvin)     # the function's environment\n\n<environment: R_GlobalEnv>"
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "3  R packages",
    "section": "",
    "text": "R installs automatically a set of standard packages (base packages) during installation process. Base packages contain the basic functions that allow R to work, and enable standard statistical and graphical functions on data sets.\n\nMore packages can be added later from repositories, when they are needed for some specific purpose (add-on R packages). Add-on R packages are written by a world-wide community of developers and R users and most of them can be installed for free from repositories.\nA repository is a place where packages are located and stored so we can install them from it. Some of the most popular repositories for R packages are:\n\nCRAN: Comprehensive R Archive Network(CRAN) is the official repository.\nGithub: Github is the most popular repository for open source projects.\nBioconductor: Bioconductor is a topic-specific repository, intended for open source software for bioinformatics.\n\n \n\n\n\n\n\n\nAdd-on R packages\n\n\n\nAdd-on R packages extend the functionality of R by providing additional collection of functions, sample data, compiled code, some tests to check everything works as it should, and documentation for the package and the functions inside in a well-defined format.\n\n\nTo use an add-on package we need to:\n\nInstall the package from a repository. Once we’ve installed a package, we likely won’t install it again unless we want to update it to a newer version.\nLoad the package in R session. Add-on packages are not loaded by default when we start RStudio on our computer. Each add-on package needs to be loaded explicitly every time we start RStudio.\n\nFor example, among the many add-on packages, we will use in this textbook are the dplyr package for data wrangling, the ggplot2 package for data visualization and and the rstatix package for statistical tests.\nLet’s now show how to perform these two steps for the ggplot2 package for data visualization."
  },
  {
    "objectID": "packages.html#package-installation",
    "href": "packages.html#package-installation",
    "title": "3  R packages",
    "section": "\n3.2 Package installation",
    "text": "3.2 Package installation\nThere are two ways to install an add-on R package: an easy way and a more advanced way.\nA. Installing Packages Using RStudio UI\nLet’s install the rstatix package the easy way first as shown in Figure Figure 3.1. In the Q4 - files, plots, packages, help pane of RStudio:\n\nClick on the “Packages” tab.\nClick on “Install”.\nType the name of the package under “Packages (separate multiple with space or comma):” In this case, type rstatix.\nClick “Install.”\n\n\n\nFigure 3.1: Installing packages in R the easy way\n\n\nB. Installing packages from repositories using command\nFor installing the rstatix package from CRAN we type the following command in the console pane of RStudio and press Enter on our keyboard:\n\ninstall.packages(\"rstatix\")\n\nNote we must include the quotation marks around the name of the package.\nIn order to install several package at once, we just have to write:\n\ninstall.packages(c(\"rstatix\", \"dplyr\", \"ggplot2\"))\n\nWe only have to install a package once. However, if we want to update a previously installed package to a newer version, we need to re-install it by repeating the earlier steps.\nMoreover, suppose, for instance, that we want to download the development version of the rstatix package from GitHub. The first step is to install and load the devtools package, available in CRAN. On Windows, in case we encounter some error means we also need to install the Rtools. Then we can call the install_github() function to install the R package from GitHub.\nIn case we need to install an older version of a package the simplest method is to use the provided install_version() function of the devtools package to install the version we need."
  },
  {
    "objectID": "packages.html#package-loading",
    "href": "packages.html#package-loading",
    "title": "3  R packages",
    "section": "\n3.3 Package loading",
    "text": "3.3 Package loading\nRecall that after we’ve installed a package, we need to load it. In other words, we need to “open it.” We do this by using the library() command (note that the the quotation marks are not necessary when we are loading a package). For example, to load the rstatix package, run the following code in the console pane.\n\nlibrary(rstatix)\n\nIf after running the earlier code, a blinking cursor returns next to the > “prompt” sign in console, it means we were successful and the rstatix package is now loaded and ready to use. If however, we get a red “error message” that reads…\nError in library(rstatix) : there is no package called ‘rstatix’\n… it means that we didn’t successfully install it.\nThere is one way in R that can use a function without using library(). To do this, we can simply use the notation package::function .\nFor example:\n\nrstatix::t_test()\n\nThe above notation tells R to use the t_test function from rstatix without load the rstatix package.\n \n\n\n\n\n\n\nPackages Vs Libraries\n\n\n\nThere is always confusion between a package and a library, and we find people calling libraries as packages. The directories in R where the packages are stored are called the libraries."
  },
  {
    "objectID": "packages.html#the-tidyverse-package",
    "href": "packages.html#the-tidyverse-package",
    "title": "3  R packages",
    "section": "\n3.4 The {tidyverse} package",
    "text": "3.4 The {tidyverse} package\nIn this textbook we will use the tidyverse package. The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\nThe command install.packages(\"tidyverse\") will install the complete tidyverse. The tidyverse package provides a shortcut for downloading the following packages:\n\n\n [1] \"broom\"         \"cli\"           \"crayon\"        \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"readr\"        \n[21] \"readxl\"        \"reprex\"        \"rlang\"         \"rstudioapi\"   \n[25] \"rvest\"         \"stringr\"       \"tibble\"        \"tidyr\"        \n[29] \"xml2\"          \"tidyverse\"    \n\n\nWhen we load the tidyverse package with the command library(tidyverse), R will load the core tidyverse and make it available in our current R session (Figure 3.2):\n\n\nFigure 3.2: Hex logos for the eight core tidyverse packages and their primary purposes (Image from Mine Çetinkaya-Rundel).\n\n\n\n\n\n\n\n\nAdd-on R packages\n\n\n\nThe tidyverse packages out of the core list have more specialized usage and are not loaded automatically with library(tidyverse), so we’ll need to load each one with its own call to library()."
  },
  {
    "objectID": "packages.html#the-here-package",
    "href": "packages.html#the-here-package",
    "title": "3  R packages",
    "section": "\n3.5 The {here} package",
    "text": "3.5 The {here} package\nWe’ve talked about what Projects are and why we should use them, but what really makes Projects in RStudio shine is the use of the here() function from the {here} package. What here() does is eliminate the need for us to do what’s called “hard-coding” our file path.\n\nThe place where the file lives on our computer is called the path. We can think of the path as directions to the file. There are two kinds of paths: absolute paths and relative paths.\n\nFor example, suppose Alice and Bob are working on a project together and want to read in R studio of their computers a data set file named covid19.csv data. They could do this using either a relative or an absolute path. We show what both choices below:\nA. Reading data using an absolute path\nAlice’s file is stored at C:/alice/project/data/covid19.csv\nand the command in R script should be:\n\ncovid19 <- read_csv(\"C:/alice/project/data/covid19.csv\")  \n\nwhile Bob’s is stored at C:/bob/project/data/covid19.csv\nand the command in R script should be:\n\ncovid19 <- read_csv(\"C:/bob/project/data/covid19.csv\")\n\nEven though Alice and Bob stored their files in the same place on their computers (in their C disk), the absolute paths are different due to their different usernames. If Bob has code that loads the covid19.csv data using an absolute path, the code won’t work on Alice’s computer.\n \nB. Reading data using a relative path\nThe command in R script should be:\n\ncovid19 <- read_csv(here(\"data\", \"covid19.csv\"))\n\nWhat here() does is tell R that the file structure starts at the Project-level, and so every subsequent call starts at the Project-level, and allows us to navigate throughout each of the folders and files within a given Project.\nThe relative path from inside the project folder (data/covid19.csv) is the same on both computers; any code that uses relative paths will work on both!"
  },
  {
    "objectID": "calculations.html",
    "href": "calculations.html",
    "title": "4  Calculations",
    "section": "",
    "text": "The simplest thing we could do with R is do arithmetic with numbers. For example:\n\n1 + 100\n\n[1] 101\n\n\nR printed out the answer, with a preceding [1].\n \n\nThe basic arithmetic operators are presented in Figure Figure 4.1:\n\n\nFigure 4.1: Arithmetic operators\n\n\nRemember when using R as a calculator, the order of operations is the same as we would have learned back in school.\nFrom highest to lowest precedence:\n\nParentheses: ( )\n\nExponents: ^ or **\n\nDivide: /\n\nMultiply: *\n\nAdd: +\n\nSubtract: -\n\n\nTherefore:\n\n3 + 5 * 2\n\n[1] 13\n\n\n \n\nUse parentheses to group operations in order to force the order of evaluation if it differs from the default, or to make clear what we intend.\n\n(3 + 5) * 2\n\n[1] 16\n\n\nThis can get unwieldy when not needed, but clarifies our intentions. Remember that others may later read our code.\n\n(3 + (5 * (2 ^ 2))) # hard to read\n3 + 5 * 2 ^ 2       # clear, if we remember the rules\n3 + 5 * (2 ^ 2)     # if we forget some rules, this might help\n\n\n\n\n\n\n\nComments with #\n\n\n\nThe text after each line of code is called a comment. Anything that follows after the hash symbol # is ignored by R when it executes code. It is considered good practice to comment your code when working in an .R script."
  },
  {
    "objectID": "calculations.html#mathematical-functions",
    "href": "calculations.html#mathematical-functions",
    "title": "4  Calculations",
    "section": "\n4.2 Mathematical functions",
    "text": "4.2 Mathematical functions\nR has many built in mathematical functions. To call a function, we simply type its name, followed by open and closing parentheses. Remember that anything we type inside the parentheses are called the function’s arguments.\nExamples\n\n\n\n\n\n\nTrigonometry functions (angles in radians)\n\n\n\n\nsin(pi/2) \n\n[1] 1\n\ncos(pi)\n\n[1] -1\n\n\n\n\n \n\n\n\n\n\n\nLogarithms and exponentials\n\n\n\n\nlog(100) # natural logarithm\n\n[1] 4.60517\n\nlog10(100) # base-10 logarithm\n\n[1] 2\n\nexp(0.5) # exponential e^(1/2)\n\n[1] 1.648721\n\n\n\n\n \n\n\n\n\n\n\nOther mathematical functions\n\n\n\n\nsqrt(9)    # squared root\n\n[1] 3\n\nabs(-9)   # absolute value\n\n[1] 9\n\n\n\n\n \nThe round() function is often very useful. The round function follows the rounding principle. By default, we will get the nearest integer. For example:\n\nround(7 / 3)  # rounding 7/3 (2.333) to the nearest integer\n\n[1] 2\n\n\nIf we want to control the approximation accuracy, we can add a digits argument to specify how many digits we want after the decimal point. For example:\n\nround(7 / 3, digits = 2)  # rounding 7/3 to two decimal places\n\n[1] 2.33\n\n\n \n\n\n\n\n\n\nRound rule when the dropped digit is 5\n\n\n\nIf the first digit that is dropped is exactly 5, R uses a rule that’s common in programming languages: Always round to the nearest even number. For example:\n\nround(1.5)\n\n[1] 2\n\nround(2.5)\n\n[1] 2\n\nround(4.5)\n\n[1] 4\n\nround(5.5)\n\n[1] 6"
  },
  {
    "objectID": "lab1.html",
    "href": "lab1.html",
    "title": "5  LAB II: Descriptive Statistics",
    "section": "",
    "text": "\\(\\equiv\\)"
  }
]