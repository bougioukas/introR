[
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "An Introduction to R",
    "section": "License",
    "text": "License\nThis textbook is free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction to R and Rstudio",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "introduction.html#installing-r-and-rstudio",
    "href": "introduction.html#installing-r-and-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.1 Installing R and RStudio",
    "text": "1.1 Installing R and RStudio\nFirst things first. We need to download and install both R and RStudio (an integrated development environment for R) on our personal computer. First, we install R, then we will need to install RStudio.\n\nFirst, we must Download and install R:\n\n\nIf our operating system (OS) is Windows: we click on “Download R for Windows”, then click on “base”, then click on the Download link.\nIf our operating system (OS) is macOS: we click on “Download R for (Mac) OS X”, then under “Latest release:” click on R-X.X.X.pkg, where R-X.X.X is the version number.\n\n\nSecond, we must Download and install RStudio:\n\n\nWe scroll down near the bottom of the page.\nWe click on the download link corresponding to your computer’s operating system.\n\nWe follow the usual installation procedures for R and RSudio."
  },
  {
    "objectID": "introduction.html#what-are-r-and-rstudio",
    "href": "introduction.html#what-are-r-and-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.2 What are R and RStudio?",
    "text": "1.2 What are R and RStudio?\nWe will use R via RStudio. Beginners often confuse the two applications. Using an analogy, R is like an airplane’s engine while RStudio is like an airplane’s dashboard (Figure 1.1).\nSpecifically, R is a statistical programming language (an implementation of the S programming language) and a powerful graphics engine, which was created by Ross Ihahka and Robert Gentleman at the University of Auckland in 1993.\nThe name R for the language was coined after the initials of the forenames of the inventors, plus the influence of the S language.\nR does all the heavy work (like an airplane engine) while RStudio is an integrated development environment (IDE) that was founded by J.J. Allaire in 2009. RStudio provides a friendly interface by adding a plenty of great features, auto-complete functions and tools (like an airplane dashboard with electronic monitors, and navigation systems) and makes life a lot easier.\n\n\nFigure 1.1: Analogy of difference between R and RStudio\n\n\nAfter we install R and RStudio on our computer, we’ll have two new programs (also called applications) we can open. In this textbook, we’ll always work in RStudio.\n\n\n\n\n\n\nWhy R Programming Language?\n\n\n\n\nR programming is used as a leading tool for machine learning, statistics, and data analysis. Objects, functions, and packages can easily be created by R.\nIt’s a platform-independent language. This means it can be applied to all operating systems.\nIt’s an open-source free language. That means anyone can install it in any organization without purchasing a license.\nR programming language is not only a statistic software but also allows us to integrate with other languages (C, C++). Thus, we can easily interact with many data sources and statistical tools.\nThe R programming language has a vast community of users and it’s growing day by day.\nR is currently one of the most requested programming languages in the Data Science job market that makes it the hottest trend nowadays."
  },
  {
    "objectID": "introduction.html#starting-r-rstudio",
    "href": "introduction.html#starting-r-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.3 Starting R & RStudio",
    "text": "1.3 Starting R & RStudio\nAfter the RStudio installation is finished, click the RStudio icon \nR starts automatically when we open RStudio Figure 1.2 and we are greeted by three panes:\n\n\nFigure 1.2: RStudio Screenshot with Console on the left and Help tab in the bottom right.\n\n\nThe three main panes that divide the screen are:\n\nthe large Console pane on the left runs R code.\n\nthe workspace pane, which includes the Environment and History tabs, in the upper right.\n\nThe Environment tab keeps track of the objects we create as we work with R (a major part of our tasks involves creating objects).\nThe History tab tracks all of the commands that we have sent to the R console in the session.\n\n\n\nthe Files/Plots/Packages/Help/Viewer pane in the lower right.\n\nThe Files tab lets us create new folders (directories) on our computer, as well as copy, move, delete, or rename files.\nThe Plots tab holds graphs and charts we generate from our data and during the analysis.\nThe Packages tab lists of all the R packages installed on our hard drive and indicates whether or not they are currently loaded. We’ll discuss packages in more detail in the next sections.\nThe Help tab, provides links to search for help directly from our RStudio window.\nThe Viewer tab in RStudio allows us to view local web content (e.g., to view an html table).\n\n\n\nThroughout this textbook, we’ll come to learn what purpose each of these panes serve.\n\n\n\n\n\n\nCommand prompt  >\n\n\n\nThe Console pane starts with information about the version number, license and contributors, and provides some guidance on how to get help. The last line is a standard command prompt (the greater than sign > symbol) that indicates R is ready and expecting instructions to do something.\n\n\n \nLet’s type 14 + 16 at the R command prompt and press Enter:\n\n14 + 16\n\n[1] 30\n\n\nSo what happened?\nWell, R gave us a response (output) to our input (14 + 16). That response came after we pressed the Enter key. It was [1] 30. It’s clear that 30 is the answer to the 14 + 16. However, what does the [1] mean? At this point we can pretty much ignore it, but technically it refers to the index of the first item on each line. (Sometimes R prints out many lines as an output. The number inside the brackets helps us figure out where in the sequence we are per line)."
  },
  {
    "objectID": "introduction.html#r-scripts",
    "href": "introduction.html#r-scripts",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.4 R scripts",
    "text": "1.4 R scripts\nOpen a new R script\nUsually, we do our programming by writing our code in script files. An R script (with the .R extension) is simply a text file in which our R code is stored, and then can be “sent” to the console, where R will execute it.\nIn the RStudio menu, we go to:\n\n\n\n\n\nflowchart LR\n  A[File] -.-> B(New File) -.-> C(R Script)\n\n\n\n\n\n\n\n\nAnother pane (Q1) is opened on the left above the interactive console Figure 1.3. This is where we can write a length script with lots of lines of code, and save the file for future use.\n\n\nFigure 1.3: RStudio Screenshot with four panes.\n\n\nTherefore, the RStudio window is divided into four panes (quadrants) that contain:\n\nQ1 - code editor (script)\nQ2 - console\nQ3 - environment (workspace), history\nQ4 - files, plots, packages, help, viewer (for local web content)\n\nWe can change the shape of the panes by either clicking the minimize or maximize buttons on the top right of each pane, or by clicking and dragging the middle of the borders of the windows.\nThe four panes might be in a different order that those in Figure 1.3. If we’d like, we can change the order of the windows under RStudio preferences. We select from RStudio menu:\n\n\n\n\n\nflowchart LR\n  A[Tools] -.-> B(Global Options) -.-> C(Pane layout)\n\n\n\n\n\n\n\n\n \nExecute the code written in R script\nNow, let’s type 14 + 16 at a new R script and press the run button . The result is printed in the console:\n\n\nFigure 1.4: The script pane.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn .R script, we can execute our code line by line (by putting the cursor on the line) or selecting a chunk of lines (by highlighting the text) and pressing the run button in the source window. We can also run our selected code using the keywboard shortcut Ctrl + Enter.\n\n\nComments can also be used to explain R code, and to make it more readable (it can also be used to prevent execution when testing alternative code). Comments start with a # . When executing the R-code, R will ignore anything that starts with #. It is considered good practice to comment our code when working in an .R script.\nKeyboard Shortcut for commenting out/commenting in multiple lines at a time: Control+Shift+C\n \n\n\n\n\n\n\nAdvantages writing our R code as an R script file\n\n\n\n\nWe can save and reuse our code\nWe can document our work (however, we can only include one-line comments and these must be prefixed with the hash symbol,  #)\nWe can share our work with others\nWe can move beyond writing one line of code at a time"
  },
  {
    "objectID": "introduction.html#errors-warnings-and-messages-in-r",
    "href": "introduction.html#errors-warnings-and-messages-in-r",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.5 Errors, warnings, and messages in R",
    "text": "1.5 Errors, warnings, and messages in R\nLet’s type the following at the R command prompt and press Enter:\n\nhello\n\nwe get the following error:Error: object ‘hello’ not found\nOne thing that intimidates new R and RStudio users is how it reports errors, warnings, and messages. R reports errors, warnings, and messages in a glaring red font, which makes it seem like it is scolding us. However, seeing red text in the console is not always bad.\nR will show red text in the console pane in three different situations:\n\nErrors: When the red text is a legitimate error, it will be prefaced with “Error…” and try to explain what went wrong. Generally when there’s an error, the code will not run.\nWarnings: When the red text is a warning, it will be prefaced with “Warning:” and R will try to explain why there’s a warning. Generally our code will still work, but with some caveats.\nMessages: When the red text doesn’t start with either “Error” or “Warning”, it’s just a friendly message.\n\nNow, let’s type the following:\n\n1 + 2 -\n+\n\n\n\n\n\n\n\nIf a command is not complete then R will show a Plus sign (+) prompt\n\n\n\nIf an R command is not complete then R will show a plus sign (+) prompt on second and subsequent lines until the command syntax is correct (this means that we can type something to finish the command we are trying to execute). We can also hit the escape key (ESC) to cancel whatever command R is waiting for us to finish."
  },
  {
    "objectID": "introduction.html#r-help-resources",
    "href": "introduction.html#r-help-resources",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.6 R Help resources",
    "text": "1.6 R Help resources\nBefore asking others for help, it’s generally a good idea for us to try to help ourself. It is strongly recommended to learn how to use R’s useful and extensive built-in help system which is an essential part of finding solutions to our R programming problems.\nWe can use the help() function or ? help operator which provide access to the R documentation pages for a specific term. For example, if we want information for the mean we type the following commands (which give the same result):\n\nhelp(mean)\n\nor\n\n?mean\n\n\n\nFigure 1.5: R help() function search for specific term such as mean\n\n\nSo, R tried to find something called mean (Figure 1.5).\n\n\n\n\n\n\nRecall a previously typed command in console\n\n\n\nIn console to recall a previously typed commands use the up arrow key (\\(\\uparrow\\)). To go between previously typed commands use the up and down arrow (\\(\\downarrow\\)) keys. To modify or correct a command use the left (\\(\\leftarrow\\)) and right arrow (\\(\\rightarrow\\)) keys.\n\n\nTwo question marks (??) will search R documentation for a phrase or term and it is a shortcut to help.search() function. So for example, let’s say we want to search documentation for linear regression analysis. Keep in mind if our phrase is more than one word long, we must put it in quotation marks.\n\n??\"linear regression\"\n\nTo do a keyword search use the apropos() command with the keyword in double quotes, \"keyword\", or single quote, 'keyword'. For example:\n\napropos(\"mean\")\n\nUse the example() command to run the examples at the end of the help for a function:\n\nexample(mean)\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nRStudio also provides search box in the “Help” tab to make our life easier (Figure 1.2).\nLike Google, but for R is the RSeek.Org. This is not included in R but is a great search engine built specifically for R-related queries.\nAdditionally, there are a lot of on-line resources that can help (e.g., R-bloggers). However, we must understand that blindly copying and pasting could be harmful and further it won’t help us to learn and develop."
  },
  {
    "objectID": "introduction.html#working-with-rstudio-projects",
    "href": "introduction.html#working-with-rstudio-projects",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.7 Working with RStudio Projects",
    "text": "1.7 Working with RStudio Projects\nWhen we are working in R, the program needs to know where to find inputs and deliver outputs, and will look first in what is called a “working directory”. Moreover, we want to organize all of the files for a given project in one folder, and that particular folder should be established as our working directory.\nCreate a new RStudio Project\nKeeping all the files associated with a project organized together – input data, R scripts, documents and figures – is such a wise and common practice that RStudio has built-in support for this via its projects. RStudio projects are associated with R working directories Figure 1.6.\nWe can create an RStudio project:\n\nIn a new directory\nIn an existing directory where we already have R code and data\nBy cloning a version control (Git or Subversion) repository\n\nLet’s create one to use for the rest of this textbook. From the RStudio menu:\n\n\n\n\n\nflowchart LR\n  A[File] -.-> B(New Project)\n\n\n\n\n\n\n\n\nThe directory name we choose here will be the project name. We call it whatever we want (e.g., introR).\n\n\nFigure 1.6: RStudio projects are associated with R working directories\n\n\n\n\n\n\n\n\nStore the RStudio Project somewhere sensible\n\n\n\nWe must think carefully in which subdirectory we will create the RStudio project. If we don’t store it somewhere sensible, it will be hard to find it in the future!\n\n\n \nRStudio Project folder structure\nThe files on our computer are organised into folders. RStudio Projects live in our computer’s normal folders - they placemark the working directory of each analysis project. These project folders can be viewed or moved around the same way we normally work with files and folders on our computer.\nThe proposed RStudio Project should contain the following sub-folders Figure 1.7:\n\ndata: data files of any kind, such as .csv, .xlsx, .txt, etc.\ndocuments: documents of any formats, such as .docx, .pdf, .tex, .Rmd, etc.\nfigures: plots, diagrams, and other figures\nscripts: all your R scripts and codes (.R extension)\n\nAdditionally, there are two important files in the project folder that are created automatically by Rstudio: name_of_project.Rproj, and .Rhistory:\n\nname_of_project.Rproj: contains options and meta-data of the project (encoding, the number of spaces used for indentation, whether or not to restore a workspace with launch, etc) and can also be used as a shortcut for opening the project directly from the filesystem.\n.Rhistory: contains a history of code executed\n\n\n\nFigure 1.7: Project folder structure\n\n\nIt is recommended to work with RStudio Projects. This enables us to switch between different projects without getting the data, scripts, or output files all mixed up. Everything gets read in or saved to the correct place. No more exporting a plot and then going through the various Documents, etc., folders on our computer trying to figure out where our plot might have been saved to. It got saved to the project folder."
  },
  {
    "objectID": "introduction.html#quitting-r-rstudio",
    "href": "introduction.html#quitting-r-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.8 Quitting R & RStudio",
    "text": "1.8 Quitting R & RStudio\nWhen we quit RStudio we will be asked whether to save workspace with two options:\n\n“Yes” – Our current R workspace (containing the work that we have done) will be restored next time we open RStudio.\n“No” – We will start with a fresh R session next time we open RStudio. For now select “No” to prevent errors being carried over from previous sessions."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "2  R functions",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "functions.html#definition-of-function",
    "href": "functions.html#definition-of-function",
    "title": "2  R functions",
    "section": "\n2.1 Definition of function",
    "text": "2.1 Definition of function\nIn programming, we use functions to incorporate sets of commands that we want to use repeatedly or that, because of their complexity, are better self-contained in a sub program and called when needed.\nWe have already used some R functions searching for help (i.e., help(), example(), apropos()). Most of the computations in R involves using functions. The base version of R includes many other functions, and thousands of others can be added (by installing packages or by creating them from scratch).\n\nA function in R is defined by its name and by the list of its arguments: function_name(arg1 = val1, arg2 = val2, ...)\n\nwhere arg1, arg2, … are called the arguments of the function, whereas value1 is the value given to the argument arg1, etc.\n\n\n\n\n\n\nCall a function\n\n\n\nTo call a function in R, we simply type its name, followed by open and closing parentheses. Anything we type inside the parentheses are the function’s arguments."
  },
  {
    "objectID": "functions.html#characteristics-of-r-functions",
    "href": "functions.html#characteristics-of-r-functions",
    "title": "2  R functions",
    "section": "\n2.2 Characteristics of R Functions",
    "text": "2.2 Characteristics of R Functions\nA. Name and argumnets of a function\n\nA function essentially has a name and a list of arguments separated by a comma.\n\nLet’s have look at an example:\n\nseq(from = 5, to = 8, by = 0.5)\n\n[1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\n\nThe function name is seq and it has three explicitly named arguments from, to and by. The arguments from and to are the start and end values of a sequence that we want to create, and by is the increment of the sequence.\nThe above result can also be obtained without naming the arguments as follows:\n\nseq(5, 8, 0.5)\n\n[1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\n\n\n\n\n\n\n\nName the arguments in the functions\n\n\n\nWe do not necessarily need to indicate the names of the arguments, but only the values, as long as we follow their order. However, it’s a good idea to name at least some of the arguments in the functions. This practice minimizes errors assigning unnamed arguments to options and makes code more readable.\n\n\n \nB. Positional matching of arguments\nAnd what about this?\n\nseq(5, 8)\n\n[1] 5 6 7 8\n\n\nThis result demonstrates something about how R resolves function arguments.\n\nIf we don’t use argument names, R will match the arguments in the order that they appeared (positional matching).\n\nHere, it is assumed that we want a sequence from = 5 that goes to = 8. Since we didn’t specify step size, the default value of by in the function definition is used, which ends up being 1 in this case.\nMoreover, the seq() function has other arguments that we could use which are documented in the help page running ?seq. For example, we could use the argument length.out (instead of by) to fix the length of the sequence as follows:\n\nseq(from = 5, to = 8, length.out = 26)  # 26 elements in the sequence\n\n [1] 5.00 5.12 5.24 5.36 5.48 5.60 5.72 5.84 5.96 6.08 6.20 6.32 6.44 6.56 6.68\n[16] 6.80 6.92 7.04 7.16 7.28 7.40 7.52 7.64 7.76 7.88 8.00\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe numbers inside the brackets, [1] and [16], helps us figure out where in the sequence we are per line. For example, [16] is the id number of the first value (6.80) returned on the second line. Obviously, this number may change depending on the width of the console.\n\n\n \nC. Required and optional arguments\n\nSome arguments in a function are required while others may be optional. We can use args() for displaying the argument names and corresponding default values of a function.\n\nLet’s see for example the log() function:\n\nargs(log)\n\nfunction (x, base = exp(1)) \nNULL\n\n\nIn the log() function x is a required argument while base is an optional argument and comes with a default value exp(1).\nIf we don’t supply a value for base, R will use the default value exp(1):\n\nlog(15)  # R uses the default value of `exp(1)`\n\n[1] 2.70805\n\n\nOtherwise, R will use for base the value that we supply:\n\nlog(15, base = 10)  # R uses our value 10\n\n[1] 1.176091\n\n\nIn contrast, x is a required argument because if we don’t supply x argument the log() function will fail:\n\nlog(base=10)\n\nError: argument x is missing, with no default\n\n\n\n\n\n\nRequired and optional arguments\n\n\n\nFor R functions, some arguments must be specified (they are required) and others are optional (because a default value is already given in the code of the function).\n\n\n \n\n\n\n\n\n\nPlaying with the arguments in several different ways\n\n\n\nTo calculate the natural logarithm of 3, any of the following expressions can be used:\n\nlog(3)\nlog(x=3)\nlog(x=3, base=exp(1))\nlog(x=3, exp(1))\nlog(3, base=exp(1))\nlog(3, exp(1))\n\nlog(base=exp(1), 3)\nlog(base=exp(1), x=3)\n\n\n\n \n\n\n\n\n\n\nCaution\n\n\n\nNote that calling\n\nlog(exp(1), 3)\n\ncalculates the logarithm of exp(1) in base 3.\n\n\n \nNot all functions have (or require) arguments.\nFor example:\n\ndate()\n\n[1] \"Thu Oct 20 21:14:43 2022\"\n\n\n \nD. Functions “live” in packages\n\nFunctions “live” in Base R and in R packages!\n\n\n\nFigure 2.1: Functions live inside the R packages that can be downloaded from the internet"
  },
  {
    "objectID": "functions.html#mathematical-functions",
    "href": "functions.html#mathematical-functions",
    "title": "2  R functions",
    "section": "\n2.3 Mathematical functions",
    "text": "2.3 Mathematical functions\nR has many built in mathematical functions such as the log(x) that we have already seen.\nLogarithms and exponents\n \n\n\nFigure 2.2: The natural logarithm function ln(x) is the inverse of the exponential function y = e^x\n\n\n\n\nTable 2.1: The Basic Properties of Logarithms and Exponents\n\nRule name\nLogarithms\nExponents\n\n\n\nProduct\n\\(log_a(x*y) = log_ax + log_ay\\)\n\\(a^x*a^y = a^{x+y}\\)\n\n\nQuotient\n\\(log_a(x/y) = log_ax - log_ay\\)\n\\(a^x/a^y = a^{x-y}\\)\n\n\nPower\n\\(log_a(x^y) = y \\cdot log_a(x)\\)\n\\((a^x)^y = a^{x*y}\\)\n\n\n\n\n \n\n\n\n\n\n\nExamples: Logarithms and exponents in R\n\n\n\n\nlog(100) # natural logarithm ln(x)\n\n[1] 4.60517\n\nlog10(100) # base-10 logarithm\n\n[1] 2\n\nexp(0.5) # exponential e^(1/2)\n\n[1] 1.648721\n\n\n\n\n \nTrigonometric functions\nTrigonometric functions define the relationship among the sides and angles of a right angle triangle (Figure 2.3 (a)). They also allow us to use angle measures, in radians or degrees, to find the coordinates of a point on a circle (e.g., unit circle)(Figure 2.3 (b)).\n\n\n\n\n(a) Right-Angled Triangle\n\n\n\n\n(b) Trigonometric circle\n\n\n\nFigure 2.3: Basic Trigonometry\n\n\nThe main functions in trigonometry are sine, cosine and tangent.\n\\[ sin(\\theta)=\\frac{opposite}{hypotenuse}  \\tag{2.1}\\] \\[ cos(\\theta)=\\frac{adjacent}{hypotenuse}  \\tag{2.2}\\] \\[ tan(\\theta)=\\frac{opposite}{adjacent}  \\tag{2.3}\\]\n \n\n\n\n\n\n\nExamples: Trigonometric functions in R (angles in radians)\n\n\n\n\nsin(pi/2)  # pi approximately equals  to 3.14\n\n[1] 1\n\ncos(pi)\n\n[1] -1\n\ntan(pi/3)\n\n[1] 1.732051\n\n\n\n\n \nOther mathematical functions\n\n\n\n\n\n\nExamples: Other mathematical functions\n\n\n\n\nsqrt(9)       # squared root\n\n[1] 3\n\nabs(-9)       # absolute value\n\n[1] 9\n\nsign(-9)      # the sign of the value, -1, 0, or 1\n\n[1] -1\n\nfactorial(3)  # factorial 3! = 1x2x3\n\n[1] 6\n\nchoose(6, 2)  # number of combinations without replacement 6!/(6-2)!2!\n\n[1] 15\n\n\n\n\n \nThe round() function\nThe round() function is often very useful. The round function follows the rounding principle. By default, we will get the nearest integer. For example:\n\nround(7 / 3)  # rounding 7/3 (2.333) to the nearest integer\n\n[1] 2\n\n\nIf we want to control the approximation accuracy, we can add a digits argument to specify how many digits we want after the decimal point. For example:\n\nround(7 / 3, digits = 2)  # rounding 7/3 to two decimal places\n\n[1] 2.33\n\n\n \n\n\n\n\n\n\nRound rule when the dropped digit is 5\n\n\n\nIf the first digit that is dropped is exactly 5, R uses a rule that’s common in programming languages: Always round to the nearest even number. For example:\n\nround(1.5)\n\n[1] 2\n\nround(2.5)\n\n[1] 2\n\nround(4.5)\n\n[1] 4\n\nround(5.5)\n\n[1] 6\n\n\n\n\nThere are a couple of further functions that can be useful:\n\nceiling(16.2)       # round to the nearest integer above\n\n[1] 17\n\nfloor(16.2)         # round to the nearest integer below\n\n[1] 16\n\ntrunc(125.2395)     #  truncates that values in the decimal places\n\n[1] 125\n\nsignif (2718214, 3)  # round to the specified number of significant digits\n\n[1] 2720000"
  },
  {
    "objectID": "functions.html#the-sessioninfo-and-option-functions",
    "href": "functions.html#the-sessioninfo-and-option-functions",
    "title": "2  R functions",
    "section": "\n2.4 The sessionInfo() and option() functions",
    "text": "2.4 The sessionInfo() and option() functions\nWe can obtain information about R, the OS and attached or loaded packages running the following function:\n\nsessionInfo()\n\n \nAdditionally, the options() function in R can be used to change various default behaviors. For example, the digits argument controls the number of digits to display in output. The current options are returned when options() is called, to allow them to be restored. The command help(options) lists all of the set table options.\n\nhelp(options)"
  },
  {
    "objectID": "functions.html#user-defined-functions-udf",
    "href": "functions.html#user-defined-functions-udf",
    "title": "2  R functions",
    "section": "\n2.5 User Defined Functions (UDF)",
    "text": "2.5 User Defined Functions (UDF)\nWe can create our own functions, using the function(), which is a very powerful way to extend R. Figure 2.4 displays the syntax for creating an R function.\n \n\n\nFigure 2.4: The syntax of a function in R\n\n\n \n\n\n\n\n\n\nWhat do we need to create a function?\n\n\n\n\nthe function’s name\nthe arguments of the function\nthe code of the function (statements)\n\n\n\nFor example a function that convert Celsius to Kelvin is:\n\ncelsius_to_kelvin <- function(temp_C) {\n  temp_K <- temp_C + 273.15\n  return(temp_K)\n}\n# freezing point of water in Kelvin\ncelsius_to_kelvin(0)\n\n[1] 273.15\n\n\nWe defined the function by “assigning” the function(temp_C) to the name celsius_to_kelvin using the assignment operator <- (see Chapter 5).\nSo, in most cases, a function has a name (e.g., celsius_to_kelvin), some arguments used as input to the function, within the () following the keyword ‘function’ (e.g., temp_C); a body, which is the code within the curly braces {}, where we carry out the computation; and can have one or more return values (the output here is the temp_K which is a numeric value).\n\n\n\n\n\n\n Function components\n\n\n\n\n\nA function has three components:\n\nThe formals(), the list of arguments that control how you call the function.\nThe body(), the code inside the function.\nThe environment(), the data structure that determines how the function finds the values associated with the names.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where we defined the function. The function environment always exists, but it is only printed when the function isn’t defined in the R global environment. For example:\n\nformals(celsius_to_kelvin)         # the argument of the function\n\n$temp_C\n\nbody(celsius_to_kelvin)            # the code of the function\n\n{\n    temp_K <- temp_C + 273.15\n    return(temp_K)\n}\n\nenvironment(celsius_to_kelvin)     # the function's environment\n\n<environment: R_GlobalEnv>"
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "3  R packages",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "packages.html#what-are-r-packages",
    "href": "packages.html#what-are-r-packages",
    "title": "3  R packages",
    "section": "\n3.1 What are R packages?",
    "text": "3.1 What are R packages?\nBase R packages\nR installs automatically a set of standard packages (base packages) during installation process. Base packages contain the basic functions that allow R to work, and enable standard statistical and graphical functions on data sets.\nAdd-on packages\nMore packages can be added later from repositories, when they are needed for some specific purpose (add-on R packages). Add-on R packages are written by a world-wide community of developers and R users and most of them can be installed for free from repositories.\nA repository is a place where packages are located and stored so we can install them from it. Some of the most popular repositories for R packages are:\n\nCRAN: Comprehensive R Archive Network(CRAN) is the official repository.\nGithub: Github is the most popular repository for open source projects.\nBioconductor: Bioconductor is a topic-specific repository, intended for open source software for bioinformatics.\n\n \n\n\n\n\n\n\nAdd-on R packages\n\n\n\nAdd-on R packages extend the functionality of R by providing additional collection of functions, sample data, compiled code, some tests to check everything works as it should, and documentation for the package and the functions inside in a well-defined format.\n\n\nTo use an add-on package we need to:\n\nInstall the package from a repository. Once we’ve installed a package, we likely won’t install it again unless we want to update it to a newer version.\nLoad the package in R session. Add-on packages are not loaded by default when we start RStudio on our computer. Each add-on package needs to be loaded explicitly every time we start RStudio.\n\nFor example, among the many add-on packages, we will use in this textbook are the dplyr package for data wrangling, the ggplot2 package for data visualization and and the rstatix package for statistical tests.\nLet’s now show how to perform these two steps for the ggplot2 package for data visualization."
  },
  {
    "objectID": "packages.html#package-installation",
    "href": "packages.html#package-installation",
    "title": "3  R packages",
    "section": "\n3.2 Package installation",
    "text": "3.2 Package installation\nThere are two ways to install an add-on R package: an easy way and a more advanced way.\nA. Installing Packages Using RStudio UI\nLet’s install the rstatix package the easy way first as shown in Figure Figure 3.1. In the Q4 - files, plots, packages, help pane of RStudio:\n\nClick on the “Packages” tab.\nClick on “Install”.\nType the name of the package under “Packages (separate multiple with space or comma):” In this case, type rstatix.\nClick “Install.”\n\n\n\nFigure 3.1: Installing packages in R the easy way\n\n\nB. Installing packages from repositories using command\nFor installing the rstatix package from CRAN we type the following command in the console pane of RStudio and press Enter on our keyboard:\n\ninstall.packages(\"rstatix\")\n\nNote we must include the quotation marks around the name of the package.\nIn order to install several package at once, we just have to write:\n\ninstall.packages(c(\"rstatix\", \"dplyr\", \"ggplot2\"))\n\nWe only have to install a package once. However, if we want to update a previously installed package to a newer version, we need to re-install it by repeating the earlier steps.\nMoreover, suppose, for instance, that we want to download the development version of the rstatix package from GitHub. The first step is to install and load the devtools package, available in CRAN. On Windows, in case we encounter some error means we also need to install the Rtools. Then we can call the install_github() function to install the R package from GitHub.\nIn case we need to install an older version of a package the simplest method is to use the provided install_version() function of the devtools package to install the version we need."
  },
  {
    "objectID": "packages.html#package-loading",
    "href": "packages.html#package-loading",
    "title": "3  R packages",
    "section": "\n3.3 Package loading",
    "text": "3.3 Package loading\nRecall that after we’ve installed a package, we need to load it. In other words, we need to “open it.” We do this by using the library() command (note that the the quotation marks are not necessary when we are loading a package). For example, to load the rstatix package, run the following code in the console pane.\n\nlibrary(rstatix)\n\nIf after running the earlier code, a blinking cursor returns next to the > “prompt” sign in console, it means we were successful and the rstatix package is now loaded and ready to use. If however, we get a red “error message” that reads…\nError in library(rstatix) : there is no package called ‘rstatix’\n… it means that we didn’t successfully install it.\nThere is one way in R that can use a function without using library(). To do this, we can simply use the notation package::function .\nFor example:\n\nrstatix::t_test()\n\nThe above notation tells R to use the t_test function from rstatix without load the rstatix package.\n \n\n\n\n\n\n\nPackages Vs Libraries\n\n\n\nThere is always confusion between a package and a library, and we find people calling libraries as packages. The directories in R where the packages are stored are called the libraries."
  },
  {
    "objectID": "packages.html#the-tidyverse-package",
    "href": "packages.html#the-tidyverse-package",
    "title": "3  R packages",
    "section": "\n3.4 The {tidyverse} package",
    "text": "3.4 The {tidyverse} package\nIn this textbook we will use the tidyverse package. The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\nThe command install.packages(\"tidyverse\") will install the complete tidyverse. The tidyverse package provides a shortcut for downloading the following packages:\n\n\n [1] \"broom\"         \"cli\"           \"crayon\"        \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"readr\"        \n[21] \"readxl\"        \"reprex\"        \"rlang\"         \"rstudioapi\"   \n[25] \"rvest\"         \"stringr\"       \"tibble\"        \"tidyr\"        \n[29] \"xml2\"          \"tidyverse\"    \n\n\nWhen we load the tidyverse package with the command library(tidyverse), R will load the core tidyverse and make it available in our current R session (Figure 3.2):\n\n\nFigure 3.2: Hex logos for the eight core tidyverse packages and their primary purposes (Image from Mine Çetinkaya-Rundel).\n\n\n\n\n\n\n\n\nAdd-on R packages\n\n\n\nThe tidyverse packages out of the core list have more specialized usage and are not loaded automatically with library(tidyverse), so we’ll need to load each one with its own call to library()."
  },
  {
    "objectID": "packages.html#the-here-package",
    "href": "packages.html#the-here-package",
    "title": "3  R packages",
    "section": "\n3.5 The {here} package",
    "text": "3.5 The {here} package\nWe’ve talked about what Projects are and why we should use them, but what really makes Projects in RStudio shine is the use of the here() function from the {here} package. What here() does is eliminate the need for us to do what’s called “hard-coding” our file path.\n\nThe place where the file lives on our computer is called the path. We can think of the path as directions to the file. There are two kinds of paths: absolute paths and relative paths.\n\nFor example, suppose Alice and Bob are working on a project together and want to read in R studio of their computers a data set file named covid19.csv data. They could do this using either a relative or an absolute path. We show what both choices below:\nA. Reading data using an absolute path\nAlice’s file is stored at C:/alice/project/data/covid19.csv\nand the command in R script should be:\n\ncovid19 <- read_csv(\"C:/alice/project/data/covid19.csv\")  \n\nwhile Bob’s is stored at C:/bob/project/data/covid19.csv\nand the command in R script should be:\n\ncovid19 <- read_csv(\"C:/bob/project/data/covid19.csv\")\n\nEven though Alice and Bob stored their files in the same place on their computers (in their C disk), the absolute paths are different due to their different usernames. If Bob has code that loads the covid19.csv data using an absolute path, the code won’t work on Alice’s computer.\n \nB. Reading data using a relative path\nThe command in R script should be:\n\ncovid19 <- read_csv(here(\"data\", \"covid19.csv\"))\n\nWhat here() does is tell R that the file structure starts at the Project-level, and so every subsequent call starts at the Project-level, and allows us to navigate throughout each of the folders and files within a given Project.\nThe relative path from inside the project folder (data/covid19.csv) is the same on both computers; any code that uses relative paths will work on both!"
  },
  {
    "objectID": "packages.html#the-reprex-package",
    "href": "packages.html#the-reprex-package",
    "title": "3  R packages",
    "section": "\n3.6 The {reprex} package",
    "text": "3.6 The {reprex} package\nIf we are looking for help with an rstats problem, it is recommend that we:\n  do not email an individual author or open source software (OSS) maintainer\n   create a minimum reproducible example (a reprex) demonstrating your problem\n   post on a public forum like RStudio Community or Stack Overflow\nWhat is a reprex?\nThe purpose of a reprex is to illustrate a particular outcome. The reader should know what outcome to expect. The reprex should do that one thing, and only that thing.\nThe reprex should be able to be run by any user who so wishes and return the exact same result.\nIt contains only the functions that are absolutely necessary to illustrate the point. If this is in the context of data analysis, the included dataset is as small as possible.\nWhy would we need a reprex?\n\nTo demonstrate an issue or bug in our code\nTo demonstrate a solution to an issue or bug in someone else’s code\nTo document a useful snippet of code for future reference\nUsing the reprex package\nIf we install reprex package we can use a function, reprex() to generate clean example code, with commented output. Of course, we need to create the minimal code our-self, but once we have it, calling the reprex function adds in the output so that others can see exactly what our computer returned. It’s a minor change but can make all the difference to someone who wants to help us.\n\n\nFigure 3.3: A reprex example."
  },
  {
    "objectID": "calculations.html",
    "href": "calculations.html",
    "title": "4  Calculations in R",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "calculations.html#arithmetic-operators-in-r",
    "href": "calculations.html#arithmetic-operators-in-r",
    "title": "4  Calculations in R",
    "section": "\n4.1 Arithmetic Operators in R",
    "text": "4.1 Arithmetic Operators in R\nThe simplest thing we could do with R is arithmetic operations with numbers. For example:\n\n1 + 100 \n\n[1] 101\n\n\nR printed out the result, with a preceding [1].\n \nIn the previous calculation the + sign was used to carry out the addition. Table 4.1 presents a list of arithmetic operators available in R.\n\n\nTable 4.1: Arithmetic Operators in R\n\nOperator\nDescription\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^\nexponent\n\n\n%%\nmodulus (remainder from division)\n\n\n%/%\ninteger division\n\n\n\n\nRemember when using R as a calculator, the order of operations is the same as we would have learned back in school.\nFrom highest to lowest precedence:\n\nParentheses: ( )\n\nExponents: ^ or **\n\nDivision: /\n\nMultiplication: *\n\nAddition: +\n\nSubtraction: -\n\n\nTherefore:\n\n3 + 5 * 2\n\n[1] 13\n\n\n \nParentheses\nUse parentheses to group operations in order to force the order of evaluation if it differs from the default, or to make clear what we intend.\n\n(3 + 5) * 2\n\n[1] 16\n\n\nThis can get unwieldy when not needed, but clarifies our intentions. Remember that others may later read our code.\n\n(3 + (5 * (2 ^ 2))) # hard to read\n3 + 5 * 2 ^ 2       # clear, if we remember the rules\n3 + 5 * (2 ^ 2)     # if we forget some rules, this might help\n\n\n\n\n\n\n\nImportant\n\n\n\nRemember that the text after each line of code is a comment. Anything that follows after the hash symbol # is ignored by R when executes code.\n\n\n \nModular arithmetic\nSuppose we want to know the integer part of a division: say, how many 13s there are in 119:\n\n119 %/% 13\n\n[1] 9\n\n\nNow suppose we wanted to know the remainder (what is left over when 119 is divided by 13): in maths this is known as 119 modulo 13, and the value 13 is known as the modulus:\n\n119 %% 13\n\n[1] 2\n\n\nModulo is very useful for testing whether one number is an exact multiple of some other number. For example, to find out whether 15421 is a multiple of 7:\n\n15421 %% 7\n\n[1] 0\n\n\nIt is as there is no remainder. We can then carry out more complex modular arithmetic:\n\n(123 + 456) %% 19\n\n[1] 9\n\n\nBut don’t forget to put brackets around the expression for which we want to carry out the modular calculation."
  },
  {
    "objectID": "calculations.html#relational-operators-in-r",
    "href": "calculations.html#relational-operators-in-r",
    "title": "4  Calculations in R",
    "section": "\n4.2 Relational Operators in R",
    "text": "4.2 Relational Operators in R\nRelational (or comparison) operators are used to compare between values. Comparisons in R typically evaluate to TRUE or FALSE (which in certain circumstances we can abbreviate to T and F). Here is a list of relational operators available in R (Table 4.2).\n\n\nTable 4.2: Relational (comparison) operators in R\n\nsymbol\nread as\n\n\n\n<\nless than\n\n\n>\ngreater than\n\n\n==\nequal to\n\n\n<=\nless than or equal to\n\n\n>=\ngreater than or equal to\n\n\n!=\nnot equal to\n\n\n\n\nSome simple comparisons with integer numbers follow:\n\n\n\n\n\n\nExamples\n\n\n\n\n2 < 1  # less than\n\n[1] FALSE\n\n\n\n1 > 0  # greater than\n\n[1] TRUE\n\n\n\n1 == 1  # equal to (double equal sign for equality)\n\n[1] TRUE\n\n\n\n1 <= 1  # less than or equal to\n\n[1] TRUE\n\n\n\n-9 >= -3 # greater than or equal to\n\n[1] FALSE\n\n\n\n1 != 2  # not equal to (inequality)\n\n[1] TRUE"
  },
  {
    "objectID": "calculations.html#floating-point-number",
    "href": "calculations.html#floating-point-number",
    "title": "4  Calculations in R",
    "section": "\n4.3 Floating point number",
    "text": "4.3 Floating point number\nWhen dealing with real numbers floating point number, we must be very careful when checking equality.\nFor example, we know from trigonometry that:\n\\[\\cos(\\frac{\\pi}{2}) = \\cos( \\frac{3 \\pi}{2}) = 0  \\]\nHowever, if we compare the two numbers we get:\n\ncos(pi/2) == cos(3*pi/2)\n\n[1] FALSE\n\n\nIn this instance, we can test for ‘near equality’ applying the all.equal() function which tests for equality with a difference tolerance of 1.5e-8.\n\nall.equal(cos(pi/2), cos(3*pi/2))\n\n[1] TRUE\n\n\nIf the difference is greater than the tolerance level 1.5e-8 the function will return the mean relative difference.\nTry to test this:\n\nall.equal(4.0000007, 4.0000008)\n\n\n\n\n\n\n\nDon’t use == to compare two numbers\n\n\n\nWe should never use == to compare two numbers unless they are integers (whole numbers) or fractions whose denominator is a power of 2 (\\(2^n\\), where n is integer). Computers may only represent decimal numbers with a certain degree of precision (rounded to typically 53 binary digits accuracy which allows representing decimal numbers to 15 or 16 significant digits), so two numbers which look the same when printed out by R, may actually have different underlying representations and therefore be different by a small margin of error (called Machine numeric tolerance)."
  },
  {
    "objectID": "calculations.html#scientific-notation",
    "href": "calculations.html#scientific-notation",
    "title": "4  Calculations in R",
    "section": "\n4.4 Scientific notation",
    "text": "4.4 Scientific notation\nScientific notation is a special way of expressing numbers that are too big or too small to be conveniently written in decimal form. Generally, it expresses numbers in forms of \\(m \\times 10^n\\) and R uses the e notation.\n\n\n\n\n\n\nExamples\n\n\n\n\n0.0055 is written \\(5.5 \\times 10^{-3}\\)\nbecause 0.0055 = 5.5 × 0.001 = 5.5 × \\(10^{-3}\\) or 5.5e-3\n0.000000015 is written \\(1.5 \\times 10^{-8}\\)\nbecause 0.000000015 = 1.5 × 0.00000001 = 1.5 × \\(10^{-8}\\) or 1.5e-8\n5500 is written \\(5.5 \\times 10^{3}\\)\nbecause 5500 = 5.5 × 1000 = 5.5 × \\(10^{3}\\) or 5.5e3\n150000000 is written \\(1.5 \\times 10^{8}\\)\nbecause 150000000 = 1.5 × 100000000 = 1.5 × \\(10^{8}\\) or 1.5e8\n\n\n\n\n\n\n\n\n\nScientific notation Vs Euler’s number\n\n\n\nNote that the e notation has nothing to do with the Euler’s number e=2.718 ."
  },
  {
    "objectID": "calculations.html#special-values-in-r",
    "href": "calculations.html#special-values-in-r",
    "title": "4  Calculations in R",
    "section": "\n4.5 Special values in R",
    "text": "4.5 Special values in R\nThere are a few special values that are used in R.\nMissing values (NA)\nFor example, in the real world, missing values may occur when recording sensor information. R uses a special numeric value NA standing for “Not available” and represents a missing value. Mathematical functions/operations using NA produces NA:\n\ncos(NA)\n\n[1] NA\n\n\n\n1 + NA\n\n[1] NA\n\n\n \nInfinitive: -Inf or Inf\nThere is also a special number Inf which represents infinity. Fortunately, R has special numbers for this.\nThis allows us to represent entities like:\n\n1/0\n\n[1] Inf\n\n\nThe Inf can also be used in ordinary calculations:\n\nexp(-Inf)\n\n[1] 0\n\n\n \nNot A Number (NaN)\nThe value NaN (stands for “not a number”) represents an undefined value and it is usually the product of some arithmetic operations. For example:\n\nInf/Inf\n\n[1] NaN\n\n\n\n0/0\n\n[1] NaN\n\n\n\ncos(Inf)\n\nWarning in cos(Inf): NaNs produced\n\n\n[1] NaN\n\n\n \nNULL\nAdditionally, there is a null object in R, represented by the symbol NULL. (The symbol NULL always points to the same object.) NULL is often used as an argument in functions to mean that no value was assigned to the argument. Additionally, some functions may return NULL. Note that NULL is not the same as NA, Inf, -Inf, or NaN."
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "5  R objects",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "objects.html#what-are-the-objects-in-r",
    "href": "objects.html#what-are-the-objects-in-r",
    "title": "5  R objects",
    "section": "\n5.1 What are the objects in R",
    "text": "5.1 What are the objects in R\nR works with objects (it is an object-oriented programming language). All the things that we manipulate or encounter in R such as numbers, data structures, functions, the results from a function (e.g., graphs) are types of objects. Some objects come with the packages in R. Other objects are user-created. User-created objects have names that are assigned by the user. R has a workspace known as the global environment that can be used to store objects.\nObjects in R can have many properties associated with them, called attributes. These properties explain what an object represents and how it should be interpreted by R. Two of the most important attributes of an R object are the class and the dimension of the object.\nAttributes of an object (if any) can be accessed using the attributes() function. Not all R objects contain attributes, in which case the attributes() function returns NULL.\nFor example, the attributes of the famous iris data set is a data.frame that contains 150 rows and 5 columns:\n\nclass(iris); dim(iris)   # Note: R commands can be separated by a semicolon\n\n[1] \"data.frame\"\n\n\n[1] 150   5\n\nattributes(iris)\n\n$names\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n[145] 145 146 147 148 149 150\n\n\n\n\n\n\n\n\nAvoid to separate R commands with a semicolon\n\n\n\nR commands are usually separated by a new line but they can also be separated by a semicolon (;). However, this is bad practice and should be avoided wherever possible: it can lead to code that is difficult to follow."
  },
  {
    "objectID": "objects.html#named-storage-of-objects",
    "href": "objects.html#named-storage-of-objects",
    "title": "5  R objects",
    "section": "\n5.2 Named storage of objects",
    "text": "5.2 Named storage of objects\nAssignment operator (<-)\nIn R we can store things in objects using the leftward assignment operator (<-) which is an arrow that points to the left, created with the less-than (<) sign and the hyphen (-) sign (keyboard shortcut: Alt + - for Windows and Option + - for Mac).\nFor example, suppose we would like to store the number 1/40 for future use. We will assign this value to an object called x:\n\nx <- 1/40\n\nNotice that assignment does not print a value. Instead, R stores it for later in the object x. Call object x now and see that it contains the value 0.025:\n\nx\n\n[1] 0.025\n\n\nIf we look for the Environment tab in one of the panes of RStudio, we will see that x and its value have appeared.\n \n\n\n\n\n\n\nHow to print the results of assignment immediately\n\n\n\nSurrounding the assignment with parentheses results in both assignment and print to screen to happen. For example:\n\n(x <- 1/40)\n\n[1] 0.025\n\n\n\n\n \nOur object x can be used in place of a number in any calculation that expects a number. For example:\n\nlog(x)\n\n[1] -3.688879\n\n\n \n\n\n\n\n\n\nUse space before and after operators (Highly Recommended)\n\n\n\nIt is important the space before and after comparison operators and assignments. For example, suppose we want to code the expression x smaller than -1/50 (note that x is 1/40):\n\n\nWith spaces\n\n\nx < -1/50    # with spaces \n\n[1] FALSE\n\n\nThe result is the logical FALSE because the value x (equals to 1/40) is higher than -1/50.\n\n\nWithout spaces\n\n\nx<-1/50    # without spaces\nx\n\n[1] 0.02\n\n\nIf we omit the spaces we end up with the assignment operator and we have x <- 1/50 which equals to 0.02.\n\n\n \nOther types of assignment\nIt is also possible to use the = or -> rightward operator for assignment (but these are much less common among R users).\nFor example:\n\nx = 1/40\nx\n\n[1] 0.025\n\n\nor\n\n1/40 -> x\nx\n\n[1] 0.025\n\n\nIt is a good idea to be consistent with the operator we use."
  },
  {
    "objectID": "objects.html#reassigning-an-object",
    "href": "objects.html#reassigning-an-object",
    "title": "5  R objects",
    "section": "\n5.3 Reassigning an object",
    "text": "5.3 Reassigning an object\nNotice also that objects can be reassigned. For example, recall the x object:\n\nx\n\n[1] 0.025\n\n\nthen type the following:\n\nx <- 100\nx\n\n[1] 100\n\n\nx used to contain the value 0.025 and now it has the value 100.\nMoreover, assignment values can contain the object being assigned to:\n\nx <- x + 1 \nx\n\n[1] 101\n\n\nThe right hand side of the assignment can be any valid R expression and it is fully evaluated before the assignment takes place."
  },
  {
    "objectID": "objects.html#legal-object-names",
    "href": "objects.html#legal-object-names",
    "title": "5  R objects",
    "section": "\n5.4 Legal object names",
    "text": "5.4 Legal object names\nObject names must start with a letter and can contain letters, numbers, underscores ( _ ) and periods (.). They cannot start with a number or underscore, nor contain spaces at all. Moreover, they can not contain Reserved words.\nDifferent people use different conventions for long object names, these include:\n\nperiods.between.words\nunderscores_between_words\ncamelCaseToSeparateWords\n\nWhat we use is up to us, but we must be consistent. We might ask help:\n\n??make.names\n??clean_names\n\n\n\n\n\n\n\nR is case-sensitive\n\n\n\nR treats capital letters differently from lower-case letters.\n\n\n\nY <- 50\nY\n\nbut…\n\ny\n\nError: object ‘y’ not found"
  },
  {
    "objectID": "objects.html#we-are-not-limited-to-store-numbers-in-objects",
    "href": "objects.html#we-are-not-limited-to-store-numbers-in-objects",
    "title": "5  R objects",
    "section": "\n5.5 We are not limited to store numbers in objects",
    "text": "5.5 We are not limited to store numbers in objects\nIn objects we can also store other data types. For example, we can store strings of characters:\n\nsentence <- \"the cat sat on the mat\"\n\nNote that we need to put strings of characters inside quotes.\n \nBut the type of data that is stored in an object affects what we can do with it:\n\nsentence + 1\n\nError in sentence + 1: non-numeric argument to binary operator"
  },
  {
    "objectID": "vector.html",
    "href": "vector.html",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "vector.html#introduction-to-vectors-in-r",
    "href": "vector.html#introduction-to-vectors-in-r",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.1 Introduction to vectors in R",
    "text": "6.1 Introduction to vectors in R\nThe most fundamental concept in base R are the vectors. Vectors come in two flavours: atomic vectors and lists (generic vectors). The atomic vectors must have all elements of the same basic type (e.g., integers, characters). On the contrary, in the lists different elements can have different types (e.g., some elements may be integers and some characters).\nThe R language supports many types of data structures that we can use to organize and store information. We will see that complex structures such as matrices, arrays, and data frames can be created. Each data structure type serves a specific purpose and can contain specific kinds of data. They differ in terms of the type of data they can hold, how they’re created, their structural complexity, the RAM that they occupy, and the notation used to identify and access individual elements. So, it’s important to understand the differences between them so we can make the right choice based on our scenario. These data structures are schematically illustrated in Figure 6.1\n\n\n\n\nFigure 6.1: Data structures in R."
  },
  {
    "objectID": "vector.html#atomic-vectors",
    "href": "vector.html#atomic-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.2 Atomic vectors",
    "text": "6.2 Atomic vectors\nThere are four primary types of atomic vectors (also known as “atomic” classes):\n\nlogical\ninteger\ndouble\ncharacter (which may contain strings)\n\nCollectively integer and double vectors are known as numeric vectors.\nThere are also two rare types: complex and raw. We won’t discuss them further because complex numbers are rarely needed in statistics, and raw vectors are a special type that’s only needed when handling binary data (raw bytes).\nOne-element atomic vectors\nEach of the four primary types has a special syntax to create an individual value. R has no 0-dimensional or scalar types. Individual numbers or strings, are actually vectors of length one and in some instances we call them scalars.\nTherefore, an one-element vector (oev) is just a single value like a number and they can be used to construct more complex objects (longer vectors). We present some examples of one-element vectors for each of the four primary types (in order from least to most general):\n1. Logical one-element vector: Logical values are boolean values of TRUE or FALSE which can be abbreviated, when we type them as T or F (we do not suggest this).\n\n# Examples of logical one-element vectors (oev)\noev_a <- TRUE  # assign the TRUE value to an object named oev_a\noev_a          # call the object with its name\n\n[1] TRUE\n\noev_b <- FALSE\noev_b\n\n[1] FALSE\n\noev_c <- T\noev_c\n\n[1] TRUE\n\noev_d <- F\noev_d\n\n[1] FALSE\n\n\n \n2. Numeric (integer or double) one-element vector: Even if we see a number like 1 or 2 in R, which we might think of as integers, they are likely represented behind the scenes as 1.00 or 2.00. We need to place an “L” suffix for integer numbers. Doubles can be specified in decimal (e.g., 0.03) or scientific (e.g, 3e-2) format.\n\n# Examples of integer and double one-element vectors (oev)\noev_e <- 3L          # integer\noev_e\n\n[1] 3\n\noev_f <- 100L        # integer\noev_f\n\n[1] 100\n\noev_g <- oev_e / oev_f\noev_g               # double\n\n[1] 0.03\n\noev_scientific <- 3e-2\noev_scientific     # double\n\n[1] 0.03\n\n\n\n\n\n\n\n\nDouble format\n\n\n\nDouble format is a computer number format, usually occupying 64 bits in computer memory.\n\n\n \n3. Character one-element vector: One-element vectors can also be characters (also known as strings). In R, we denote characters using quotation marks ” or ’. Here are examples of character one-element vectors:\n\n# Examples of character one-element vectors (oev)\noev_h <- \"hello\"      # double quotation marks\noev_h\n\n[1] \"hello\"\n\noev_i <- 'covid-19'   # single quotation marks\noev_i\n\n[1] \"covid-19\"\n\noev_j <- \"I love data analysis\"\noev_j\n\n[1] \"I love data analysis\"\n\n\nR treats numeric and character one-element vectors differently. For example, while we can do basic arithmetic operations on numeric one-element vectors – they won’t work on character one-element vectors. If we try to perform numeric operations (like addition) on character one-element vector, we’ll get an error like the following:\n\nh <- \"1\"\nk <- \"2\"\nh + k\n\nError in h + k : non-numeric argument to binary operator\nIf we see an error like this one, it means that we’re trying to apply numeric operations to character objects that’s wrong.\nIt’s very rare that single values (one-element vectors) will be the center of an R session, so one of the first questions encountered when working with data in R is what sort of object should be used to hold collections of data. Next, we are going to talk about “longer” atomic vectors."
  },
  {
    "objectID": "vector.html#making-longer-atomic-vectors",
    "href": "vector.html#making-longer-atomic-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.3 Making longer atomic vectors",
    "text": "6.3 Making longer atomic vectors\nAtomic vectors can consisted of more than one element. In this case, the vector elements are ordered, and they must all be of the same type of data. Common example types of “long” atomic vectors are numeric (whole numbers and fractions), logical (e.g., TRUE or FALSE), and character (e.g., letters or words).\nLet’s see how we can create “long” atomic vectors and some usefull vector properties through examples.\nThe colon operator (:)\n\nThe colon operator : will generate sequences of consecutive values. For example:\n\n1:5\n\n[1] 1 2 3 4 5\n\n\nIn this example, the colon operator : takes two integers 1 and 5 as arguments, and returns an atomic vector of integer numbers from the starting point 1 to the ending point 5 in steps of 1.\nWe can assign (or name) the atomic vector to an object named x_seq:\n\nx_seq <- 1:5\n\nand call it with its name:\n\nx_seq\n\n[1] 1 2 3 4 5\n\n\nWe can determine the type of a vector with typeof().\n\ntypeof(x_seq)\n\n[1] \"integer\"\n\n\nThe elements of the x_seq vector are integers.\nWe can also find how many elements a vector contains applying the length() function:\n\nlength(x_seq)\n\n[1] 5\n\n\nOther examples:\n\n5:1\n\n[1] 5 4 3 2 1\n\n2.5:8.5\n\n[1] 2.5 3.5 4.5 5.5 6.5 7.5 8.5\n\n-3:4\n\n[1] -3 -2 -1  0  1  2  3  4\n\n\n \nThe function seq()\n\nWe have already explore in Chapter 2 the seq() function which creates vectors of consecutive values (seq stands for sequence):\n\nseq(1, 5)    # increment by 1\n\n[1] 1 2 3 4 5\n\n\n \nThe c() function\nWe can also create atomic vectors “by hand” using the c() function (or concatenate command) which combines values into a vector. Let’s create a vector of values 2, 4.5, and 1:\n\nc(2, 4.5, -1)\n\n[1]  2.0  4.5 -1.0\n\n\nOf course, we can have an atomic vector with logical elements as the following example:\n\nc(TRUE, FALSE, TRUE, FALSE)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nor equivalently\n\nc(T, F, T, F)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nand an atomic vector with character elements:\n\nc(\"male\", \"female\", \"female\", \"male\")\n\n[1] \"male\"   \"female\" \"female\" \"male\"  \n\n\n \n\n\n\n\n\n\nNote: An atomic vector can be element of another vector:\n\n\n\n\ny_seq <- 3:7\nc(y_seq, 2, 4.5, -1)  # y_seq is an element of a vector\n\n[1]  3.0  4.0  5.0  6.0  7.0  2.0  4.5 -1.0\n\n\n\n\nRepeating vectors\nThe rep() function allows us to conveniently repeat complete a vector or the elements of a vector. Let’s see some examples:\n1. Repeating the complete vector.\n\nrep(1:4, times = 5)               # 5 times to repeat the complete vector\n\n [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4\n\nrep(c(0, 4, 7), times = 3)        # 3 times to repeat the complete vector\n\n[1] 0 4 7 0 4 7 0 4 7\n\nrep(c(\"a\", \"b\", \"c\"), times = 2)  # 2 times to repeat the complete vector\n\n[1] \"a\" \"b\" \"c\" \"a\" \"b\" \"c\"\n\n\n \n2. Repeating each element of the vector.\n\nrep(1:4, each = 5)               # each element is repeated 5 times\n\n [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4\n\nrep(c(0, 4, 7), each = 3)        # each element is repeated 3 times\n\n[1] 0 0 0 4 4 4 7 7 7\n\nrep(c(\"a\", \"b\", \"c\"), each = 2)  # each element is repeated 2 times\n\n[1] \"a\" \"a\" \"b\" \"b\" \"c\" \"c\"\n\n\n \nDefault vectors\nR comes with a few built-in default vectors, containing useful values:\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nmonth.abb\n\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nWe will use some of these built-in vectors in the examples that follow."
  },
  {
    "objectID": "vector.html#mixing-things-in-a-vector---coercion",
    "href": "vector.html#mixing-things-in-a-vector---coercion",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.4 Mixing things in a vector - Coercion",
    "text": "6.4 Mixing things in a vector - Coercion\nImplicit coercion\nIn general, implicit coercion is an attempt by R to be flexible with data types. When an entry does not match the expected value, R tries to guess what we meant before throwing in an error.\nFor example, R assumes that everything in our atomic vector is of the same data type – that is, all numbers or all characters or all logical elements. Let’s create a “mixed” vector:\n\nmy_vector <- c(1, 4, \"hello\", TRUE)\n\nIn this case, we will not have a vector with two numeric objects, one character object and one logical object. Instead, R will do what it can to convert them all into all the same object type, in this case all character objects. So my_vector will contain 1, 4, hello and TRUE as characters.\nThe hierarchy for coercion is:\nlogical < integer < numeric < character\n\n\n\n\n\n\nExamples\n\n\n\n1. numeric Vs character\n\na <- c(10.5 , 3.2, \"I am a character\")\na\n\n[1] \"10.5\"             \"3.2\"              \"I am a character\"\n\ntypeof(a)\n\n[1] \"character\"\n\n\nAdding a character string to a numeric vector converts all the elements in the vector to character values.\n2. logical Vs character\n\nb <- c(TRUE, FALSE, \"Hello\")\nb\n\n[1] \"TRUE\"  \"FALSE\" \"Hello\"\n\ntypeof(b)\n\n[1] \"character\"\n\n\nAdding a character string to a logical vector converts all the elements in the vector to character values.\n3. logical Vs numeric\n\nd <- c(FALSE, TRUE, 2)\nd\n\n[1] 0 1 2\n\ntypeof(d)\n\n[1] \"double\"\n\n\nAdding a numeric value to a logical vector converts all the elements in the vector to double (numeric) values. Logical values are converted to numbers as folowing: TRUE is converted to 1 and FALSE to 0.\n\n\nExplicit coercion\nR also offers functions to force a specific coercion (explicit coercion). For example, we can turn numbers into characters with the as.character() function. Let’s create a numeric vector f, with numbers 1 through 5, and convert it to a character vector g:\n\nf <- 1:5\n\ng <- as.character(f)\ng\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nWe can turn the characters back to numbers using the as.numeric() function which converts characters or other data types into numeric:\n\nas.numeric(g)\n\n[1] 1 2 3 4 5\n\n\nThis function is actually quite useful in practice, because many public datasets that include numbers, include them in a form that makes them appear to be character strings.\nNow, suppose we define an object q of character strings “1”, “b”, “3” and we want to convert them to numbers using the as.numeric() function:\n\nq <- c(\"1\", \"b\", \"3\")\n\nas.numeric(q)\n\nWarning: NAs introduced by coercion\n\n\n[1]  1 NA  3\n\n\nAs we can see R is able to convert the strings “1” and “3” to the numeric values 1 and 3, but it does not know what to do with “b”. As a result, if we call as.numeric() on this vector, we get a warning that NAs introduced by coercion (the element “b” was converted to a missing value NA).\nMoreover, when nonsensical coercion takes place, we will usually get a warning from R. For example:\n\nx_abc <- c(\"a\", \"b\", \"c\")\nas.numeric(x_abc)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA NA NA"
  },
  {
    "objectID": "vector.html#sort-rank-and-order-numeric-vectors",
    "href": "vector.html#sort-rank-and-order-numeric-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.5 Sort, rank, and order numeric vectors",
    "text": "6.5 Sort, rank, and order numeric vectors\nWe have learned how to create atomic vectors of different types including numeric, character and logical. In addition, we know how to create atomic vectors with patterns and how coercion works. An atomic vector usually contains more than one elements. Sometimes, we want to order the elements in various ways. In this section, we will introduce important functions that relate to ordering elements in an atomic vector.\nFirstly, let’s create a numeric vector which will be used throughout this part.\n\nnum_vect <- c(2, 3, 2, 0, 4, 7) \nnum_vect \n\n[1] 2 3 2 0 4 7\n\n\nSort vectors\nThe first function we will introduce is sort(). By default, the sort() function sorts elements in vector in the ascending order, namely from the smallest to largest.\n\nsort(num_vect)\n\n[1] 0 2 2 3 4 7\n\n\nIf we want to sort the vector in the descending order, namely from the largest to smallest, we can set a second argument decreasing = TRUE.\n\nsort(num_vect, decreasing = TRUE)\n\n[1] 7 4 3 2 2 0\n\n\nRanks of vectors\nNext, let’s talk about ranks. The rank() function references the position of the value in the sorted vector and is in the same order as the original sequence.\n\nnum_vect\n\n[1] 2 3 2 0 4 7\n\nrank(num_vect)\n\n[1] 2.5 4.0 2.5 1.0 5.0 6.0\n\n\nIf we check the values of num_vect, we can see that the smallest value of num_vect is 0, which corresponds to the fourth element. Thus, the fourth element has rank 1. The second smallest value of num_vect is 2, which is shared at the first and the third elements, resulting a tie (elements with the same value will result in a tie). Normally, these two elements would have ranks 2 and 3. To break the tie, the rank() function assigns all the elements involving in the tie (the first and third elements in this example) the same rank, which is average of all their ranks (the average of 2 and 3), by default. In addition to this default behavior for handling ties, rank() also provides other options by setting the ties.method argument.\nIf we want to break the ties by the order element appears in the vector, we can set ties.method = \"first\". Then the earlier appearing element will have smaller ranks than the later one. In this example, the first element will have rank 2 and the third element has rank 3, since the first element appears earlier than the third element.\n\nrank(num_vect, ties.method = \"first\")\n\n[1] 2 4 3 1 5 6\n\n\nNote that unlike sort(), we can’t get positions in the descending order from the rank() function, which means we can’t add decreasing = TRUE in rank().\nOrder of vectors\nThe next function we want to introduce is the order() function. Note that the function name order could be a bit misleading since ordering elements also has the same meaning of sorting. However, although it is related to sorting, order() is a very different function from sort().\nLet’s recall the values of num_vect and apply order() on num_vect:\n\nnum_vect\n\n[1] 2 3 2 0 4 7\n\norder(num_vect)\n\n[1] 4 1 3 2 5 6\n\n\nFrom the result, we can see that the order() function returns the position of the original value and is in the order of sorted sequence, that is smallest value to largest value. For example, the first output is 4, indicating the 4th element in num_vect is the smallest. The second output is 1, showing the 1st element in num_vect is the second smallest."
  },
  {
    "objectID": "vector.html#mathematical-operations-and-functions-applied-to-numeric-vectors",
    "href": "vector.html#mathematical-operations-and-functions-applied-to-numeric-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.6 Mathematical operations and functions applied to numeric vectors",
    "text": "6.6 Mathematical operations and functions applied to numeric vectors\nMathematical operations applied to all the elements of a numeric vector (that is called vectorization):\n\n(1:5) * 2\n\n[1]  2  4  6  8 10\n\n2^(1:5)\n\n[1]  2  4  8 16 32\n\n\nThe same rule is applied to the elements of the vectors using mathematical functions:\n\nz_seq <- 3:9      \nsqrt(z_seq)    # calculate the square root of all the elements of z_seq\n\n[1] 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 3.000000\n\n\nWe can also round the results using the round() function and set the argument digits = 2, as following:\n\nround(sqrt(z_seq), digits = 2)\n\n[1] 1.73 2.00 2.24 2.45 2.65 2.83 3.00"
  },
  {
    "objectID": "vector.html#relational-operators-applied-between-a-vector-and-a-scalar",
    "href": "vector.html#relational-operators-applied-between-a-vector-and-a-scalar",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.7 Relational operators applied between a vector and a scalar",
    "text": "6.7 Relational operators applied between a vector and a scalar\nFor relational operators (>, <, ==, <=, >=, !=), each element of the vector is compared with a defined value (scalar). The result of comparison is a Boolean value (TRUE or FALSE).\nExamples:\n\nm <- c(4, 2, 3, 8)\n\n\nm > 3\n\n[1]  TRUE FALSE FALSE  TRUE\n\nm >= 3\n\n[1]  TRUE FALSE  TRUE  TRUE\n\nm == 3\n\n[1] FALSE FALSE  TRUE FALSE\n\nm != 3\n\n[1]  TRUE  TRUE FALSE  TRUE"
  },
  {
    "objectID": "vector.html#operators-applied-between-two-vectors",
    "href": "vector.html#operators-applied-between-two-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.8 Operators applied between two vectors",
    "text": "6.8 Operators applied between two vectors\nArithmetic Operators\nThe arithmetic operators (+, -, *, /, ^) act on each element of the vector.\nExamples:\n\nv <- c(1, 2, 3)\nt <- c(8, 3, 2)\n\n\nt + v\n\n[1] 9 5 5\n\nt^v\n\n[1] 8 9 8\n\nt + 3 * v / 2\n\n[1] 9.5 6.0 6.5\n\n\nNote that R will follow the BODMAS (Brackets, Orders (powers/roots), Division, Multiplication, Addition, Subtraction) rule for the order in which it will carry out calculations.\n \nRelational Operators\nFor relational operators (>, <, ==, <=, >=, !=), each element of the first vector is compared with the corresponding element of the second vector. The result of comparison is a Boolean value (TRUE or FALSE).\nExamples:\n\nw <- c(2, 5.5, 6, 9)\nz <- c(8, 2.5, 14, 9)\n\n\nz > w\n\n[1]  TRUE FALSE  TRUE FALSE\n\nz == w\n\n[1] FALSE FALSE FALSE  TRUE\n\nz >= w\n\n[1]  TRUE FALSE  TRUE  TRUE\n\nz != w\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\n \nLogical Operators applied to vectors\nThe logical (Boolean) operators are:\n\n\n& , && (AND)\n\n| , || (OR)\n\n! (NOT)\n\nLogical operators are applicable to vectors of type logical or numeric. The result of comparison is a logical (Boolean) value.\nSuppose we have the following vectors:\n\ns <- c(1, 0, - 1, 0, TRUE, TRUE, FALSE)\ns\n\n[1]  1  0 -1  0  1  1  0\n\nu <- c(2, 0, - 2, 2, TRUE, FALSE, FALSE)\nu\n\n[1]  2  0 -2  2  1  0  0\n\n\nHow R will compute, for example, s & u?\nTHE RULE: all non-zero values in the vectors are considered as logical value TRUE and all zeros are considered as FALSE.\nTherefore:\n\ns\n\n[1]  1  0 -1  0  1  1  0\n\n\nLogicals: TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n\nu\n\n[1]  2  0 -2  2  1  0  0\n\n\nLogicals: TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n \nA. AND Operators (&, &&)\nThe & operator combines each element of the first vector with the corresponding element of the second vector and gives an output TRUE if both the elements are TRUE.\n\ns & u\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n\n\nAdditionally, the && operator takes the first element of both vectors and gives TRUE only if both are TRUE.\n\ns && u\n\nWarning in s && u: 'length(x) = 7 > 1' in coercion to 'logical(1)'\n\nWarning in s && u: 'length(x) = 7 > 1' in coercion to 'logical(1)'\n\n\n[1] TRUE\n\n\nB. OR operators (|, ||)\nThe | operator combines each element of the first vector with the corresponding element of the second vector and gives an output TRUE if one of the elements is TRUE.\n\ns | u\n\n[1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n\n\nAdditionally, the || operator takes the first element of both vectors and gives TRUE if one of them is TRUE.\n\ns || u\n\nWarning in s || u: 'length(x) = 7 > 1' in coercion to 'logical(1)'\n\n\n[1] TRUE\n\n\nC. NOT operator (!)\nThe ! operator takes each element of the vector and gives the opposite logical value.\n\n! s\n\n[1] FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n\n! u\n\n[1] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE"
  },
  {
    "objectID": "vector.html#statistical-functions-applied-to-vectors",
    "href": "vector.html#statistical-functions-applied-to-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.9 Statistical functions applied to vectors",
    "text": "6.9 Statistical functions applied to vectors\nStatistical functions in R such as sum() and arithmetic mean() take in the numeric values of a vector and return a single numeric value:\n\nv_seq <- 5:10   \nv_seq\n\n[1]  5  6  7  8  9 10\n\nsum(v_seq)     # adds all the elements of a vector\n\n[1] 45\n\nmean(v_seq)    # calculate the arithmetic mean\n\n[1] 7.5\n\nmedian(v_seq)  # calculate the median\n\n[1] 7.5\n\nsd(v_seq)      # calculate the standard deviation\n\n[1] 1.870829\n\nrange(v_seq)   # returns the minimum and maximum values\n\n[1]  5 10\n\n\n \nNext, we add a missing value NA in the v_seq vector:\n\nv_seq2 <- c(v_seq, NA)\ntypeof(v_seq2)\n\n[1] \"integer\"\n\n\nWe can see that the v_seq2 vector is of integer type.\nHowever, if we try to calculate the mean of the v_seq2, R returns a NA value:\n\nmean(v_seq2)\n\n[1] NA\n\n\nTherefore, if some of the values in a vector are missing, then the mean of the vector is unknown (NA). In this case, it makes sense to remove the NA and compute the mean of the other values in the vector setting the na.rm argument equals to TRUE:\n\nmean(v_seq2, na.rm = TRUE)\n\n[1] 7.5"
  },
  {
    "objectID": "vector.html#subsetting-vectors",
    "href": "vector.html#subsetting-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.10 Subsetting vectors",
    "text": "6.10 Subsetting vectors\nSubsetting (indexing) a vector using [ ]\n\nA. Extract specific elements of a vector\nHaving defined a vector, it’s often useful to extract parts of a vector. We do this with the [ ] operator. For example, using the built in month.name vector:\n\nmonth.name[2]     # we extract only the second month of the year\n\n[1] \"February\"\n\nmonth.name[2:4]   # we extract the second, third, and forth month of the year\n\n[1] \"February\" \"March\"    \"April\"   \n\n\nLet’s see the second example analytically. The vector 2:4 generates the sequence 2, 3, 4. This gets passed to the extract operator [ ].\nWe can also generate this sequence using the vector c(2, 3, 4):\n\nmonth.name[c(2, 3, 4)]\n\n[1] \"February\" \"March\"    \"April\"   \n\n\n\n\n\n\n\n\nThe first element of a vector\n\n\n\nIn R, the first element of a vector has an index of 1. (In many other programming languages [e.g., C and Python], the first element of a vector has an index of 0)\n\n\n \nNote that values are returned in the order that we specify with the indices. For example:\n\nmonth.name[4:2]  # extraction of 4, 3, 2 elements of the vector\n\n[1] \"April\"    \"March\"    \"February\"\n\n\nWe can also extract the same element more than once:\n\nmonth.name[c(1, 1, 2, 3, 4)]\n\n[1] \"January\"  \"January\"  \"February\" \"March\"    \"April\"   \n\n\n \n\n\n\n\n\n\nMissing data (NA) in vectors\n\n\n\nIf we try and extract an element that doesn’t exist in the vector, the missing values are NA:\n\nmonth.name[10:13]\n\n[1] \"October\"  \"November\" \"December\" NA        \n\n\n\n\n \nB. Skipping and removing elements from vectors\nIf we use a negative number as the index of a vector, R will return every element except for the one specified:\n\nmonth.name[-2]   # remove the second month February from the vector\n\n [1] \"January\"   \"March\"     \"April\"     \"May\"       \"June\"      \"July\"     \n [7] \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nWe can also skip multiple elements:\n\nmonth.name[c(-1, -5)]  # remove the first and fifth elements of the vector\n\n [1] \"February\"  \"March\"     \"April\"     \"June\"      \"July\"      \"August\"   \n [7] \"September\" \"October\"   \"November\"  \"December\" \n\n\nwhich is equivalent to:\n\nmonth.name[-c(1, 5)]  # remove the first and fifth elements of the vector\n\n [1] \"February\"  \"March\"     \"April\"     \"June\"      \"July\"      \"August\"   \n [7] \"September\" \"October\"   \"November\"  \"December\" \n\n\n \nA common error occurs when trying to skip slices of a vector. Suppose we want to skip the first five elements form the month.name vector. Most people first try to negate a sequence like so:\n\nmonth.name[-1:5]  \n\nThis gives an error:Error in month.name [-1:5]: only 0’s may be mixed with negative subscripts\nRemember that the colon operator : is a function and in this example takes its first argument as -1, and second as 5, so generates the sequence of numbers: -1, 0, 1, 2, 3, 4, 5.\nThe correct solution is to wrap that function call in brackets, so that the - operator is applied to the sequence:\n\n-(1:5)\n\n[1] -1 -2 -3 -4 -5\n\nmonth.name[-(1:5)]  # remove the 1st to fifth element of the vector\n\n[1] \"June\"      \"July\"      \"August\"    \"September\" \"October\"   \"November\" \n[7] \"December\" \n\n\n \nSubsetting with logical vectors (indexing by conditon)\nAs well as providing a list of indices we want to keep (or delete, if we prefix them with -), we can pass a logical vector to R indicating the indices we wish to select.\nFor example, let’s say that we want to select only the first four months of the year:\n\nfourmonths <- month.name[1:4]\nfourmonths\n\n[1] \"January\"  \"February\" \"March\"    \"April\"   \n\n\nwhich is equivalent to:\n\nmonth.name[c(TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, \n             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]\n\n[1] \"January\"  \"February\" \"March\"    \"April\"   \n\n\nFurthermore, if we want to exlude “February” from the fourmonths vector we should code:\n\nfourmonths[c(TRUE, FALSE, TRUE, TRUE)]\n\n[1] \"January\" \"March\"   \"April\""
  },
  {
    "objectID": "vector.html#vector-recycling",
    "href": "vector.html#vector-recycling",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.11 Vector recycling",
    "text": "6.11 Vector recycling\nWhat happens if we supply a logical vector that is shorter than the vector we’re extracting the elements from?\nFor example:\n\nfourmonths[c(TRUE, FALSE)]\n\n[1] \"January\" \"March\"  \n\n\nThis illustrates the idea of vector recycling. The [ ] extract operator silently “recycled” the values of the shorter vector c(TRUE, FALSE) in order to make the length compatible to the fourmonths vector:\n\nfourmonths[c(TRUE,FALSE,TRUE,FALSE)]\n\n[1] \"January\" \"March\"  \n\n\nFor a further example, suppose we have two vectors c(1,2,4) , c(6,0,9,10,13), where the first one is shorter with only 3 elements. Now if we sum these two, we will get a warning message as follows.\n\nc(1,2,4) + c(6,0,9,10,13)\n\nWarning in c(1, 2, 4) + c(6, 0, 9, 10, 13): longer object length is not a\nmultiple of shorter object length\n\n\n[1]  7  2 13 11 15\n\n\nHere R , sums those vectors by recycling or repeating the elements in shorter one, until it is long enough to match the longer one as follows:\n\nc(1, 2, 4, 1, 2) + c(6, 0, 9, 10, 13)\n\n[1]  7  2 13 11 15"
  },
  {
    "objectID": "matrix.html",
    "href": "matrix.html",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "matrix.html#creating-a-matrix-in-r",
    "href": "matrix.html#creating-a-matrix-in-r",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.1 Creating a matrix in R",
    "text": "7.1 Creating a matrix in R\nEvery data object in R contains a number of attributes to describe the nature of the information in that object. For example, we can generate objects such as matrices using the dim (dimension) attribute. Using matrices we can perform a matrix algebra operations, a powerful type of mathematical technique.\n\n\n\n\n\n\nMatrix\n\n\n\nA matrix is an atomic vector with two dimensions and it is used to represent 2-dimensional data (they have rows and columns) of the same type (numeric, character, or logical).\n\n\nAdding a dimension attribute to a vector allows it to behave like a 2-dimensional matrix. For example:\n\nx_20 <- 1:20\n\ndim(x_20) <- c(5, 4)\n\nx_20\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\n \nMost often we define a matrix using the matrix() function. We need to specify the number of rows and columns.\nExample 1: numeric matrix\n\nX1 <- matrix(1:20, nrow=5, ncol=4)\nX1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nThe matrix is filled by columns (default column-wise), so entries can be thought of starting in the “upper left” corner and running down the columns. If we want the matrix to be filled by rows we must add an extra argument (byrow=TRUE) in the matrix() function, as follows:\n\nX2 <- matrix(1:20, nrow=5, ncol=4, byrow=TRUE)\nX2\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n\n\n \nThe type of data, the class and the dimensions of the X2 object are:\n\ntypeof(X2)\n\n[1] \"integer\"\n\nclass(X2)\n\n[1] \"matrix\" \"array\" \n\ndim(X2)\n\n[1] 5 4\n\n\nOf note, the typeof() function gives the type of data that the object includes (integer), while the class is the type of structure (matrix) of the object.\nThe dim() is an inbuilt R function that either sets or returns the dimension of the matrix, array, or data frame. The dim() function takes the R object as an argument and returns its dimension (as in our example), or if you assign the value to the dim() function, then it sets the dimension for that R Object.\n \nExample 2: logical matrix\n\nx_logical <- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)\nX3 <- matrix(x_logical, nrow=2, ncol=3)\nX3\n\n      [,1]  [,2]  [,3]\n[1,]  TRUE FALSE FALSE\n[2,] FALSE  TRUE FALSE\n\n\n \nThe type of data, the class and the dimensions of the X3 object are:\n\ntypeof(X3)\n\n[1] \"logical\"\n\nclass(X3)\n\n[1] \"matrix\" \"array\" \n\ndim(X3)\n\n[1] 2 3\n\n\n \nExample 3: character matrix\n\nx_char <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\nX4 <- matrix(x_char, nrow=2, ncol=3)\nX4\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"f\" \n\n\n \nThe type of data, the class and the dimensions of the X4 object are:\n\ntypeof(X4)\n\n[1] \"character\"\n\nclass(X4)\n\n[1] \"matrix\" \"array\" \n\ndim(X4)\n\n[1] 2 3"
  },
  {
    "objectID": "matrix.html#using-matrix-subscripts",
    "href": "matrix.html#using-matrix-subscripts",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.2 Using matrix subscripts",
    "text": "7.2 Using matrix subscripts\nWe can identify rows, columns, or elements of a matrix by using subscripts and brackets. Particularly, X[i, ] refers to the ith row of matrix X, X[ , j] refers to jth column, and X[i, j] refers to the ijth element, respectively.\nThe subscripts i and j can be numeric vectors in order to select multiple rows or columns, as shown in the following examples.\n\nX <- matrix(1:10, nrow=2)  # create a 2x5 numeric matrix filled by column\nX\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\nX[2, ]   # select the 2nd row\n\n[1]  2  4  6  8 10\n\nX[, 2]  # select the 2nd column\n\n[1] 3 4\n\nX[1, 4]  # select the element in the 1st row, 4th column\n\n[1] 7\n\nX[1, c(4, 5)]  # select the elements in the 1st row, 4th and 5th column \n\n[1] 7 9"
  },
  {
    "objectID": "matrix.html#basic-matrix-algebra",
    "href": "matrix.html#basic-matrix-algebra",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.3 Basic matrix algebra",
    "text": "7.3 Basic matrix algebra\nThe identity matrix\nA square matrix with ones on the main diagonal and zeros elsewhere:\n\ndiag(5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n\n\n \nThe transpose of a matrix\nThe transpose operation simply changes columns to rows. For example, for a matrix A:\n\nA <-matrix(c(4, -1, -5, 0, 1, -2), 2, 3, byrow = TRUE)\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\n\nthe transpose matrix is:\n\nt(A)\n\n     [,1] [,2]\n[1,]    4    0\n[2,]   -1    1\n[3,]   -5   -2\n\n\n \nMultiplying a number (scalar) with a matrix\nIn scalar multiplication, each element in the matrix is multiplied by the given number (scalar). For example:\n\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\n-3 * A\n\n     [,1] [,2] [,3]\n[1,]  -12    3   15\n[2,]    0   -3    6\n\n\n \nElement-wise multiplication of two matrices of the same dimensions\nThe element-wise multiplication of two matrices, A and B, of the same dimensions can also be computed with the * operator.\n\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\nB <-matrix(c(3, 1, -5, 0, 2, -2), 2, 3, byrow = TRUE)\nB\n\n     [,1] [,2] [,3]\n[1,]    3    1   -5\n[2,]    0    2   -2\n\n\nThe output will be a matrix of the same dimensions of the original matrices:\n\nA * B\n\n     [,1] [,2] [,3]\n[1,]   12   -1   25\n[2,]    0    2    4\n\n\n \nThe dot product (inner product) of two matrices\nTo multiply a matrix by another matrix we need to do the “dot product” of rows and columns. But what does that mean? Let us see with an example.\nTo work out the answer for the 1st row and 1st column:\n\n\nFigure 7.1: Dot product for the 1st row and 1st column\n\n\nThe “Dot Product” is where we multiply matching members, then sum up: 1×7 + 2×9 + 3×11 = 58\nWe match the 1st members (1 and 7), multiply them, likewise for the 2nd members (2 and 9) and the 3rd members (3 and 11), and finally sum them up.\nWant to see another example? Here it is for the 1st row and 2nd column:\n\n\nFigure 7.2: Dot product for the 1st row and 2nd column\n\n\nThe “Dot Product” is: 1×8 + 2×10 + 3×12 = 64\n\n\n\n\n\n\nExample: Dot (inner) Product in R\n\n\n\nIn R, a dot (inner) product of two matrices can be performed with the %*% operator.\n\nP <- matrix(c(3, 0, -5, -1, -3, 4), nrow = 2, ncol = 3, byrow = TRUE)\nQ <- matrix(c(-5, 5, 2, 1, -2, 0), nrow = 3, ncol = 2, byrow = TRUE)\nP\n\n     [,1] [,2] [,3]\n[1,]    3    0   -5\n[2,]   -1   -3    4\n\nQ\n\n     [,1] [,2]\n[1,]   -5    5\n[2,]    2    1\n[3,]   -2    0\n\nP %*% Q\n\n     [,1] [,2]\n[1,]   -5   15\n[2,]   -9   -8\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nBefore inner multiplying two matrices check that the dimensions are compatible. The number of columns of the first matrix must be equal to the number of rows of the second.\n\n\n \nMatrix crossproduct\nIf we need to calculate the inner product of a matrix and the transpose we can type t(A) %*% B, being A and B the names of the matrices.\n\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\nB\n\n     [,1] [,2] [,3]\n[1,]    3    1   -5\n[2,]    0    2   -2\n\nt(A) %*% B\n\n     [,1] [,2] [,3]\n[1,]   12    4  -20\n[2,]   -3    1    3\n[3,]  -15   -9   29\n\n\nHowever, in R it is more efficient and faster using the crossprod:\n\ncrossprod(A, B)\n\n     [,1] [,2] [,3]\n[1,]   12    4  -20\n[2,]   -3    1    3\n[3,]  -15   -9   29\n\n\n \nThe determinant of a matrix\nThe determinant is a scalar value that is a function of the entries of a square matrix:\n\nM <- matrix( c(5, 1, 0, 3,-1, 2, 4, 0,-1), nrow = 3, byrow = TRUE)\nM\n\n     [,1] [,2] [,3]\n[1,]    5    1    0\n[2,]    3   -1    2\n[3,]    4    0   -1\n\ndet(M)\n\n[1] 16\n\n\n \nThe inverse of a matrix\nThe det(M) is not zero, so inverse exists:\n\nM_inv  <- inv(M)\nM_inv\n\n       [,1]    [,2]   [,3]\n[1,] 0.0625  0.0625  0.125\n[2,] 0.6875 -0.3125 -0.625\n[3,] 0.2500  0.2500 -0.500\n\n\nThe inverse of a matrix M is defined as the M_inv matrix which multiplies M to give the identity matrix:\n\nM_inv %*% M\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\n \nSymmetric matrix\nIn linear algebra, a symmetric matrix is a square matrix that is equal to its transpose. For example:\n\nS <- matrix(c(13, -4, 2, -4, 11, -2, 2, -2, 8), 3, 3, byrow = TRUE)\nS\n\n     [,1] [,2] [,3]\n[1,]   13   -4    2\n[2,]   -4   11   -2\n[3,]    2   -2    8\n\nt(S)\n\n     [,1] [,2] [,3]\n[1,]   13   -4    2\n[2,]   -4   11   -2\n[3,]    2   -2    8\n\n\nA symmetric matrix guarantees that its eigenvalues are real numbers. Eigenvalues and eigenvectors are highly used by the data scientists as they are the core of the data science field. For example, eigenvalues and eigenvectors are very much useful in the principal component analysis which is a dimensionality reduction technique in machine learning and is highly used in the field of data science.\nThe eigen() built-in function in R calculates the eigenvalues and eigenvectors of a symmetric matrix. It returns a named list, with eigenvalues named values and eigenvectors named vectors:\n\nev <- eigen(S)\nev\n\neigen() decomposition\n$values\n[1] 17  8  7\n\n$vectors\n           [,1]       [,2]      [,3]\n[1,]  0.7453560  0.6666667 0.0000000\n[2,] -0.5962848  0.6666667 0.4472136\n[3,]  0.2981424 -0.3333333 0.8944272\n\n\nThe eigenvalues are always returned in decreasing order, and each column of vectors corresponds to the elements in values.\n \nApplication: calculation of the average using matrices\nIn ordinary algebra, the mean of a set of n observations, \\(v_1, v_2, v_3,...,v_i, ..., v_n\\) is computed by adding all of the observations and dividing by the number of observations:\n\\[\n\\overline{v} = \\frac{1}{n}\\sum_{i=1}^{n}v_i\n\\]\nwhere \\(\\overline{v}\\) is the mean of observations, \\(\\sum_{i=1}^{n}v_i\\) is the sum of all observations, and \\(n\\) is the number of observations.\nIn matrix algebra, given that:\n\\[\nU = \\left(\\begin{array}{c}\n1 \\\\\n1 \\\\\n\\vdots \\\\\n1\n\\end{array}\\right)\n\\]\nand\n\\[\nV = \\left(\\begin{array}{c}\nv_1 \\\\\nv_2 \\\\\n\\vdots \\\\\nv_n\n\\end{array}\\right)\n\\]\nthe mean can be computed as follows:\n\\[\n\\frac{1}{n} \\cdot U^T \\cdot V =\n\\frac{1}{n} \\cdot\n\\begin{pmatrix}\n      1 & 1 & 1 & ...& 1\n    \\end{pmatrix}\n    \\cdot\n    \\begin{pmatrix}\n      v_{1} \\\\\n      v_{2} \\\\\n      v_{3} \\\\\n      \\vdots \\\\\n      v_{n} \\\\\n    \\end{pmatrix} =\n\\]\n\\[\n=\n    \\frac{1}{n} \\cdot\n    \\begin{pmatrix}\n      1\\cdot v_{1} + 1\\cdot v_{2} +1\\cdot v_{3} +...1\\cdot v_{n}\n    \\end{pmatrix} =\n    \\frac{1}{n}\\sum_{i=1}^{n}v_i\n\\]\nwhere \\(U^T\\) is the transpose of \\(U\\).\nFor example:\n\nmy_values <- c(2, 5, 7, -4, 8, 6, 3)\nmean(my_values)\n\n[1] 3.857143\n\n\n\nn <- length(my_values)  # get the length (number of elements) of vector\nU <- matrix(1, n, 1)\nU\n\n     [,1]\n[1,]    1\n[2,]    1\n[3,]    1\n[4,]    1\n[5,]    1\n[6,]    1\n[7,]    1\n\nV <- matrix(my_values, n, 1)\nV\n\n     [,1]\n[1,]    2\n[2,]    5\n[3,]    7\n[4,]   -4\n[5,]    8\n[6,]    6\n[7,]    3\n\n\n\naverage_my_values <- t(U) %*% V/n\naverage_my_values \n\n         [,1]\n[1,] 3.857143"
  },
  {
    "objectID": "matrix.html#arrays",
    "href": "matrix.html#arrays",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.4 Arrays",
    "text": "7.4 Arrays\nArrays are similar to matrices but can have more than two dimensions. They’re created with an array() function from base R:\n\n# build the 2x3x4 array\nmy_array <- array(1:24, dim = c(2,3,4))\nmy_array\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24\n\n\nAs you can see, arrays are a natural extension of matrices. They can be useful in programming new statistical methods. Like matrices, they contain a single type of data (e.g., numeric).\nWe can find the type, class and the dimensions of the array:\n\ntypeof(my_array)\n\n[1] \"integer\"\n\nclass(my_array)\n\n[1] \"array\"\n\ndim(my_array)\n\n[1] 2 3 4"
  },
  {
    "objectID": "list.html",
    "href": "list.html",
    "title": "8  Data structures in R: lists and data frames",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "list.html#creating-a-list",
    "href": "list.html#creating-a-list",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.1 Creating a list",
    "text": "8.1 Creating a list\nA list in R allows us to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related to each other in any way. We could say that a list is some kind super data type: we can store practically any piece of information in it!\nWe construct a list using the list() function. The list items (or components of a list) can be matrices, vectors, other lists. For example:\n\nmy_list <- list(1:5, c(\"apple\", \"orange\"), TRUE)\nmy_list\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"apple\"  \"orange\"\n\n[[3]]\n[1] TRUE\n\n\nThis list consists of three components that are atomic vectors of different types of data (numeric, characters, and logical).\nWe can assign names to the list items:\n\nmy_list <- list(\n              numbers = 1:5, \n              strings = c(\"apple\", \"orange\"), \n              logicals = TRUE)\nmy_list\n\n$numbers\n[1] 1 2 3 4 5\n\n$strings\n[1] \"apple\"  \"orange\"\n\n$logicals\n[1] TRUE\n\n\nWe can also confirm that the class of the object is list:\n\nclass(my_list)\n\n[1] \"list\""
  },
  {
    "objectID": "list.html#subsetting-a-list",
    "href": "list.html#subsetting-a-list",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.2 Subsetting a list",
    "text": "8.2 Subsetting a list\nSubset list and preserve output as a list\nWe can use the [ ] operator to extract one or more list items while preserving the output in list format:\n\nmy_list[1]    # extract the first list item\n\n$numbers\n[1] 1 2 3 4 5\n\nclass(my_list[1])\n\n[1] \"list\"\n\n\n \nSubset list and simplify the output\nWe can use the [[ ]] to extract one or more list items while simplifying the output:\n\nmy_list[[1]]   # extract the first list item and simplify it to a vector\n\n[1] 1 2 3 4 5\n\nclass(my_list[[1]])\n\n[1] \"integer\"\n\nmy_list[[\"numbers\"]]   # same as above but using the item's name\n\n[1] 1 2 3 4 5\n\n\nWe can also access the content of the list by typing the name of the list followed by a dollar sign $ folowed by the name of the list item:\n\nmy_list$numbers  # extract the numbers and simplify to a vector\n\n[1] 1 2 3 4 5\n\n\nOne thing that differentiates the [[ operator from the $ is that the [[ operator can be used with computed indices and names. The $ operator can only be used with names.\n\n\n\n\n\n\nSimplifying Vs Preserving subsetting\n\n\n\nIt’s important to understand the difference between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output. Preserving subsets keeps the structure of the output the same as the input.\n\n\n \nSubset list to get individual elements out of a list item\nTo extract individual elements out of a specific list item combine the [[ (or $) operator with the [ operator:\n\nmy_list[[2]][2]          # using the index\n\n[1] \"orange\"\n\nmy_list[[\"strings\"]][2]  # using the name of the list item\n\n[1] \"orange\"\n\nmy_list$strings[2]       # using the $\n\n[1] \"orange\""
  },
  {
    "objectID": "list.html#recursive-vectors-and-nested-lists",
    "href": "list.html#recursive-vectors-and-nested-lists",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.3 Recursive vectors and Nested Lists",
    "text": "8.3 Recursive vectors and Nested Lists\nA recursive vector is a list that contains other lists. The sublists of a recursive vector are known as nested lists. For example:\n\nmy_list2 <- list(item1 = 3.14,\n            item2 = list(item2a_num = 5:10,\n                         item2b_char = c(\"a\",\"b\",\"c\")))\n\nmy_list2\n\n$item1\n[1] 3.14\n\n$item2\n$item2$item2a_num\n[1]  5  6  7  8  9 10\n\n$item2$item2b_char\n[1] \"a\" \"b\" \"c\"\n\n\n \nSubsetting a nested list\nWe can access list items of a nested list by using the combination of [[ ]] or $ operator and the [ ] operator. For example:\n\n# preserve the output as a list\nmy_list2[[2]][1]\n\n$item2a_num\n[1]  5  6  7  8  9 10\n\nclass(my_list2[[2]][1])\n\n[1] \"list\"\n\n# same as above but simplify the output\nmy_list2[[2]][[1]]\n\n[1]  5  6  7  8  9 10\n\nclass(my_list2[[2]][[1]])\n\n[1] \"integer\"\n\n# same as above with names\nmy_list2[[\"item2\"]][[\"item2a_num\"]]\n\n[1]  5  6  7  8  9 10\n\n# same as above with $ operator\nmy_list2$item2$item2a_num\n\n[1]  5  6  7  8  9 10\n\n\n \nWe can also extract individual elements from the list items of a nested list. For example:\n\n# extract individual element\nmy_list2[[2]][[2]][3]\n\n[1] \"c\"\n\nclass(my_list2[[2]][[2]][3])\n\n[1] \"character\""
  },
  {
    "objectID": "list.html#unlist-a-list",
    "href": "list.html#unlist-a-list",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.4 Unlist a list",
    "text": "8.4 Unlist a list\nWe can turn a list into an atomic vector with unlist():\n\nmy_unlist <- unlist(my_list)\nmy_unlist\n\nnumbers1 numbers2 numbers3 numbers4 numbers5 strings1 strings2 logicals \n     \"1\"      \"2\"      \"3\"      \"4\"      \"5\"  \"apple\" \"orange\"   \"TRUE\" \n\nclass(my_unlist)\n\n[1] \"character\""
  },
  {
    "objectID": "list.html#data-frames",
    "href": "list.html#data-frames",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.5 Data frames",
    "text": "8.5 Data frames\nA data frame is the most common way of storing data in R and, generally, is the data structure most often used for data analyses.\n\n\n\n\n\n\nData frame\n\n\n\nA data frame is a special type of list with equal-length atomic vectors. Each component of the list can be thought of as a column and the length of each component of the list is the number of rows.\n\n\n \nBasic characteristics of data frames\n\nEach column of a data frame is an atomic vector and remember that the data in an atomic vector must only be of one type (numeric, character, or logical).\n\nData frames are similar to the datasets we’d typically see in spreadsheets (e.g., Excell files, Google sheets, LibreOffice Calc).\n\nData frames are the most common data structure we’ll deal with in R. A data frame can be created with the data.frame() function in base R, the tibble() function in the tidyverse package (an improvement over data.frame), or the “fast” data.table() in the data.table package.\n\nDifferent traditions have different names for the rows and columns of a dataset. Statisticians refer to them as observations and variables, database analysts call them records and fields, and those from the data mining/machine learning disciplines call them examples and attributes. We’ll use the terms observations and variables throughout this textbook.\nThe two basic variable categories are the categorical and numerical variables.\n \nCreating a data frame with tibble()\n\nWe can create a data frame from column vectors with the tibble() function from tibble package which belongs to the “tidyverse” family of packages. A tibble is a specific kind of data frame and is short for “tidy table”.\nIn order to use the tidyverse packages, our input data frames must be in “tidy” format (long/narrow format). In tidy data there are three interrelated rules:\n\nEach variable must have its own column.\nEach observation must have its own row.\nEach value must have its own cell.\n\n\n\n\n\nFigure 8.1: Tidy data.\n\n\n\n\nHere, we provide a simple example of patient dataset:\n\nlibrary(tidyverse)   # load the tidyverse package\nlibrary(lubridate)   # load the lubridate package\n\npatient_data <- tibble(\npatientID = c(1, 2, 3, 4, 5, 6, 7, 8),\nage = c(25, 30, 28, 22, 31, 45, 37, 43),\nweight = c(94, 83, 71, 87, 94, 73, 89, 74),\ndiabetes = c(\"Type 1\", \"Type 2\", \"Type 1\", \"Type 1\", \n              \"Type 2\", \"Type 1\", \"Type 1\", \"Type 2\"),\nstatus = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\", \n            \"Poor\",\"Excellent\", \"Improved\", \"Improved\"),\ndates = ymd(\"2020-10-09\", \"2020-10-12\", \"2020-10-18\", \"2020-10-27\",\n           \"2020-11-04\", \"2020-11-09\", \"2020-11-22\", \"2020-12-02\"))\npatient_data\n\n# A tibble: 8 × 6\n  patientID   age weight diabetes status    dates     \n      <dbl> <dbl>  <dbl> <chr>    <chr>     <date>    \n1         1    25     94 Type 1   Poor      2020-10-09\n2         2    30     83 Type 2   Improved  2020-10-12\n3         3    28     71 Type 1   Excellent 2020-10-18\n4         4    22     87 Type 1   Poor      2020-10-27\n5         5    31     94 Type 2   Poor      2020-11-04\n6         6    45     73 Type 1   Excellent 2020-11-09\n7         7    37     89 Type 1   Improved  2020-11-22\n8         8    43     74 Type 2   Improved  2020-12-02\n\n\nIn this data frame, patientID is a row or case identifier, age (in years) and weight (in kg) are continuous variables, diabetes (Type 1, Type 2) is a nominal (dichotomous) variable, status is an ordinal variable (Poor/Improved/Excellent), and dates variable with dates (note that we used the ymd() function to create this variable).\nWe might have noticed the row of three (or four) letter abbreviations under the column names. These describe the type of each variable:\n\ndbl stands for doubles, or real numbers.\nchr stands for character vectors, or strings.\ndate stands for dates.\n\nThere are some other common types of variables that aren’t used in this dataset:\n\nint stands for integers.\nlgl stands for logical, vectors that contain only TRUE or FALSE.\nfct stands for factors, which R uses to represent categorical variables with fixed possible values.\ndttm stands for date-times (a date + a time).\n\nOften we use the glimpse() function in order to have a quick look at the structure of the data frame:\n\nglimpse(patient_data)\n\nRows: 8\nColumns: 6\n$ patientID <dbl> 1, 2, 3, 4, 5, 6, 7, 8\n$ age       <dbl> 25, 30, 28, 22, 31, 45, 37, 43\n$ weight    <dbl> 94, 83, 71, 87, 94, 73, 89, 74\n$ diabetes  <chr> \"Type 1\", \"Type 2\", \"Type 1\", \"Type 1\", \"Type 2\", \"Type 1\", …\n$ status    <chr> \"Poor\", \"Improved\", \"Excellent\", \"Poor\", \"Poor\", \"Excellent\"…\n$ dates     <date> 2020-10-09, 2020-10-12, 2020-10-18, 2020-10-27, 2020-11-04, …\n\n\nWe can also find the type, class and dim for the data frame:\n\ntypeof(patient_data)\n\n[1] \"list\"\n\nclass(patient_data)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\ndim(patient_data)\n\n[1] 8 6\n\n\nThe type is a list but the class is a tbl (tibble) object which is a “tidy” data frame (tibbles work better in the tidyverse). The dimensions are 8x6.\nThe attribute() function help us to explore the characteristics/attributives of the tibbles:\n\nattributes(patient_data)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5 6 7 8\n\n$names\n[1] \"patientID\" \"age\"       \"weight\"    \"diabetes\"  \"status\"    \"dates\"    \n\n\n \nAccess only one variable at a time from a tibble\nTo access the variable age, we can use the dollar sign ($) like this:\n\npatient_data$age\n\n[1] 25 30 28 22 31 45 37 43\n\n\nFor example, if we want to cross tabulate diabetes type by status, we could use the following code:\n\ntable(patient_data$diabetes, patient_data$status)\n\n        \n         Excellent Improved Poor\n  Type 1         2        1    2\n  Type 2         0        2    1\n\n\n\n\n\n\n\n\nTable\n\n\n\nThe table() function builds a contingency table of the counts at each combination of levels of the variables."
  },
  {
    "objectID": "list.html#access-variables-using-the-with-function",
    "href": "list.html#access-variables-using-the-with-function",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.6 Access variables using the with() function",
    "text": "8.6 Access variables using the with() function\nIt can get tiresome typing patient_data$ at the beginning of every variable name. An alternative approach is to use with() function. For example:\n\nwith(patient_data, table(diabetes, status))\n\n        status\ndiabetes Excellent Improved Poor\n  Type 1         2        1    2\n  Type 2         0        2    1"
  },
  {
    "objectID": "list.html#factors",
    "href": "list.html#factors",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.7 Factors",
    "text": "8.7 Factors\nCategorical (nominal) and ordered categorical (ordinal) variables in R are usually transformed to factors. Factors can contain only predefined values and are crucial in R because they determine how data will be analyzed in statistical models and presented visually.\nIn our example, we should convert the diabetes and status variables from character to factor variables. This can be done by applying the convert_as_factor() function from the rstatix package:\n\n# convert from character to factor\npatient_data <- rstatix::convert_as_factor(patient_data, diabetes, status)\npatient_data\n\n# A tibble: 8 × 6\n  patientID   age weight diabetes status    dates     \n      <dbl> <dbl>  <dbl> <fct>    <fct>     <date>    \n1         1    25     94 Type 1   Poor      2020-10-09\n2         2    30     83 Type 2   Improved  2020-10-12\n3         3    28     71 Type 1   Excellent 2020-10-18\n4         4    22     87 Type 1   Poor      2020-10-27\n5         5    31     94 Type 2   Poor      2020-11-04\n6         6    45     73 Type 1   Excellent 2020-11-09\n7         7    37     89 Type 1   Improved  2020-11-22\n8         8    43     74 Type 2   Improved  2020-12-02\n\n\nNow, we can inspect the order of the levels for both factor variables using the levels() function:\n\nlevels(patient_data$diabetes) # show the levels of diabetes variable\n\n[1] \"Type 1\" \"Type 2\"\n\nlevels(patient_data$status) # show the levels of status variable\n\n[1] \"Excellent\" \"Improved\"  \"Poor\"     \n\n\nAdditionally, we may want to reorder the levels in the status variable using the fct_relevel() function from the forcats package. In this case, the argument rev in the function will reverse the order:\n\n# reverse the order of the levels\npatient_data$status <-  fct_relevel(patient_data$status, rev)\n\nlevels(patient_data$status)  # show the order of the levels\n\n[1] \"Poor\"      \"Improved\"  \"Excellent\"\n\n\nor using the fct_rev() from forcats package:\n\npatient_data$status <- fct_rev(patient_data$status)\n\nThe status variable has a natural ordering between its categories. If we want to compare the values, we have to pass this information to R.\n\npatient_data$status <-  factor(patient_data$status, ordered = TRUE)\n\npatient_data$status\n\n[1] Poor      Improved  Excellent Poor      Poor      Excellent Improved \n[8] Improved \nLevels: Poor < Improved < Excellent\n\n\nNow we can use, for example, the comparison operators > to check whether one element of the ordered vector is larger than the other.\n\npatient_data$status[2] > patient_data$status[6]\n\n[1] FALSE\n\n\nFactors are also useful when we know the set of possible values (based on theory or experimental design, not of the data) but they’re not all present in a given dataset. In contrast to a character vector, when we tabulate a factor (e.g. using the table() function) we will get counts of all categories, even unobserved ones:\n\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\ntable(sex_factor)\n\nsex_factor\nm f \n3 0"
  },
  {
    "objectID": "list.html#dates-in-r",
    "href": "list.html#dates-in-r",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.8 Dates in R",
    "text": "8.8 Dates in R\nThere are three types of date/time data that refer to an instant in time:\n\nA date. Tibbles print this as <date>.\nA time within a day. Tibbles print this as <time>.\nA date-time is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). Tibbles print this as <dttm>. Elsewhere in R these are called POSIXct.\n\nTo get the current date or date-time you can use Sys.Date() or now():\n\nSys.Date()\nnow()\n\nDate vectors are built on top of double vectors but they have the special class “Date”:\n\ntoday <- Sys.Date()\ntypeof(today)\n\n[1] \"double\"\n\nclass(today)\n\n[1] \"Date\"\n\n\nThe value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01:\n\nunclass(today)\n\n[1] 19285\n\n\nSo, in numeric form, Date counts the days since 1970-01-01. For example:\n\ndate1 <- as.Date('2020-06-28')\nas.numeric(date1)\n\n[1] 18441\n\n\nNow, we can use difftime() to find the amount of time in DAYS that has passed since we created date1.\n\ndifftime(Sys.time(), date1, units = 'days')\n\nTime difference of 844.7605 days\n\n\nPOSIXct stores a date and time. In numeric form, the number of seconds since 1970-01-01.\n\ndate2 <- as.POSIXct('2012-06-28 18:00')\nas.numeric(date2)\n\n[1] 1340895600\n\n\nWe’ve seen also one approach to parsing strings into dates variable in our data frame using the ymd() function from lubridate package. This is the most concise way to create a single date/time object, as we might need when filtering date/time data. The class of this object is:\n\nclass(patient_data$dates)\n\n[1] \"Date\""
  },
  {
    "objectID": "transformation.html",
    "href": "transformation.html",
    "title": "9  Data transformation",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "transformation.html#importing-data",
    "href": "transformation.html#importing-data",
    "title": "9  Data transformation",
    "section": "\n9.1 Importing data",
    "text": "9.1 Importing data\nUp to this point we have used data objects created with functions. Most of the time however, we work with data stored elsewhere and there are many ways to import such data into an R session.\nData are stored in spreadsheets which are often saved in one of the following two formats:\n\nA Comma Separated Values .csv file. We can think of a .csv file as a barebones spreadsheet where:\n\n\nEach line in the file corresponds to one row of data/one observation.\nValues for each line are separated with commas “,”. In other words, the values of different variables are separated by commas.\nThe first line is often, but not always, a header row indicating the names of the columns/variables.\n\n\nAn Excel .xlsx spreadsheet file. This format is based on Microsoft’s proprietary Excel software and may include the use of bold and italic fonts, colored cells, different column widths, and formula macros.\n\nWe will use the dataset named arrhythmia which is a .csv file.\n\n\n\nFigure 9.1: Table with raw data of arrhythmia data set.\n\n\n\nThe meta-data (data about the data) for this dataset are as following:\n\nage: age (yrs)\nsex: sex (0=male, 1=female)\nheight: height (cm)\nweight: weight (kg)\nQRS: mean duration of QRS (ms) \n\nheart_rate: heart rate (beats/min)\n\nIf the dataset is stored in our computer disc as a .csv file (arrhythmia.csv) we can read it with the read_csv function from readr package as following:\n\nlibrary(readr)\narrhythmia <- read_csv(here(\"data\", \"arrhythmia.csv\"))\n\narrhythmia\n\n# A tibble: 452 × 6\n     age   sex height weight   QRS heart_rate\n   <dbl> <dbl>  <dbl>  <dbl> <dbl>      <dbl>\n 1    75     0    190     80    91         63\n 2    56     1    165     64    81         53\n 3    54     0    172     95   138         75\n 4    55     0    175     94   100         71\n 5    75     0    190     80    88         75\n 6    13     0    169     51   100         84\n 7    40     1    160     52    77         70\n 8    49     1    162     54    78         67\n 9    44     0    168     56    84         64\n10    50     1    167     67    89         63\n# … with 442 more rows\n\n\nThis data frame contains 452 observations and 6 variables. However, when we call the name of the object (arrhythmia), we can see in the console the first 10 rows, and all the columns that fit on screen. Note that by default the first row of the .csv file was used as the column names of the data frame.\nWe might have noticed that the categorical variable sex is coded as 0 (for males) and 1 (for females), so it is recognized of double type. We can use the factor() function to encode a variable as a factor:\n\narrhythmia$sex = factor(arrhythmia$sex, levels = c(0, 1), labels = c(\"male\", \"female\"))\n\nLet’s look at the data again with the glipmse() function:\n\nglimpse(arrhythmia)\n\nRows: 452\nColumns: 6\n$ age        <dbl> 75, 56, 54, 55, 75, 13, 40, 49, 44, 50, 62, 45, 54, 30, 44,…\n$ sex        <fct> male, female, male, male, male, male, female, female, male,…\n$ height     <dbl> 190, 165, 172, 175, 190, 169, 160, 162, 168, 167, 170, 165,…\n$ weight     <dbl> 80, 64, 95, 94, 80, 51, 52, 54, 56, 67, 72, 86, 58, 73, 88,…\n$ QRS        <dbl> 91, 81, 138, 100, 88, 100, 77, 78, 84, 89, 102, 77, 78, 91,…\n$ heart_rate <dbl> 63, 53, 75, 71, 75, 84, 70, 67, 64, 63, 70, 72, 73, 56, 72,…\n\n\nNow, the variable sex is a factor variable (fct) with two levels:\n\nlevels(arrhythmia$sex)\n\n[1] \"male\"   \"female\""
  },
  {
    "objectID": "transformation.html#subsetting-variables",
    "href": "transformation.html#subsetting-variables",
    "title": "9  Data transformation",
    "section": "\n9.2 Subsetting variables",
    "text": "9.2 Subsetting variables\nWe don’t necessarily need all the variables, and a good practice for large datasets with many variables is to select only the variables we are actually interested in. In this chapter we review the different ways of selecting variables.\nVariable selection is not very useful with the arrhythmia data because we only have 6 variables, but we can still get the general idea.\nA. Select variables by name using [ ]\nWe can select only the age, sex, QRS, variables from the data frame:\n\ndat1 <- arrhythmia[c(\"age\", \"sex\" , \"QRS\")]\nhead(dat1)\n\n# A tibble: 6 × 3\n    age sex      QRS\n  <dbl> <fct>  <dbl>\n1    75 male      91\n2    56 female    81\n3    54 male     138\n4    55 male     100\n5    75 male      88\n6    13 male     100\n\n\nB. Select or exclude variables by indexing [ ] (not recommended)\n\ndat2 <- arrhythmia[c(1, 2, 5)]\nhead(dat2)\n\n# A tibble: 6 × 3\n    age sex      QRS\n  <dbl> <fct>  <dbl>\n1    75 male      91\n2    56 female    81\n3    54 male     138\n4    55 male     100\n5    75 male      88\n6    13 male     100\n\n\n\ndat3 <- arrhythmia[-c(3, 4, 6)]\nhead(dat3)\n\n# A tibble: 6 × 3\n    age sex      QRS\n  <dbl> <fct>  <dbl>\n1    75 male      91\n2    56 female    81\n3    54 male     138\n4    55 male     100\n5    75 male      88\n6    13 male     100\n\n\nC. Select variables using the subset() function\n\ndat4 <- subset(arrhythmia, select = c(1, 2, 5))\nhead(dat4)\n\n# A tibble: 6 × 3\n    age sex      QRS\n  <dbl> <fct>  <dbl>\n1    75 male      91\n2    56 female    81\n3    54 male     138\n4    55 male     100\n5    75 male      88\n6    13 male     100\n\n\nThe select argument allows the selection by indexing the columns of interest in.\nD. Select variables using the select() function from dplyr\nIn select() function we pass the data frame first and then the variables separated by commas:\n\ndat5 <- select(arrhythmia, age, sex, QRS)\nhead(dat5)\n\n# A tibble: 6 × 3\n    age sex      QRS\n  <dbl> <fct>  <dbl>\n1    75 male      91\n2    56 female    81\n3    54 male     138\n4    55 male     100\n5    75 male      88\n6    13 male     100"
  },
  {
    "objectID": "transformation.html#subsetting-observations",
    "href": "transformation.html#subsetting-observations",
    "title": "9  Data transformation",
    "section": "\n9.3 Subsetting observations",
    "text": "9.3 Subsetting observations\nA. Select rows by indexing [ ]\n\ndat6 <- arrhythmia[5:15, ]\ndat6\n\n# A tibble: 11 × 6\n     age sex    height weight   QRS heart_rate\n   <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n 1    75 male      190     80    88         75\n 2    13 male      169     51   100         84\n 3    40 female    160     52    77         70\n 4    49 female    162     54    78         67\n 5    44 male      168     56    84         64\n 6    50 female    167     67    89         63\n 7    62 male      170     72   102         70\n 8    45 female    165     86    77         72\n 9    54 female    172     58    78         73\n10    30 male      170     73    91         56\n11    44 female    160     88    77         72\n\n\nB. Select rows by conditions using [ ]\n\ndat7 <- arrhythmia[which(arrhythmia$age > 75), ]\ndat7\n\n# A tibble: 9 × 6\n    age sex    height weight   QRS heart_rate\n  <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n1    79 female    150     60    93         74\n2    77 male      165     77    98         59\n3    83 female    160     55    84         84\n4    80 male      173     85    93         80\n5    80 male      160     70    90         67\n6    81 female    165     60    86         76\n7    78 male      152     46    97         75\n8    76 female    150     54    71         63\n9    78 female    160     70    79         75\n\n\n\ndat8 <- arrhythmia[which(arrhythmia$age > 75 & arrhythmia$sex == \"female\"), ]\ndat8\n\n# A tibble: 5 × 6\n    age sex    height weight   QRS heart_rate\n  <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n1    79 female    150     60    93         74\n2    83 female    160     55    84         84\n3    81 female    165     60    86         76\n4    76 female    150     54    71         63\n5    78 female    160     70    79         75\n\n\nC. Select rows by conditions using subset() function\n\ndat9 <- subset(arrhythmia, age > 75)\ndat9\n\n# A tibble: 9 × 6\n    age sex    height weight   QRS heart_rate\n  <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n1    79 female    150     60    93         74\n2    77 male      165     77    98         59\n3    83 female    160     55    84         84\n4    80 male      173     85    93         80\n5    80 male      160     70    90         67\n6    81 female    165     60    86         76\n7    78 male      152     46    97         75\n8    76 female    150     54    71         63\n9    78 female    160     70    79         75\n\n\n\ndat10 <- subset(arrhythmia, age > 75 & sex == \"female\")\ndat10\n\n# A tibble: 5 × 6\n    age sex    height weight   QRS heart_rate\n  <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n1    79 female    150     60    93         74\n2    83 female    160     55    84         84\n3    81 female    165     60    86         76\n4    76 female    150     54    71         63\n5    78 female    160     70    79         75\n\n\nD. Select rows using the filter() from dplyr\nWe pass the data frame first and then one or more conditions separated by a comma:\n\ndat11 <- filter(arrhythmia, age > 75)\ndat11\n\n# A tibble: 9 × 6\n    age sex    height weight   QRS heart_rate\n  <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n1    79 female    150     60    93         74\n2    77 male      165     77    98         59\n3    83 female    160     55    84         84\n4    80 male      173     85    93         80\n5    80 male      160     70    90         67\n6    81 female    165     60    86         76\n7    78 male      152     46    97         75\n8    76 female    150     54    71         63\n9    78 female    160     70    79         75\n\n\nIf we want to select only female patients with age > 75:\n\ndat12 <- filter(arrhythmia, age > 75, sex == \"female\")\ndat12\n\n# A tibble: 5 × 6\n    age sex    height weight   QRS heart_rate\n  <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n1    79 female    150     60    93         74\n2    83 female    160     55    84         84\n3    81 female    165     60    86         76\n4    76 female    150     54    71         63\n5    78 female    160     70    79         75"
  },
  {
    "objectID": "transformation.html#subsetting-variables-and-observations-by-indexing",
    "href": "transformation.html#subsetting-variables-and-observations-by-indexing",
    "title": "9  Data transformation",
    "section": "\n9.4 Subsetting variables and observations by indexing [ ]\n",
    "text": "9.4 Subsetting variables and observations by indexing [ ]\n\n\ndat13 <- arrhythmia[5:15, c(1, 2, 5)]\ndat13\n\n# A tibble: 11 × 3\n     age sex      QRS\n   <dbl> <fct>  <dbl>\n 1    75 male      88\n 2    13 male     100\n 3    40 female    77\n 4    49 female    78\n 5    44 male      84\n 6    50 female    89\n 7    62 male     102\n 8    45 female    77\n 9    54 female    78\n10    30 male      91\n11    44 female    77"
  },
  {
    "objectID": "transformation.html#reorder-rows-using-arrange-from-dplyr",
    "href": "transformation.html#reorder-rows-using-arrange-from-dplyr",
    "title": "9  Data transformation",
    "section": "\n9.5 Reorder rows using arrange() from dplyr\n",
    "text": "9.5 Reorder rows using arrange() from dplyr\n\nWe can also arrange a data frame based on one or more variables. The arrange() function works similarly to filter() except that instead of selecting rows, it changes their order. It takes a data frame and a set of column names (or more complicated expressions) to order by. For example, we can arrange the rows of the arrhythmia table by the magnitude of QRS (in ascending order which is the default):\n\ndat14 <- arrange(arrhythmia, QRS)\nhead(dat14, 10)\n\n# A tibble: 10 × 6\n     age sex    height weight   QRS heart_rate\n   <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n 1    35 female    160     53    55         81\n 2    48 female    158     52    61         62\n 3    64 female    160     80    62         68\n 4    34 female    167     60    63         54\n 5    52 female    153     55    67         98\n 6    65 female    155     68    68         82\n 7    46 female    162     65    68         60\n 8    44 female    160     45    69         63\n 9    46 female    165     60    69         86\n10     3 male      105     12    69        124\n\n\nWe can use desc() to re-arrange in descending order. For example:\n\ndat15 <- arrange(arrhythmia, desc(QRS))\nhead(dat15, 10)\n\n# A tibble: 10 × 6\n     age sex    height weight   QRS heart_rate\n   <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl>\n 1    44 male      170     84   188         77\n 2     7 female    127     22   185        122\n 3    68 male      161     70   170         63\n 4    75 female    159     59   163         72\n 5    66 female    156     80   153         64\n 6    61 female    156     77   147         56\n 7    62 male      176     73   146         64\n 8    68 female    146     62   146         61\n 9     7 male      119     21   140         70\n10    54 male      172     95   138         75"
  },
  {
    "objectID": "transformation.html#create-new-variables-with-mutate",
    "href": "transformation.html#create-new-variables-with-mutate",
    "title": "9  Data transformation",
    "section": "\n9.6 Create new variables with mutate()\n",
    "text": "9.6 Create new variables with mutate()\n\nSuppose we want to calculate BMI for the participants from weight and height. We can use the following code to calculate the BMI (we divide the height with 100, because it was given in cm):\n\nmutate(arrhythmia, bmi = round(weight / (height / 100)^ 2, digits = 1))\n\n# A tibble: 452 × 7\n     age sex    height weight   QRS heart_rate   bmi\n   <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl> <dbl>\n 1    75 male      190     80    91         63  22.2\n 2    56 female    165     64    81         53  23.5\n 3    54 male      172     95   138         75  32.1\n 4    55 male      175     94   100         71  30.7\n 5    75 male      190     80    88         75  22.2\n 6    13 male      169     51   100         84  17.9\n 7    40 female    160     52    77         70  20.3\n 8    49 female    162     54    78         67  20.6\n 9    44 male      168     56    84         64  19.8\n10    50 female    167     67    89         63  24  \n# … with 442 more rows\n\n\nwhich is equivalent to:\n\narrhythmia %>%   \n     mutate(bmi = round(weight / (height / 100)^ 2, digits=1))"
  },
  {
    "objectID": "transformation.html#using-the-pipe-operator-in-a-sequence-of-functions",
    "href": "transformation.html#using-the-pipe-operator-in-a-sequence-of-functions",
    "title": "9  Data transformation",
    "section": "\n9.7 Using the pipe operator %>% in a sequence of functions",
    "text": "9.7 Using the pipe operator %>% in a sequence of functions\nLet’s say that we want to find the BMI, and BMI categories only for the adults:\n\narrhythmia_adults <- arrhythmia %>% \n        filter(age >= 18) %>% \n        mutate(bmi = round(weight / (height / 100)^ 2, digits = 1),\n               bmi_cat = cut(bmi, breaks = c(-Inf, 18.5, 25.0, 30.0, Inf), \n                   labels = c(\"underweight\",\"normal\",\"overweight\", \"obese\"))\n               )\n\narrhythmia_adults\n\n# A tibble: 428 × 8\n     age sex    height weight   QRS heart_rate   bmi bmi_cat\n   <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl> <dbl> <fct>  \n 1    75 male      190     80    91         63  22.2 normal \n 2    56 female    165     64    81         53  23.5 normal \n 3    54 male      172     95   138         75  32.1 obese  \n 4    55 male      175     94   100         71  30.7 obese  \n 5    75 male      190     80    88         75  22.2 normal \n 6    40 female    160     52    77         70  20.3 normal \n 7    49 female    162     54    78         67  20.6 normal \n 8    44 male      168     56    84         64  19.8 normal \n 9    50 female    167     67    89         63  24   normal \n10    62 male      170     72   102         70  24.9 normal \n# … with 418 more rows\n\n\nWe would read this sequence as:\n\nTake the dataset arrythmia then\n\nUse this output as the input to the filter() to select only the adults (age >=18) then\n\nUse this output as the input to the mutate() to calculate bmi and bmi_cat.\n\nCan you imagine what is the function of cut() for?"
  },
  {
    "objectID": "transformation.html#more-examples-and-functions",
    "href": "transformation.html#more-examples-and-functions",
    "title": "9  Data transformation",
    "section": "\n9.8 More examples and functions",
    "text": "9.8 More examples and functions\nNow, we want from the arrhythmia_adults to filter only the overweight or obese patients:\n\noverweight_obese <- arrhythmia_adults %>% \n                       filter(bmi_cat == \"overweight\" | bmi_cat == \"obese\")\n\nHere, we used the logical operator |. The logical operators are:\n\n\n& (and)\n\n| (or)\n\n! (not)\n\n \nAlternatively we can use the %in% operator. This operator helps us to easily create multiple OR arguments:\n\noverweight_obese2 <- arrhythmia_adults %>% \n                       filter(bmi_cat %in% c(\"overweight\", \"obese\"))\n\nLet’s say that we also want those overweight or obese people who have heart rate > 85:\n\noverweight_obese3 <- arrhythmia_adults %>% \n                       filter(bmi_cat %in% c(\"overweight\", \"obese\"), \n                              heart_rate >= 85)\noverweight_obese3\n\n# A tibble: 44 × 8\n     age sex    height weight   QRS heart_rate   bmi bmi_cat   \n   <dbl> <fct>   <dbl>  <dbl> <dbl>      <dbl> <dbl> <fct>     \n 1    50 female    160     73    75         93  28.5 overweight\n 2    69 female    160     71    75         98  27.7 overweight\n 3    64 female    155     88    82         85  36.6 obese     \n 4    62 female    165     70    72        103  25.7 overweight\n 5    63 male      175     80    97         89  26.1 overweight\n 6    43 male      176     90    78         85  29.1 overweight\n 7    24 female    162     75    88         93  28.6 overweight\n 8    51 female    160     80    85         85  31.2 obese     \n 9    42 female    160     68    81         85  26.6 overweight\n10    73 female    160     80    82        103  31.2 obese     \n# … with 34 more rows\n\n\nNow, let’s rename variables for example heart_rate to HR and sex to gender in the subset overweight_obese3. Moreover, select() can be used with everything() to hoist a variable up to the front of the tibble:\n\noverweight_obese3 %>% \n          rename(HR = heart_rate, gender = sex) %>% \n          select(HR, gender, everything())\n\n# A tibble: 44 × 8\n      HR gender   age height weight   QRS   bmi bmi_cat   \n   <dbl> <fct>  <dbl>  <dbl>  <dbl> <dbl> <dbl> <fct>     \n 1    93 female    50    160     73    75  28.5 overweight\n 2    98 female    69    160     71    75  27.7 overweight\n 3    85 female    64    155     88    82  36.6 obese     \n 4   103 female    62    165     70    72  25.7 overweight\n 5    89 male      63    175     80    97  26.1 overweight\n 6    85 male      43    176     90    78  29.1 overweight\n 7    93 female    24    162     75    88  28.6 overweight\n 8    85 female    51    160     80    85  31.2 obese     \n 9    85 female    42    160     68    81  26.6 overweight\n10   103 female    73    160     80    82  31.2 obese     \n# … with 34 more rows"
  },
  {
    "objectID": "transformation.html#explore-for-outliers-in-the-dataset",
    "href": "transformation.html#explore-for-outliers-in-the-dataset",
    "title": "9  Data transformation",
    "section": "\n9.9 Explore for outliers in the dataset",
    "text": "9.9 Explore for outliers in the dataset\nLet’s take a look to the dataset arrythmia_adults with the summary() function:\n\nsummary(arrhythmia_adults)\n\n      age            sex          height        weight           QRS       \n Min.   :18.00   male  :191   Min.   :146   Min.   : 18.0   Min.   : 55.0  \n 1st Qu.:37.00   female:237   1st Qu.:160   1st Qu.: 60.0   1st Qu.: 80.0  \n Median :47.00                Median :165   Median : 70.0   Median : 86.0  \n Mean   :48.51                Mean   :165   Mean   : 70.1   Mean   : 88.4  \n 3rd Qu.:59.00                3rd Qu.:170   3rd Qu.: 80.0   3rd Qu.: 94.0  \n Max.   :83.00                Max.   :190   Max.   :176.0   Max.   :188.0  \n   heart_rate          bmi               bmi_cat   \n Min.   : 44.00   Min.   : 5.20   underweight: 11  \n 1st Qu.: 65.00   1st Qu.:22.90   normal     :192  \n Median : 72.00   Median :25.40   overweight :167  \n Mean   : 73.33   Mean   :25.72   obese      : 58  \n 3rd Qu.: 80.00   3rd Qu.:28.10                    \n Max.   :120.00   Max.   :61.60                    \n\n\nWe can see that the minimum value in weight and bmi is 18 kg and 5.2, respectevely. However, these values can’t be right! We can also inspect the outliers in bmi variable using a simple boxplot Figure 9.2:\n\nboxplot(arrhythmia_adults$bmi, main = \"Boxplot of age of adult patients\", ylab = \"BMI\", boxwex=.3, frame = FALSE, col= \"blue\")\n\n\n\nFigure 9.2: A Boxplot of age of adult patients."
  },
  {
    "objectID": "transformation.html#summarizing-numerical-variables",
    "href": "transformation.html#summarizing-numerical-variables",
    "title": "9  Data transformation",
    "section": "\n9.10 Summarizing Numerical variables",
    "text": "9.10 Summarizing Numerical variables\nSummary measures for one numerical variable\nThe next common task when working with data frames is to compute summary measures. Summary measures are single numerical values that summarize a large number of values.\nCommonly known examples of summary measures for numerical data include the arithmetic mean (also called the average) and the median (the middle value). Other examples of summary measures that might not immediately come to mind include the sum, the smallest value also called the minimum, the largest value also called the maximum, the 1st quartile and 3rd quartile, the standard deviation, the skewness, and the kurtosis.\nSummary functions in R take in many values and return a single value, as illustrated in Figure Figure 9.3.\n\n\nFigure 9.3: Diagram illustrating a summary function in R\n\n\nLet’s calculate two summary measures for the QRS variable in the arrhythmia_adults data frame: the mean and standard deviation. To compute these summary measures, we need the mean() and sd() statistical functions in R.\n\nmean(arrhythmia_adults$QRS, na.rm = TRUE)\n\n[1] 88.3972\n\nsd(arrhythmia_adults$QRS, na.rm = TRUE)\n\n[1] 14.44674\n\n\n\n\n\n\n\n\nna.rm argument\n\n\n\nThe na.rm argument of mean() and sd() statistical functions takes a logical value (TRUE/ FALSE) indicating whether NA values should be stripped before the computation proceeds.\n\n\n \nNow, we’ll use the mean() and sd() within the summarize() function from the dplyr package. Note we can also use the UK spelling of summarise(). The first argument should be a data frame with the raw data:\n\nsummary_QRS <- arrhythmia_adults %>% \n  summarize(mean_QRS = mean(QRS, na.rm = TRUE), \n            sd_QRS = sd(QRS, na.rm = TRUE))\nsummary_QRS\n\n# A tibble: 1 × 2\n  mean_QRS sd_QRS\n     <dbl>  <dbl>\n1     88.4   14.4\n\n\nThe results are saved in a new data frame tibble that has two columns/variables, the mean_QRS and the sd_QRS.\nOther summary functions that can be used inside the summarize() verb to compute summary measures are:\n\n\nmean(): the mean AKA the average\n\nsd(): the standard deviation, which is a measure of spread\n\nmin() and max(): the minimum and maximum values respectively\n\nIQR(): Interquartile range\n\nsum(): the sum\n\nskewness() : the skewness\n\nkurtosis() : the kurtosis\n\nn(): a count of the number of rows/observations in each group. This particular summary function will make more sense when group_by().\nSummary measures for more numerical variables\nWe can add more numerical variables:\n\nsummary_QRS_age <- arrhythmia_adults %>% \n                   summarize(mean_QRS = mean(QRS, na.rm = TRUE), \n                             sd_QRS = sd(QRS, na.rm = TRUE),\n                             mean_age = mean(age, na.rm = TRUE), \n                             sd_age = sd(age, na.rm = TRUE)\n                             )\nsummary_QRS_age\n\n# A tibble: 1 × 4\n  mean_QRS sd_QRS mean_age sd_age\n     <dbl>  <dbl>    <dbl>  <dbl>\n1     88.4   14.4     48.5   14.4\n\n\n \nWe can also calculate the mean for all numerical variables with the summarize_if():\n\nsummary_all_means <- arrhythmia_adults %>% \n  summarise_if(is.numeric, mean, na.rm = TRUE)\n        \nsummary_all_means\n\n# A tibble: 1 × 6\n    age height weight   QRS heart_rate   bmi\n  <dbl>  <dbl>  <dbl> <dbl>      <dbl> <dbl>\n1  48.5   165.   70.1  88.4       73.3  25.7\n\n\n \nGrouping rows by a categorical variable and summarize()\n\nSay instead of a single mean of QRS for all the adults, we want the mean QRS for the participants in each bmi category, separately. In other words, we would like to compute the mean QRS split by bmi_cat:\n\nsummary_QRS_bmi <- arrhythmia_adults %>% \n  group_by(bmi_cat) %>% \n  summarize(mean_QRS = mean(QRS, na.rm = TRUE), \n            sd_QRS = sd(QRS, na.rm = TRUE)) %>% \n  ungroup() # ungrouping variable is a good habit to prevent errors\n\nsummary_QRS_bmi \n\n# A tibble: 4 × 3\n  bmi_cat     mean_QRS sd_QRS\n  <fct>          <dbl>  <dbl>\n1 underweight     81.6   10.1\n2 normal          86.8   12.9\n3 overweight      90.3   15.5\n4 obese           89.5   16.3\n\n\nThis code is identical to the previous code that created summary_QRS, but with an extra function group_by() added before the summarize(). Grouping the arrhythmia_adults dataset by bmi_cat and then applying the summarize() function yields a data frame that displays the mean and standard deviation QRS split by bmi categories.\n\n\n\n\n\n\ngroup_by() function\n\n\n\nIt is important to note that the group_by() function doesn’t change data frames by itself. Rather it changes the grouping structure. It is only after we apply the summarize() function that the data frame changes.\n\n\nGrouping by more than one variable\nWe are not limited to grouping by one variable. Say we want to know the mean QRS of males and females in each of the four bmi categories:\n\nQRS_bmi_sex <- arrhythmia_adults %>% \n  group_by(bmi_cat, sex) %>% \n  summarize(mean_QRS = mean(QRS, na.rm = TRUE), \n            sd_QRS = sd(QRS, na.rm = TRUE)) %>% \n  ungroup()\n\nQRS_bmi_sex\n\n# A tibble: 8 × 4\n  bmi_cat     sex    mean_QRS sd_QRS\n  <fct>       <fct>     <dbl>  <dbl>\n1 underweight male       86.5  11.0 \n2 underweight female     78.9   9.17\n3 normal      male       92.7  11.3 \n4 normal      female     82.8  12.3 \n5 overweight  male       96.2  16.0 \n6 overweight  female     83.4  11.5 \n7 obese       male       94.8  14.9 \n8 obese       female     86.9  16.5 \n\n\nMore summary measures\nLet’s look at some summary measures of the QRS variable by considering multiple statistical functions at once in the same summarize() code:\n\nQRS_summary <- arrhythmia_adults %>% \n  summarize(\n    min = min(QRS, na.rm = TRUE),\n    q1 = quantile(QRS, 0.25, na.rm = TRUE),\n    median = quantile(QRS, 0.5, na.rm = TRUE),\n    q3 = quantile(QRS, 0.75, na.rm = TRUE),\n    max = max(QRS, na.rm = TRUE),\n    mean = mean(QRS, na.rm = TRUE),\n    sd = sd(QRS, na.rm = TRUE),\n    skewness = moments::skewness(QRS, na.rm = TRUE),\n    kurtosis= moments::kurtosis(QRS, na.rm = TRUE),\n    missing = sum(is.na(QRS)),\n    n = n())\n\nQRS_summary\n\n# A tibble: 1 × 11\n    min    q1 median    q3   max  mean    sd skewness kurtosis missing     n\n  <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>   <int> <int>\n1    55    80     86    94   188  88.4  14.4     2.46     13.9       0   428\n\n\nThe distribution of the data can be represented by an histogram.\n\nhist(arrhythmia_adults$QRS, main = \"Histogram\", xlab = \"QRS (ms)\", ylab = \"Frequency\")\n\n\n\nFigure 9.4: A Histogram of QRS of adult patients.\n\n\n\n\nAs we can see the distribution of QRS variable is not symmetrical.\nIf we want the summary statistics for males and females separately we must use the group_by() function:\n\nQRS_summary2 <- arrhythmia_adults %>% \n  group_by(sex) %>% \n  summarize(\n    min = min(QRS, na.rm = TRUE),\n    q1 = quantile(QRS, 0.25, na.rm = TRUE),\n    median = quantile(QRS, 0.5, na.rm = TRUE),\n    q3 = quantile(QRS, 0.75, na.rm = TRUE),\n    max = max(QRS, na.rm = TRUE),\n    mean = mean(QRS, na.rm = TRUE),\n    sd = sd(QRS, na.rm = TRUE),\n    skewness = moments::skewness(QRS, na.rm = TRUE),\n    kurtosis= moments::kurtosis(QRS, na.rm = TRUE),\n    missing = sum(is.na(QRS)),\n    n = n()\n  ) %>% \n  ungroup()\n\nQRS_summary2\n\n# A tibble: 2 × 12\n  sex     min    q1 median    q3   max  mean    sd skewn…¹ kurto…² missing     n\n  <fct> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>   <dbl>   <int> <int>\n1 male     71    87     92    99   188  94.4  14.1    2.93    17.1       0   191\n2 fema…    55    77     82    87   163  83.5  12.8    2.98    17.0       0   237\n# … with abbreviated variable names ¹​skewness, ²​kurtosis\n\n\n\nhist(arrhythmia_adults$QRS[arrhythmia_adults$sex==\"male\"],\n     main = \"Histogram (males)\", xlab = \"QRS (ms)\", ylab = \"Frequency\")\n\nhist(arrhythmia_adults$QRS[arrhythmia_adults$sex==\"female\"], \n     main = \"Histogram (females)\", xlab = \"QRS (ms)\", ylab = \"Frequency\")\n\n\n\n\n(a) Histogram of QRS of males.\n\n\n\n\n(b) Histogram of QRS of females.\n\n\n\nFigure 9.5: Histogram of QRS of males and females patients.\n\n\n\nLet’s see the age variable:\n\nage_summary <- arrhythmia_adults %>% \n  summarize(\n    min = min(age, na.rm = TRUE),\n    q1 = quantile(age, 0.25, na.rm = TRUE),\n    median = quantile(age, 0.5, na.rm = TRUE),\n    q3 = quantile(age, 0.75, na.rm = TRUE),\n    max = max(age, na.rm = TRUE),\n    mean = mean(age, na.rm = TRUE),\n    sd = sd(age, na.rm = TRUE),\n    skewness = moments::skewness(age, na.rm = TRUE),\n    kurtosis= moments::kurtosis(age, na.rm = TRUE),\n    missing = sum(is.na(age)),\n    n = n())\n\nage_summary\n\n# A tibble: 1 × 11\n    min    q1 median    q3   max  mean    sd skewness kurtosis missing     n\n  <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>   <int> <int>\n1    18    37     47    59    83  48.5  14.4   0.0851     2.31       0   428\n\n\n\nhist(arrhythmia_adults$age, main = \"Histogram\", xlab = \"Age (years)\", ylab = \"Frequency\")\n\n\n\nFigure 9.6: A Histogram of age of adult patients.\n\n\n\n\nThe age variable approximates a symmetrical distribution (bell-shaped)."
  },
  {
    "objectID": "transformation.html#summarizing-categorical-variables",
    "href": "transformation.html#summarizing-categorical-variables",
    "title": "9  Data transformation",
    "section": "\n9.11 Summarizing Categorical variables",
    "text": "9.11 Summarizing Categorical variables\nFrequency distribution table\nSummary measures for categorical data include frequencies and percentages. If we have two categorical variables, we might be interested in a 2-dimensional frequency distribution table. Say we want to know the number of males and females in each of the four bmi catecories. We can create a frequency distribution table with table() function for the variables bmi_cat and sex:\n\ntb1 <- table(arrhythmia_adults$bmi_cat, arrhythmia_adults$sex)\n\ntb1\n\n             \n              male female\n  underweight    4      7\n  normal        77    115\n  overweight    91     76\n  obese         19     39\n\n\nWe can also create a frequency distribution table using the functions count() from the dplyr package:\n\ntb2 <- arrhythmia_adults %>%\n             count(bmi_cat, sex)\n\ntb2\n\n# A tibble: 8 × 3\n  bmi_cat     sex        n\n  <fct>       <fct>  <int>\n1 underweight male       4\n2 underweight female     7\n3 normal      male      77\n4 normal      female   115\n5 overweight  male      91\n6 overweight  female    76\n7 obese       male      19\n8 obese       female    39\n\n\nFrequency distribution table with total percentages\nWe can also create a summary statistics using the functions count() and mutate() from the dplyr package to find the total percentages:\n\ntb3 <- arrhythmia_adults %>%\n             count(bmi_cat, sex) %>%\n             mutate(percentage = round(n*100/sum(n), digits = 2))\n\ntb3\n\n# A tibble: 8 × 4\n  bmi_cat     sex        n percentage\n  <fct>       <fct>  <int>      <dbl>\n1 underweight male       4       0.93\n2 underweight female     7       1.64\n3 normal      male      77      18.0 \n4 normal      female   115      26.9 \n5 overweight  male      91      21.3 \n6 overweight  female    76      17.8 \n7 obese       male      19       4.44\n8 obese       female    39       9.11\n\n\nIn the above table we can see the frequency for each category and the total percentage (the frequency is divided by the total number of observations, here 428). For example, the percentage of underweight males is 0.93%, (4/428)*100.\nFrequency distribution table with percentages inside for each bmi category\nHowever, we may want to calculate the percentage inside for each category. For example, the percentage of males (n = 4) in the underweight category (n = 11) is 36.4%, (4/11)*100. We will use the functions group_by(), summarize() and mutate() from the dplyr package:\n\ntb4 <- arrhythmia_adults %>% \n  group_by(bmi_cat, sex) %>% \n  summarize(n=n()) %>% \n  mutate(percentage = round(n*100/sum(n), digits = 2)) %>% \n  ungroup()\n\ntb4\n\n# A tibble: 8 × 4\n  bmi_cat     sex        n percentage\n  <fct>       <fct>  <int>      <dbl>\n1 underweight male       4       36.4\n2 underweight female     7       63.6\n3 normal      male      77       40.1\n4 normal      female   115       59.9\n5 overweight  male      91       54.5\n6 overweight  female    76       45.5\n7 obese       male      19       32.8\n8 obese       female    39       67.2"
  },
  {
    "objectID": "visualization.html",
    "href": "visualization.html",
    "title": "10  Data Visualization: ggplot2",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "visualization.html#introduction-to-ggplot2",
    "href": "visualization.html#introduction-to-ggplot2",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.1 Introduction to ggplot2",
    "text": "10.1 Introduction to ggplot2\nThe ggplot2 package is generally the preferred tool of choice for constructing data visualizations in R. The main reason for this is because of its grounding in the grammar of graphics, the idea that any plot can be expressed from the same set of components: a data set, a coordinate system, and a set of geoms–the visual representation of data points. To display values, ggplot2 maps variables in the data to visual properties of the geom (aesthetics) like size, color, and x and y locations. Additionally, the key to understanding ggplot2 is thinking about a figure in layers.\nThere are many extension packages for ggplot2, which make it easy to produce specialized types of graphs, such as survival plots, geographic maps and ROC curves. With ggplot2 (and its extensions), users can produce elegant, professional-looking visualizations that communicate results powerfully to the desired audience. However, ggplot2 runs into some limitations regarding user interactivity. This becomes increasingly problematic when creating interactive documents using R Markdown or dashboard apps in R Shiny, where interactivity is a crucial component of communicating information effectively.\nFortunately, the plotly package significantly enhances the design of interactive charts in R, allowing users to hover over data points, zoom into specific areas, pan back and forth through time, and much more."
  },
  {
    "objectID": "visualization.html#dataset-covid-19",
    "href": "visualization.html#dataset-covid-19",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.2 Dataset Covid-19",
    "text": "10.2 Dataset Covid-19\nIn this example, we investigate graphically the association between a country’s wealth and COVID-19 cases. This research question may provide valuable information on whether interventions have been successful, and whether people in countries with fragile health systems are at increased risk.\nWhat other variables are associated to both wealth and COVID-19 cases? For example, wealthier countries may have more resources to test for the virus and a lack of reported cases in developing countries could indicate a scarcity of testing. Therefore, when assessing wealth and COVID-19 cases, we should be cautious when comparing countries with different testing rates. In addition, evidence suggests age is an important factor in COVID-19 infection and mortality. Therefore, we should be careful when comparing countries with higher proportions of older inhabitants to other countries. Using diagrams to depict multivariable associations may be helpful.\nLoad the data\nWe load the file covid_data.csv in R.\n\nlibrary(readr)\ncovid_data <- read_csv(\"data/covid_data.csv\", col_types = cols(date = col_date(format = \"%m/%d/%Y\")))\n\ncovid_data\n\n# A tibble: 132,236 × 14\n   iso3c country date       confi…¹ deaths recov…² total…³ region income popul…⁴\n   <chr> <chr>   <date>       <dbl>  <dbl>   <dbl>   <dbl> <chr>  <chr>    <dbl>\n 1 ABW   Aruba   2020-03-13      NA     NA      NA      NA Latin… High …  106766\n 2 ABW   Aruba   2020-03-14      NA     NA      NA      NA Latin… High …  106766\n 3 ABW   Aruba   2020-03-15      NA     NA      NA      NA Latin… High …  106766\n 4 ABW   Aruba   2020-03-16      NA     NA      NA      NA Latin… High …  106766\n 5 ABW   Aruba   2020-03-17      NA     NA      NA      NA Latin… High …  106766\n 6 ABW   Aruba   2020-03-18      NA     NA      NA      NA Latin… High …  106766\n 7 ABW   Aruba   2020-03-19      NA     NA      NA      NA Latin… High …  106766\n 8 ABW   Aruba   2020-03-20      NA     NA      NA      NA Latin… High …  106766\n 9 ABW   Aruba   2020-03-21      NA     NA      NA      NA Latin… High …  106766\n10 ABW   Aruba   2020-03-22      NA     NA      NA      NA Latin… High …  106766\n# … with 132,226 more rows, 4 more variables: pop_density <dbl>,\n#   life_expectancy <dbl>, gdp_capita <dbl>, timestamp <dttm>, and abbreviated\n#   variable names ¹​confirmed, ²​recovered, ³​total_tests, ⁴​population\n\n\nLet’s have a look at the types of variables:\n\nglimpse(covid_data)\n\nRows: 132,236\nColumns: 14\n$ iso3c           <chr> \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\"…\n$ country         <chr> \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", …\n$ date            <date> 2020-03-13, 2020-03-14, 2020-03-15, 2020-03-16, 2020-…\n$ confirmed       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ deaths          <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ recovered       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ total_tests     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ region          <chr> \"Latin America & Caribbean\", \"Latin America & Caribbea…\n$ income          <chr> \"High income\", \"High income\", \"High income\", \"High inc…\n$ population      <dbl> 106766, 106766, 106766, 106766, 106766, 106766, 106766…\n$ pop_density     <dbl> 593.1444, 593.1444, 593.1444, 593.1444, 593.1444, 593.…\n$ life_expectancy <dbl> 76.293, 76.293, 76.293, 76.293, 76.293, 76.293, 76.293…\n$ gdp_capita      <dbl> 26631.47, 26631.47, 26631.47, 26631.47, 26631.47, 2663…\n$ timestamp       <dttm> 2021-10-09 02:10:32, 2021-10-09 02:10:32, 2021-10-09 …\n\n\nThe data frame contains 132236 rows and 14 variables. There are 8 numeric variables, 4 variables of character type, and 2 variables with dates (one of date type and the other of dttm type):\n\n\niso3c: ISO3c country code as defined by ISO 3166-1 alpha-3\n\ncountry: Country name\n\ndate: Calendar date\n\nconfirmed: Confirmed Covid-19 cases as reported by JHU CSSE (accumulated)\n\ndeaths: Covid-19-related deaths as reported by JHU CSSE (accumulated)\n\nrecovered: Covid-19 recoveries as reported by JHU CSSE (accumulated)\n\ntotal_tests: Accumulated test counts as reported by Our World in Data\n\nregion: Country region as classified by the World Bank (time-stable)\n\nincome: Country income group as classified by the World Bank (time-stable)\n\npopulation: Country population as reported by the World Bank (original identifier ‘SP.POP.TOTL’, time-stable)\n\npop_density: Country population density as reported by the World Bank (original identifier ‘EN.POP.DNST’, time-stable)\n\nlife_expectancy Average life expectancy at birth of country citizens in years as reported by the World Bank (original identifier ‘SP.DYN.LE00.IN’, time-stable)\n\ngdp_capita: Country gross domestic product per capita, measured in 2010 US-$ as reported by the World Bank (original identifier ‘NY.GDP.PCAP.KD’, time-stable)\n\ntimestamp: Date and time where data has been collected from authoritative sources\n\nAnother informative function to inspect our dataset is skim() in the skimr package:\n\nskimr::skim(covid_data)\n\nData preparation for the plots\nThe data cover a period from 2019-12-31 to 2021-10-07.\nSuppose we are interested in investigating countries with population more than 1 million up to June, 12 2021 and we want also to calculate the cases per 100000 inhabitants and tests per capita:\n\ndat <- covid_data %>%\n  filter(date == \"2021-06-12\", population > 1000000) %>%\n  mutate(cases_per_100k = confirmed / population * 100000,\n         tests_per_capita = total_tests / population)"
  },
  {
    "objectID": "visualization.html#step-by-step-anatomy-of-a-ggplot",
    "href": "visualization.html#step-by-step-anatomy-of-a-ggplot",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.3 Step-by-step anatomy of a ggplot",
    "text": "10.3 Step-by-step anatomy of a ggplot\nBecause ggplot2 is a core tidyverse package, it is installed for us when we installed the tidyverse meta-package.\n\nggplot2 is a system for declaratively creating graphics, based on The Grammar of Graphics. We provide the data, tell ggplot2 how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details.\n\nConsequently, a ggplot is built up from a few basic elements (Figure 10.1):\n\n\nData: The raw data that we want to plot.\n\nGeometries geom_: The geometric shapes that will represent the data.\n\nAesthetics aes(): Aesthetics of the geometric and statistical objects, such as color, size, shape, transparency and position.\n\nScales scale_: Maps between the data and the aesthetic dimensions, such as data range to plot width or factor values to colors.\n\nStatistical transformations stat_: Statistical summaries of the data, such as quantiles, fitted curves and sums.\n\nCoordinate system coord_: The transformation used for mapping data coordinates into the plane of the data rectangle.\n\nFacets facet_: The arrangement of the data into a grid of plots.\n\nVisual themes theme(): The overall visual defaults of a plot, such as background, grids, axes, default typeface, sizes and colors.\n\n\n\n\n\nFigure 10.1: ggplot2 basic syntax.\n\n\n\n\nStart with a default blank ggplot\nWe always start to define a plotting element by calling:\n\nggplot(data = df, mapping = aes(x = variable1, y = variable2)).\n\nFor example, here, we map the variable gdp_capita to the x position and the variable cases_per_100K to the y position. Later, we will also map variables to all kind of other aesthetics such as color, size, and shape.\n\np <- ggplot(data = dat, mapping = aes(x = gdp_capita, y = cases_per_100k))\np\n\n\n\nFigure 10.2: A default blank ggplot.\n\n\n\n\nThe ggplot() function has two basic arguments. The argument data defines which dataset to use for the plot; this allows us to refer to gdp_capita and gdp_capita without repeating from which dataset they come. The argument mapping defines which variables are mapped onto which aesthetics. Aesthetics are the visual properties of the elements that make up the plot. For example, aes(x = gdp_capita, y = cases_per_100k) means that the x and y aesthetics of all elements will be mapped onto the variables gdp_capita and gdp_capita, respectively.\nAs we can see, only a panel is created when running this. Why? This is because we have only told ggplot what dataset to use and what columns should be used for x and y axis. We haven’t explicitly asked it to draw anything else —we still need to provide a geometry!\nggplot2 allows us to store the current ggobject in an object of our choice by assigning it to a name, in our case called p. We can add other elements on top of the blank layer using the + operator.\n\n\n\n\n\n\nTip\n\n\n\nWe don’t usually have to spell out data and mapping.\n\n\nNext, suppose that we want to create a scatter plot. This type of graph can be useful for showing the association between at least two variables, because they allow us to encode data simultaneously on a horizontal x‐axis and vertical y‐axis to see whether and what association exists.\nAdd a geometry\nGeoms are the geometric shapes that make up ggplot2 visualisations (Figure 10.3). Each is called with a function that begins with geom_* and ends with the name of the geom (e.g., point or line). Each geom has a number of aesthetics that define its visual properties.\n\n\n\n\nFigure 10.3: Geometries for two continuous variables.\n\n\n\n\nLet’s tell ggplot2 which style we want to use. For example, we will built a scatter plot by adding points using a geom layer called geom_point. In this case, geom_point() inherits the x and y aesthetics from the ggplot() function.\n\np + geom_point()\n\nWarning: Removed 3 rows containing missing values (geom_point).\n\n\n\n\nFigure 10.4: Adding a geometry of points on the canvas.\n\n\n\n\nAdd aesthtics to geometries: aes()\n\nEach geom comes with its own properties (called arguments) and the same argument may result in a different change depending on the geom we are using.\nAesthetic attributes describe every aspect of a given graphical element and refer to which variable is mapped onto it. We can map our data to anything that our geom supports.\nTo add additional variables to a plot, we can use aesthetics like color, shape, and size.\n\nEach argument to aes() maps a variable in our data to a specific element in our geom.\n\nA. color aesthetics\nColor is an important dimension in human vision and is consequently equally important in the design of a scientific figure. However, color can be either our greatest ally or our worst enemy if not used properly. If we decide to use color, we should consider which colors to use and where to use them.\nColor palettes (or colormaps) are classified into three main categories in ggplot2:\n\n\nSequential: one variation of a unique color, used for quantitative data varying from dark to light (Figure 10.5). These scales may exist in discrete or continuous forms or both.\n\n\n\n\n\nFigure 10.5: Example sequential color scales.\n\n\n\n\n\n\nDiverging: variation from one color to another, used to highlight deviation from a median value (Figure 10.6) A diverging color scale creates a gradient between three different colors, allowing us to easily identify low, middle, and high values within our data.\n\n\n\n\n\nFigure 10.6: Example diverging color scales.\n\n\n\n\n\n\nQualitative: a discrete set of distinct colors with no implied order, used mainly for discrete or categorical data (Figure 10.7).\n\n\n\n\n\nFigure 10.7: Example qualitative color scales.\n\n\n\n\nNow, suppose we want to group the points according to the categorical variable region using different colors, as follows:\n\np + geom_point(aes(color = region))\n\nWarning: Removed 3 rows containing missing values (geom_point).\n\n\n\n\n\n\n\n\nHere, we added inside the aes() of geom_point the color aesthetic. The data of the categorical variable region mapped to color aesthetic of geom_point. Obviously, the qualitative scale was applied automatically by ggplot2. In addition, ggplot automatically created a legend to show the correspondence between the regions and colors.\nTo find all aesthetics that apply to the geom_point() function, run ?geom_point. We can find a useful list of all aesthetic specifications there.\n\n\n\n\n\n\nImportant\n\n\n\nThe grouping variable must be categorical—in other words, a factor or character vector. If it is stored as a vector of numeric values, it should be converted to a factor before it is used as a grouping variable.\n\n\nIt is very important to understand the difference between including ggplot arguments inside or outside of the aes() function. For example, let’s see the difference if we add the color outside the aes() function:\n\np + geom_point(color = \"red\")\n\nWarning: Removed 3 rows containing missing values (geom_point).\n\n\n\n\n\n\n\n\nIn this case, we set an aesthetic to a fixed value (red) in the individual layer geom_point outside of aes(). In fact, we set the red color for the entire graph (constant aesthetics), so it changed the color of the plot globally.\n\n\n\n\n\n\nTip\n\n\n\nggplot2 understands both color and colour as well as the short version col\n\n\nIn R, colors can be specified either by name (e.g., \"blue\") or as a hexadecimal RGB triplet (such as #0072B2). The hexadecimal system defines each color (red, green, or blue) in terms of two values that range from 0–9, then from A–F, giving a total of 16 different values for each character.\nWe can also use palettes of colors such as viridis palette which we will use in the next graphs. In following Table we present a color blind-friendly palette.\nIn R, the hex color code goes in quotes and is preceded by a #. For example:\n\n\nName\nHex code\n\n\n\norange\n#E69F00\n\n\nsky blue\n#56B4E9\n\n\nbluish green\n#009E73\n\n\nyellow\n#F0E442\n\n\nblue\n#0072B2\n\n\nvermilion\n#D55E00\n\n\nreddish purple\n#CC79A7\n\n\nblack\n#000000\n\n\n\nAlthough the code for hexadecimal may not be intuitive, it is easy to look up online exactly what the code is for any color we want to use (just do an internet search for something like “RGB to Hex color”). The main advantage of the Hex system over RGB is that it is very compact to specify whatever color we want.\nB. shape aesthetics\nAlternatively, we can group the points according to the region variable using different point shapes, as follows:\n\np + geom_point(aes(shape = region))\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because\nmore than 6 becomes difficult to discriminate; you have 7. Consider\nspecifying shapes manually if you must have them.\n\n\nWarning: Removed 46 rows containing missing values (geom_point).\n\n\n\n\n\n\n\n\nThe different points shapes symbols commonly used in R are shown in the Figure 10.8 below:\n\n\n\n\nFigure 10.8: The different points symbols commonly used in R.\n\n\n\n\nAs we can observe in the previous graph, ggplot2 by default allows only six different point shapes to be displayed. However, we will see how to change this using appropriate scales.\nC. size aesthetics\nNext, we can add a third variable tests_per_capita using the size aesthetic:\n\np + geom_point(aes(size = tests_per_capita))\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\n\n\n\n\n\n\nAdd a new geom\nWe can add the name of the country for each data point:\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point() +\n  geom_text_repel(aes(label = country))\n\nWarning: Removed 3 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 93 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps"
  },
  {
    "objectID": "visualization.html#change-the-default-properties-of-the-plot-scales",
    "href": "visualization.html#change-the-default-properties-of-the-plot-scales",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.4 Change the default properties of the plot: scales\n",
    "text": "10.4 Change the default properties of the plot: scales\n\nChange the scale of the axis\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1) +\n  scale_y_continuous(trans = \"log10\") # or scale_y_log10()\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 117 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\nContinuous variable tests_per_capital mapped to size and categorical variable region mapped to color.\nChange the default colors\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_color_npg()\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 117 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\nChange the default shape points\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, shape= region)) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_shape_manual(values = c(4, 16, 2, 1, 0, 19, 8))\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 117 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\nHowever, when a variable is mapped to size (here, test_per_capital), it’s a good idea to not map a variable to shape (here, region). This is because it is difficult to compare the sizes of different shapes (e.g., a size 4 square with a size 4 triangle). Also, some of the shapes really are different sizes: shapes 16 and 19 are both circles, but at any given numeric size, shape 19 circles are visually larger than shape 16 circles."
  },
  {
    "objectID": "visualization.html#modify-axis-legend-and-plot-labels-labs",
    "href": "visualization.html#modify-axis-legend-and-plot-labels-labs",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.5 Modify axis, legend, and plot labels: labs()\n",
    "text": "10.5 Modify axis, legend, and plot labels: labs()\n\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\",\n       title = \"Confirmed cases per 100,000 inhabitants, GDP per capita, and COVID-19 testing rate by country\", \n       subtitle = \"May 20, 2021\", \n       caption = \"Source Data: Covid-19 related data from {tidycovid19} package\",\n       tag = 'A')\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 127 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps"
  },
  {
    "objectID": "visualization.html#modify-theme-components-theme",
    "href": "visualization.html#modify-theme-components-theme",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.6 Modify theme components: theme()\n",
    "text": "10.6 Modify theme components: theme()\n\nWe can fine tune the appearance of the graph using themes. Theme functions (which start with element_) control background colors, fonts, grid-lines, legend placement, and other non-data related features of the graph.\nThis function is very complex since it allows you to specify all the different details contributing to the plot appearance as well as generating your own format and style.\n\n\n\n\nFigure 10.9: The different points symbols commonly used in R.\n\n\n\n\nggplot2 theme system comes with multiple element_ functions:\n\n\nelement_text(): specify the display of text elements\n\nelement_line(): specify the display of lines (i.e. axis lines)\n\nelement_rect(): specify the display of borders and backgrounds\n\nelement_blank()draw nothing\n\nelement_text()\nWhile making a plot with ggplot2, it automatically chooses appropriate values for various aspects of element text. In total there are 10 different aspects/elements of texts in a plot made with ggplot2. The figure below shows the anatomy of text elements and the key word in ggplot2 describing the element.\n\n\n\n\nFigure 10.10: Anatomy of Text Elements in ggplot2.\n\n\n\n\nWith element_text(), we can customize the looks of the the texts. For example, to control the look of title of a plot, we will use plot.title element as argument to theme() function and use element_text() to specify the color, font and size of the plot title.\nelement_line()\nWith element_line(), we can customize all the lines that are not part of data. For example, we can customize the color of x and y axis lines, we can make the axis lines as arrows, and we can add second x-axis on top and so on.\nBroadly, with element_line() we can customize three groups of lines in a plot. First, are X and Y axis lines. Second, are the lines associated with tick on X and Y axis. And the third, are the major and minor grid lines along both X and Y axis. The figure below shows the anatomy of line elements and the key word in ggplot2 describing the element.\n\n\n\n\nFigure 10.11: Anatomy of Line Elements in ggplot2.\n\n\n\n\nelement_rect()\nWith element_rect(), we can customize all things that are rectangular in a plot. For example, we can customize the line and fill colors of rectangles that define borders and backgrounds in a plot.\nIn total there are 7 aspects of rectangular elements we can control using using element_rect().\n\n\n\n\nFigure 10.12: Anatomy of Rectangle Elements in ggplot2.\n\n\n\n\nelement_blank()\nIf we look at the ggplot2 theme documentation page, we can see that element_blank() does not take any arguments. So what does it do? As it says element_blank(): draws nothing, and assigns no space. We can use element_blank() if we don’t want any specific non-data plot elements drawn on the plot (we disable them). With element_blank() we can suppress or remove change for each of the theme elements. For example, using panel.grid.minor = element_blank() in the theme() we disable the minor grid lines of the panel."
  },
  {
    "objectID": "visualization.html#modify-theme-elements-in-practice",
    "href": "visualization.html#modify-theme-elements-in-practice",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.7 Modify theme elements in practice",
    "text": "10.7 Modify theme elements in practice\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1, color = \"white\", size = 5) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\",\n       title = \"Confirmed cases per 100,000 inhabitants, GDP per capita, and COVID-19 \\ntesting rate by country\", \n       subtitle = \"May 20, 2021\", \n       caption = \"Source Data: Covid-19 related data from {tidycovid19} package\") +\n  theme(\n        # background, panel and grid lines\n        plot.background = element_blank(),\n        panel.background = element_rect(fill = \"grey30\"),\n        panel.grid.major = element_line(size = 0.1, color = \"grey50\"),\n        panel.grid.minor = element_blank(),\n        # title, subtitle and caption\n        plot.title = element_text(size = 15),\n        plot.subtitle = element_text(size = 12),\n        plot.caption = element_text(size = 10),\n        # axis\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10),\n        # legend\n        legend.background = element_blank(),\n        legend.title = element_text(size = 10, face = \"bold\"),\n        legend.text = element_text(size = 10),\n        legend.key = element_rect(color = \"white\"),\n        legend.position= \"bottom\",\n        legend.box = 'vertical'\n        )\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 61 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\nThe figure depicts strong, positive relationships between the following pairs of variables: wealth/COVID-19 cases, wealth/COVID-19 testing, and COVID-19 cases/testing. Note the use of two plot attributes (size and color) to depict additional variables."
  },
  {
    "objectID": "visualization.html#adding-an-in-build-theme-from-ggplot2",
    "href": "visualization.html#adding-an-in-build-theme-from-ggplot2",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.8 Adding an in-build theme from ggplot2\n",
    "text": "10.8 Adding an in-build theme from ggplot2\n\nWhile it is possible to build up a new theme from the ground it is usually easier and less error-prone to modify an existing theme. This is done in ggplot2 as well as can be seen by looking at e.g., theme_minimal():\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1, color = \"black\", size = 3) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\",\n       title = \"Confirmed cases per 100,000 inhabitants, GDP per capita, and COVID-19 testing rate by country\", \n       subtitle = \"May 20, 2021\", \n       caption = \"Source Data: Covid-19 related data from {tidycovid19} package\") +\n  theme_minimal()\n\nWarning: Removed 76 rows containing missing values (geom_point).\n\n\nWarning: Removed 3 rows containing missing values (geom_text_repel).\n\n\nWarning: ggrepel: 114 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\nIn-build theme from ggplot2:\n\n\ntheme_gray() – signature ggplot2 theme\n\ntheme_bw() – dark on light ggplot2 theme\n\ntheme_linedraw() – uses black lines on white backgrounds only\n\ntheme_light() – similar to linedraw() but with grey lines aswell\n\ntheme_dark() – lines on a dark background instead of light\n\ntheme_minimal() – no background annotations, minimal feel.\n\ntheme_classic() – theme with no grid lines.\n\ntheme_void() – empty theme with no elements"
  },
  {
    "objectID": "visualization.html#blur-points",
    "href": "visualization.html#blur-points",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.9 Blur points",
    "text": "10.9 Blur points\nWe can focus the attention on specific region e.g. East Asia and Pacific countries. One solution is to blur all the points that we do not want to highlight. We will use the with_blur() function, which blurs the layers to which it is applied.\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k, size = tests_per_capita, color = region)) +\n  with_blur(\n  geom_point(data=dat %>% filter(region != \"East Asia & Pacific\")),\n  sigma = unit(0.95, 'mm') # you can choose the amount of blur \n  ) +\n  geom_point(data=dat %>% filter(region == \"East Asia & Pacific\")) +\n  geom_text_repel(data=dat %>% filter(region == \"East Asia & Pacific\"), aes(label = country), min.segment.length = 0, seed = 42, \n                  box.padding = 0.1, \n                  color = \"black\", size = 5) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\",\n       title = \"Confirmed cases per 100,000 inhabitants, GDP per capita, and <span style='font-size:18pt'>COVID-19</span> testing rate by country with emphasis in  <br> <span style='color:#E64B35FF'>East Asia & Pacific</span> countries\", \n       subtitle = \"May 20, 2021\", \n       caption = \"Source Data: Covid-19 related data from {tidycovid19} package\") +\n  theme_minimal() +\n  theme(plot.title = element_markdown())\n\n\n\n\n\n\n\nIn the above graph, additional styling was applied via inline CSS (Cascading Style Sheets) to the title. The CSS properties color, font-size, and font-family are currently supported.\n\nThe ggtext package defines a new theme element, element_markdown(). It behaves similarly to element_text() but render the provided text as markdown/html. element_markdown() is meant as a direct replacement for element_text(), and it renders text without word wrapping. To start a new line, use the <br> tag or add two spaces before the end of a line."
  },
  {
    "objectID": "visualization.html#highlight-data-points",
    "href": "visualization.html#highlight-data-points",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.10 Highlight data points",
    "text": "10.10 Highlight data points\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k, \n                color = region)) +\n  geom_point(aes(size = tests_per_capita)) +\n  scale_y_continuous(trans = \"log10\") +\n  scale_color_npg() +\n  gghighlight(region == \"East Asia & Pacific\", keep_scales = TRUE, \n              use_direct_label = FALSE) +\n  geom_text_repel(aes(label = country),\n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.3, \n                  color = \"black\", size = 4) +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\",\n       title = \"Confirmed cases per 100,000 inhabitants, GDP per capita, and <span style='font-size:14pt'>COVID-19</span> testing rate by country with emphasis in  <br> <span style='color:#E64B35FF'>East Asia & Pacific</span> countries\", \n       subtitle = \"May 20, 2021\", \n       caption = \"Source Data: Covid-19 related data from {tidycovid19} package\") +\n  theme_minimal() +\n  theme(plot.title = element_markdown())"
  },
  {
    "objectID": "visualization.html#limit-axis-range-zoom",
    "href": "visualization.html#limit-axis-range-zoom",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.11 Limit Axis Range (Zoom)",
    "text": "10.11 Limit Axis Range (Zoom)\nSometimes we want to zoom into our data. We can do this without subsettting our data. We can change the X and Y axis limits by zooming in to the region of interest without deleting points. This is done using coord_cartesian().\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text(aes(label = country), size = 5) +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\") +\n  coord_cartesian(ylim=c(3.8*10^3, 1.6*10^4)) +\n  theme_minimal() +\n  theme(legend.position= \"bottom\",\n        legend.box = 'vertical')\n\n\n\n\n\n\n\nNote that the text is above the points, because it is the ‘top layer’ of the plot. The geom_* layers that appear early in the command are drawn first, and can be obscured by the geom_* layers that come after them.\nWhat happens if we switch the order of the geom_point() and geom_text() functions above? What do we notice?"
  },
  {
    "objectID": "visualization.html#highlight-a-certain-area-of-the-figure",
    "href": "visualization.html#highlight-a-certain-area-of-the-figure",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.12 Highlight a certain area of the figure",
    "text": "10.12 Highlight a certain area of the figure\nThe facet_zoom() function from the package ggforce provides the means to zoom in on a subset of the data, while keeping the view of the full dataset as a separate panel.\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text(aes(label = country), size = 5) +\n  scale_y_log10() +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\"\n       ) +\n  facet_zoom(xlim = c(50000, 70000))\n\n\n\n\n\n\n\nAnother way to zoom-in detail is using the package ggpp. The geom_plot() geometry plots ggplot objects, nested in a tibble passed as data argument, using aesthetics x and y for positioning, and label for the ggplot object containing the definition of the plot to be nested. As an example we produce a plot where the inset plot is a zoomed-in detail from the main plot. In this case the main and inset plots start as the same plot.\n\n# the inset plot\ngp1 <- ggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text(aes(label = country), size = 3) +\n  scale_color_npg() +\n  theme(legend.position = \"none\")\n\n\ndata.tb <- \n  tibble(x = 110000, y = 1, \n         plot = list(gp1 + \n                       coord_cartesian(xlim = c(30000, 80000), \n                                       ylim = c(4000, 11000)) +\n                       labs(x = NULL, y = NULL) ))\n\n# the main plot\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(aes(size = tests_per_capita, color = region)) +\n  geom_text(aes(label = country), size = 3) +\n  geom_plot(data = data.tb, aes(x, y, label = plot)) +\n  annotate(geom = \"rect\", \n            xmin = 30000, xmax = 80000, \n           ymin = 4000, ymax = 11000,\n           linetype = \"dotted\", \n           fill = NA, colour = \"black\") +\n  scale_y_log10() +\n  scale_color_npg() +\n  labs(x = \"GDP per capita ($)\",\n       y = \"Cases per 100,000 inhabitants\",\n       color = \"Region\",\n       size = \"Proportion tested\")"
  },
  {
    "objectID": "visualization.html#split-a-plot-into-a-matrix-of-panels-facet",
    "href": "visualization.html#split-a-plot-into-a-matrix-of-panels-facet",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.13 Split a plot into a matrix of panels: facet()\n",
    "text": "10.13 Split a plot into a matrix of panels: facet()\n\nAnother technique for displaying categorical variables on a plot is faceting. The facet approach partitions a plot into a matrix of panels. Each panel shows a different subset of the data. Coordinate systems and faceting control the position of elements of the plot.\nThere are two types of faceting provided by ggplot2: facet_wrap and facet_grid. Facet wrap produces a 1d ribbon of panels that is wrapped into 2d to save space, while facet grid produces a 2d grid of panels defined by variables which form the rows and columns. These differences are illustrated in Figure \\(\\ref{fig:facets}\\).\n\n\n\n\nFigure 10.13: A sketch illustrating the difference between the two faceting systems.\n\n\n\n\n\n\n\n\nFigure 10.14: ggplot2 basic theme and facet elements.\n\n\n\n\n\nfacet_wrap multiple-panel plots based on one variable\nFacets can be placed next to each other, wrapping with a certain number of columns or rows. The label for each plot will be at the top of the plot.\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(size = 2.0) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1,  color = \"black\", size = 4) +\n  scale_y_continuous(trans = \"log10\") +\n  facet_wrap(~region,  ncol=2)\n\n\n\n\n\n\n\nThe points in a scatter plot may obscure each other and prevent the viewer from accurately assessing the distribution of the data. This is called overplotting. If the amount of overplotting is low, you may be able to alleviate it by using smaller points, by using a different shape through which other points can be seen, or making the points semitransparent using alpha.\n\nggplot(dat, aes(x = gdp_capita, y = cases_per_100k)) +\n  geom_point(size = 1.5, alpha = 0.4) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1, color = \"black\", size = 4) +\n  scale_y_continuous(trans = \"log10\") +\n  facet_wrap(~region,  ncol=2)\n\n\n\n\n\n\n\n\nfacet_grid multiple-panel plots based on two variables\nThe facet_grid() function does a similar thing but instead of creating different plots it creates different grids and then plots each plot in the grids. The data can be split up by one or two variables that vary on the horizontal and/or vertical direction. This is done by giving a formula to facet_grid(), of the form vertical ~ horizontal.\n\ndat %>% \n  mutate(income = factor(income, levels = c(\"Low income\", \n                                            \"Lower middle income\",\n                                            \"Upper middle income\",\n                                            \"High income\"))) %>%\n  drop_na(\"income\") %>% \nggplot(aes(x = tests_per_capita, y = cases_per_100k)) +\n  geom_point(size = 1.5, color = \"red\", alpha = 0.4) +\n  geom_text_repel(aes(label = country), \n                  min.segment.length = 0, seed = 42, \n                  box.padding = 0.1, color = \"gray30\", \n                   segment.size = 0.2, size = 3) +\n  scale_y_continuous(trans = \"log10\") +\n  facet_grid(region~income) +\n  theme(strip.background = element_blank(),\n        strip.text.y = element_text(angle = 0))\n\n\n\n\n\n\n\nNote that the lines which come before the ggplot() function are piped %>% whereas from ggplot() onwards we have to use +. This is because ggplot2 package was written before the pipe %>% was introduced. The + sign in ggplot2 functions (similar to the pipe %>% in other functions in the tidyverse) allows code to be written from left to right adding different layers and customisations to the same plot.\nMoreover, as commands get longer, we suggest to add carriage returns (new lines), which must be inserted after the %>% or + symbols. In most cases, R is blind to white space and new lines, so this is a simple way to make our code more readable."
  },
  {
    "objectID": "visualization.html#practical-example-the-graph-everyone-wants-to-draw",
    "href": "visualization.html#practical-example-the-graph-everyone-wants-to-draw",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.14 Practical example: the graph everyone wants to draw",
    "text": "10.14 Practical example: the graph everyone wants to draw"
  },
  {
    "objectID": "visualization.html#cumulative-number-of-deaths-from-covid-19",
    "href": "visualization.html#cumulative-number-of-deaths-from-covid-19",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.15 Cumulative Number of Deaths from COVID-19",
    "text": "10.15 Cumulative Number of Deaths from COVID-19\nSeeing the total number of deaths over time, on a country-by-country basis, can illustrate how the pandemic is expanding. Because the epidemic began at different times in different countries, viewing each country’s curve from the same starting point can allow us to more easily compare countries. The starting point for this chart is the day on which the 10th death was confirmed in each country, with the trend lines following the number of days since that event.\nLet’s say we want to focus on data of specific countries:\n\nfocus_cn <- c(\"CHN\", \"GBR\", \"USA\", \"JPN\", \"GRC\", \"MEX\",\n              \"KOR\", \"ITA\", \"ESP\", \"BRA\", \"IND\")\n\nFirst, we have to prepare the data:\n\ncovid_deaths <- covid_data %>%\n  select(date, iso3c, deaths) %>%\n  group_by(iso3c) %>%\n  arrange(date) %>%\n  filter(deaths > 10) %>%\n  mutate(days_elapsed = date - min(date),\n         end_label = ifelse(date == max(date), iso3c, NA),\n         end_label = case_when(iso3c %in% focus_cn ~ end_label,\n                      TRUE ~ NA_character_),\n         cgroup = case_when(iso3c %in% focus_cn ~ iso3c,\n                   TRUE ~ \"OTHER\")) %>% \n  ungroup()\n\ncovid_deaths\n\n# A tibble: 87,842 × 6\n   date       iso3c deaths days_elapsed end_label cgroup\n   <date>     <chr>  <dbl> <drtn>       <chr>     <chr> \n 1 2020-01-22 CHN       17 0 days       <NA>      CHN   \n 2 2020-01-23 CHN       18 1 days       <NA>      CHN   \n 3 2020-01-24 CHN       26 2 days       <NA>      CHN   \n 4 2020-01-25 CHN       42 3 days       <NA>      CHN   \n 5 2020-01-26 CHN       56 4 days       <NA>      CHN   \n 6 2020-01-27 CHN       82 5 days       <NA>      CHN   \n 7 2020-01-28 CHN      131 6 days       <NA>      CHN   \n 8 2020-01-29 CHN      133 7 days       <NA>      CHN   \n 9 2020-01-30 CHN      171 8 days       <NA>      CHN   \n10 2020-01-31 CHN      213 9 days       <NA>      CHN   \n# … with 87,832 more rows\n\n\nWe also set particular colors for the selected countries:\n\n## Colors\ncgroup_cols <- c(prismatic::clr_darken(\n  paletteer_d(\"ggsci::category20_d3\"), 0.2)[1:length(focus_cn)],\n  \"gray70\")\n\nNow we are ready to create the chart with the cumulative number of confirmed deaths:\n\ndeath_curves <- covid_deaths %>% filter(cgroup != \"OTHER\") %>% \n    ggplot(mapping = aes(x = days_elapsed, y = deaths,\n                         color = cgroup, label = end_label,\n                         group = iso3c)) +\n    geom_line(size = 0.8) +\n    geom_text_repel(nudge_x = 0.2,\n                    nudge_y = 0.1, size = 3,\n                    segment.color = NA) +\n    guides(color = FALSE) +\n    scale_color_manual(values = cgroup_cols) +\n    scale_y_continuous(labels = scales::comma_format(accuracy = 1), \n                       limits = c(10, 6.1*10^5),\n                       breaks = seq(0, 6.*10^5, 10^5)) +\n    labs(x = \"Days Since 10th Confirmed Death\",\n         y = \"Cumulative Number of Deaths\",\n         title = \"Cumulative Number of Deaths from COVID-19\",\n         subtitle = paste(\"Data as of\", format(max(covid_deaths$date),\n                                               \"%d/%m/%y\")),\n         caption = \"Data: https://coronavirus.jhu.edu/map.html\")\n\ndeath_curves"
  },
  {
    "objectID": "visualization.html#cumulative-number-of-deaths-from-covid-19-in-logarithmic-scale",
    "href": "visualization.html#cumulative-number-of-deaths-from-covid-19-in-logarithmic-scale",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.16 Cumulative Number of Deaths from COVID-19 in logarithmic scale",
    "text": "10.16 Cumulative Number of Deaths from COVID-19 in logarithmic scale\nNext, we present the chart with the cumulative number of confirmed deaths in logarithmic scale:\n\ndeath_log_curves <- covid_deaths %>% filter(cgroup != \"OTHER\") %>% \n    ggplot(mapping = aes(x = days_elapsed, y = deaths,\n                         color = cgroup, label = end_label,\n                         group = iso3c)) +\n    geom_line(size = 0.8) +\n    geom_text_repel(nudge_x = 0.2,\n                    nudge_y = 0.1, size = 3,\n                    segment.color = NA) +\n    guides(color = \"none\") +\n    scale_color_manual(values = cgroup_cols) +\n    scale_y_continuous(labels = scales::comma_format(accuracy = 1),\n                       limits = c(10, 2^20),\n                       breaks = 2^seq(4, 20),\n                       trans = \"log2\") +\n    labs(x = \"Days Since 10th Confirmed Death\",\n         y = \"Cumulative Number of Deaths (log2 scale)\",\n         title = \"Cumulative Number of Deaths (log scale) from COVID-19\",\n         subtitle = paste(\"Data as of\", format(max(covid_deaths$date),\n                                               \"%d/%m/%y\")),\n         caption = \"Data: https://coronavirus.jhu.edu/map.html\")\n\ndeath_log_curves\n\n\n\n\n\n\n\nThis chart shows the cumulative number of confirmed deaths since the 10th confirmed death for each country. An upward bend in a curve can indicate either a time of explosive growth of coronavirus cases in a given country or a change in how deaths are defined or counted. Comparing across countries can also show where the pandemic is growing most rapidly at any point in time.\nLimited testing and challenges in the attribution of the cause of death means that the number of confirmed deaths may not be an accurate count of the true number of deaths from COVID-19."
  },
  {
    "objectID": "visualization.html#combine-several-plots-into-one-figure",
    "href": "visualization.html#combine-several-plots-into-one-figure",
    "title": "10  Data Visualization: ggplot2",
    "section": "\n10.17 Combine several plots into one figure",
    "text": "10.17 Combine several plots into one figure\nAssemble a number of plots\nSometimes, we would like to combine several plots into one figure. This can be easily done with the patchwork package. For example, if we want to combine two ggplot2 objects, say death_curves and death_log_curves, then we can directly call death_curves + death_log_curves to combine the two objects. Since the two plots share the same elements, patchwork allows us to use e.g. one top title, subtitle and tags by calling function plot_annotation.\n\ndeath_curves + death_log_curves +\n  plot_annotation(title = 'Cumulative Number of Deaths',\n                  subtitle = 'A: Linear scale; B: Log scale',\n                  tag_levels = 'A')\n\n\n\n\n\n\n\nInsets\nAnother approach is to use the inset_element() function which marks a plot or graphic object to be placed as an inset on the previous plot. It will thus not take up a slot in the provided layout, but share the slot with the previous plot. inset_element() allows us to freely position our inset relative to either the panel, plot, or full area of the previous plot, by specifying the location of the left, bottom, right, and top edge of the inset.\n\ndeath_curves + inset_element(death_log_curves, \n                             left =0.02, right =0.4, \n                             bottom = 0.45, top =0.98)"
  },
  {
    "objectID": "interactive.html",
    "href": "interactive.html",
    "title": "11  Animated and Interactive Plots",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "interactive.html#load-the-data",
    "href": "interactive.html#load-the-data",
    "title": "11  Animated and Interactive Plots",
    "section": "\n11.1 Load the data",
    "text": "11.1 Load the data\n\nlibrary(readr)\ncovid_data <- read_csv(\"data/covid_data.csv\", col_types = cols(date = col_date(format = \"%m/%d/%Y\")))\n\n\ndat <- covid_data %>%\n  filter(date == \"2021-06-12\", population > 1000000) %>%\n  mutate(cases_per_100k = confirmed / population * 100000,\n         tests_per_capita = total_tests / population)\n\nfocus_cn <- c(\"CHN\", \"GBR\", \"USA\", \"JPN\", \"GRC\", \"MEX\",\n              \"KOR\", \"ITA\", \"ESP\", \"BRA\", \"IND\")\n\ncovid_deaths <- covid_data %>%\n  select(date, iso3c, deaths) %>%\n  group_by(iso3c) %>%\n  arrange(date) %>%\n  filter(deaths > 10) %>%\n  mutate(days_elapsed = date - min(date),\n         end_label = ifelse(date == max(date), iso3c, NA),\n         end_label = case_when(iso3c %in% focus_cn ~ end_label,\n                      TRUE ~ NA_character_),\n         cgroup = case_when(iso3c %in% focus_cn ~ iso3c,\n                   TRUE ~ \"OTHER\")) %>% \n  ungroup()\n\n\n## Colors\ncgroup_cols <- c(prismatic::clr_darken(\n  paletteer_d(\"ggsci::category20_d3\"), 0.2)[1:length(focus_cn)],\n  \"gray70\")"
  },
  {
    "objectID": "interactive.html#animated-plot",
    "href": "interactive.html#animated-plot",
    "title": "11  Animated and Interactive Plots",
    "section": "\n11.2 Animated plot",
    "text": "11.2 Animated plot\n\nanimate1 <- covid_deaths %>% \n  filter(iso3c %in% focus_cn) %>% \n  ggplot(mapping = aes(x = date, y = deaths, group= iso3c, \n                       color = iso3c)) +\n  geom_path(size = 1) +\n  geom_point() +\n  geom_text(aes(label = iso3c), size = 5) +\n  scale_y_continuous(labels = scales::comma_format(accuracy = 1),\n                       limits = c(10, 2^20),\n                       breaks = 2^seq(4, 20),\n                       trans = \"log2\") +\n  scale_color_manual(values = cgroup_cols) +\n  labs(title = \"Date: {round(frame_along, 0)}\", \n       x = 'Calendar time', \n       y = 'Cumulative Number of Deaths (log2 scale)') +\n  theme_minimal() +\n  theme(legend.position = \"none\") +\n  transition_reveal(date) \n\nanimate1"
  },
  {
    "objectID": "interactive.html#interactive-plots-with-plotly",
    "href": "interactive.html#interactive-plots-with-plotly",
    "title": "11  Animated and Interactive Plots",
    "section": "\n11.3 Interactive plots with Plotly",
    "text": "11.3 Interactive plots with Plotly\nAny graph made with the plotly R package is powered by the JavaScript library plotly.js1. The plot_ly() function provides a ‘direct’ interface to plotly.js with some additional abstractions to help reduce typing. These abstractions, inspired by the Grammar of Graphics and ggplot2, make it much faster to iterate from one graphic to another, making it easier to discover interesting features in the data. Plotly allows the user to create high quality, interactive graphs. This includes scatter plots, histograms, heatmaps and many more! To demonstrate, we’ll use it to explore the covid_data and learn a bit how plotly works along the way.\nPlotly is an extensive package and we will merely scratch the surface of its capabilities in this course. More information about the package can be found at the website: \nA Plotly chart is created by using tree set of functions:\n\n\nplot_ly(), can be thought of as the base which allows R objects to be mapped to the Plotly library. It is similar to ggplot() function.\n\nlayout(), is used to control the chart title, axis labels, legends, canvas, range and scales.\n\nadd_trace() (add_*), creates a geometry layer called a trace which is added to the chart. It defines the type of plot similar to geometries(geom_*) in ggplot.\n\nNote that multiple traces can be added on one plot. There are many add_* functions. Running the following code provides a list of these functions:\n\nstringr::str_subset(objects(\"package:plotly\"), pattern =\"^add_\")\n\n [1] \"add_annotations\"        \"add_area\"               \"add_bars\"              \n [4] \"add_boxplot\"            \"add_choropleth\"         \"add_contour\"           \n [7] \"add_data\"               \"add_fun\"                \"add_heatmap\"           \n[10] \"add_histogram\"          \"add_histogram2d\"        \"add_histogram2dcontour\"\n[13] \"add_image\"              \"add_lines\"              \"add_markers\"           \n[16] \"add_mesh\"               \"add_paths\"              \"add_pie\"               \n[19] \"add_polygons\"           \"add_ribbons\"            \"add_scattergeo\"        \n[22] \"add_segments\"           \"add_sf\"                 \"add_surface\"           \n[25] \"add_table\"              \"add_text\"               \"add_trace\"             \n\n\nLet’s see an example of a simple interactive plot:\n\nplotly1 <- dat %>% \n  plot_ly(x = ~gdp_capita, y = ~life_expectancy, \n          color = ~region)\n\nplotly1\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\nWarning: Ignoring 2 observations\n\n\n\n\n\n\nAlthough we did not specify the plot type, the produced chart is a scatter plot. The plot_ly() function is the base plotly command to initialize a plot from a dataframe, similar to ggplot() from ggplot2. Therefore, we observe that if we assign variable names (e.g., gdp_capita, life_expectancy, region, etc.) to visual properties (e.g., x, y, color, etc.) within plot_ly(), it tries to find a sensible geometric representation of that information for us.\nAnalytically, the type of plot is specified by setting the trace type. The scatter trace type is the foundation for many low-level geometries (e.g., points, lines, and text), thus we must also specify a mode. To create a scatter plot with points the mode is set to markers, but additional scatter modes include lines, paths, segments, ribbons, polygons, and text.\nThe plot’s interactivity can be accessed via its tool bar. The functionality provided by this toolbar from left to right are as follows:\n\nDownloading the plot as a png file.\nZooming in specific areas of the plot\nPanning across the map.\nSelecting all points using a box.\nSelecting all points using a lasso.\nZooming in and out on\n\nMoreover, hovering over individual points displays their coordinates.\nPlotly functions take a plotly object as an input and return a modified plotly object, making it work perfectly with the pipe operator (%>%). Note that plot_ly() uses a ~ syntax for mapping aesthetics that is a bit different from the ggplot() syntax we’ve presented earlier.\nWe can explicitly define the type and mode of the plot using the add_trace(). Additionally, we can change the palette of colors and use the layout function to set title and axis labels. For the axis labels we use the xaxis and yaxis arguments which require lists:\n\nplotly2 <- dat %>% \n  plot_ly(x = ~gdp_capita, y = ~life_expectancy, \n          color=~region) %>% \n  add_trace(type = \"scatter\", mode = \"markers\", colors = \"Set1\") %>% \n  layout(title = \"Life expectancy vs. GDP per capita\",\n         xaxis = list(\n           title = \"GDP per capita ($)\"),\n         yaxis = list(\n           title = \"Life expectancy (years)\")\n         )\n\nplotly2\n\n\n\n\n\nRather than using add_trace() and specifying the type and mode, we can use the convenience function add_markers() and change the “filled” circles with “open” circles. Note that if we want to use a constant value for an aesthetic (e.g., symbol), we must specify that the argument should be used “as-is,” using the I() function. Another important attribute that can be added is the name of the country using the text argument in the plot_ly().\n\nplotly3 <- dat %>%\n  plot_ly(x = ~gdp_capita, y = ~life_expectancy, \n          color=~region,\n          text = ~country) %>% \n  add_markers(symbol = I(\"circle-open\"), colors = \"Set1\") %>% \n  layout(title = \"Life expectancy vs. GDP per capita\",\n         xaxis = list(\n           title = \"GDP per capita ($)\"),\n         yaxis = list(\n           title = \"Life expectancy (years)\")\n         )\n\nplotly3\n\n\n\n\n\nMaking other plot types is similarly easy by using the corresponding add_*() function.\nWe can also create 3D interactive plots using the scatter3d type as follows:\n\nplotly4 <- dat %>%\n  plot_ly(x = ~gdp_capita, y = ~life_expectancy, \n          z= ~tests_per_capita, color=~region, \n          text = ~ country, size = I(200)) %>%\n  add_trace(type = \"scatter3d\", mode = \"markers\", \n            symbol = I(\"circle-open\"), colors = \"Set1\") %>%\n  layout(scene = list(\n    xaxis = list(\n      title = \"x:GDP per capita ($)\"),\n    yaxis = list(\n      title = \"y:Life expectancy (years)\"),\n    zaxis = list(\n      title = \"z:Tests per capita\")\n  ))\n\nplotly4\n\n\n\n\n\nWe can use the paste() function to create a more customized text label. Use HTML tags for any formatting. For example, to show both the variables in a more attractive format, we could run:\n\nplotly5 <- dat %>%\n  plot_ly(x = ~gdp_capita, y = ~life_expectancy, \n          z= ~tests_per_capita, color=~region, \n          size = I(200)) %>%\n  add_trace(type = \"scatter3d\", mode = \"markers\", \n            symbol = I(\"circle-open\"), colors = \"Set1\",\n            text = ~ paste(\"<b>Country:</b> \", country, \"<br />\",\n\"<b>GDP per capita ($):</b> \", round(gdp_capita, digits=1),\"<br />\",\n\"<b>Life expectancy (yrs):</b> \", round(life_expectancy, digits=1),\"<br />\",\n\"<b>No. health measures:</b> \", tests_per_capita                   \n                           ), hoverinfo = \"text\") %>%\n  layout(scene = list(\n    xaxis = list(\n      title = \"x:GDP per capita ($)\"),\n    yaxis = list(\n      title = \"y:Life expectancy (years)\"),\n    zaxis = list(\n      title = \"z:Tests per capita\")\n  ))\n\nplotly5"
  },
  {
    "objectID": "interactive.html#integration-plotly-with-ggplot2-ggplotly",
    "href": "interactive.html#integration-plotly-with-ggplot2-ggplotly",
    "title": "11  Animated and Interactive Plots",
    "section": "\n11.4 Integration plotly with ggplot2: ggplotly()\n",
    "text": "11.4 Integration plotly with ggplot2: ggplotly()\n\nA ggplot object can be transformed into an interactive plot by calling the function ggplotly().\n\ng_plot <- ggplot(dat, aes(x = gdp_capita, y = life_expectancy)) +\n  geom_point(aes(color = region)) +\n  geom_text(aes(label = country)) +\nlabs(title = \"Life expectancy vs. GDP per capita\",\n         xaxis = list(\n           title = \"GDP per capita ($)\"),\n         yaxis = list(\n           title = \"Life expectancy (years)\")\n         )\n\nggplotly(g_plot)"
  },
  {
    "objectID": "sql.html",
    "href": "sql.html",
    "title": "12  SQL",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "sql.html#introduction-to-relational-databases",
    "href": "sql.html#introduction-to-relational-databases",
    "title": "12  SQL",
    "section": "\n12.1 Introduction to relational databases",
    "text": "12.1 Introduction to relational databases\nSo far, we have dealt with datasets that easily fit into our computer’s memory. But what about datasets that are too large for our computer to handle as a whole? In this case, storing the data outside of R and organizing it in a database is helpful. Connecting to the database allows us to retrieve only the chunks needed for the current analysis.\nA very common form of data storage is the relational database. There are many relational database management systems (RDBMS), such as SQLite, MySQL, PostgreSQL, Oracle, and many more. These different RDBMS each have their own advantages and limitations. Almost all employ SQL (structured query language) to pull data from the database.\nThankfully, several packages have been written that allows R to connect to relational databases and use the R programming language as the front end (what the user types in) to pull data from them. In this tutorial, we will give examples of how to read and analyzed data using R with SQLite RDBMS.\nData from the Portal Project\nThe Portal Project is a long-term ecological study being conducted near Portal, AZ. Since 1977, the site has been a primary focus of research on interactions among rodents, ants and plants and their respective responses to climate.\nData from the Portal project is recorded in a relational database designed for reliable storage and rapid access to the bounty of information produced by this long-term ecological experiment.\nThe research site consists of many plots – patches of the Arizona desert that are intensively manipulated and repeatedly surveyed. The plots have some fixed characteristics, such as the type of manipulation, geographic location, aspect, etc.\nThe plots have a lot of dynamic characteristics, and those changes are recorded in repeated surveys. In particular, the animals captured during each survey are identified to species, weighed, and measured.\nThere is also the portalr R package that provides a collection of basic functions to summarize the Portal project data on rodents, plants, ants, and weather at our long-term field site in the Chihuahuan Desert."
  },
  {
    "objectID": "sql.html#basic-definitions-in-sql",
    "href": "sql.html#basic-definitions-in-sql",
    "title": "12  SQL",
    "section": "\n12.2 Basic definitions in SQL",
    "text": "12.2 Basic definitions in SQL\nDatabase: a container/repository (usually a file or set of files) to store organized data; a set of relational information.\nTables: the information inside the database is organized in tables; a structured list of data\nDatabase terminology builds on common ways of characterizing data files. The breakdown of a table into records (also named rows) or fields (also named columns, or variables) is familiar to anyone who’s worked in spreadsheets. The descriptions below formalize these terms, and provide an example referencing the Portal mammals database."
  },
  {
    "objectID": "sql.html#types-of-sql-statements-ddl-vs.-dml",
    "href": "sql.html#types-of-sql-statements-ddl-vs.-dml",
    "title": "12  SQL",
    "section": "\n12.3 Types of SQL statements (DDL vs. DML)",
    "text": "12.3 Types of SQL statements (DDL vs. DML)\nSQL statements fall into two different categories: Data Definition Language statements and Data Manipulation Language statements.\nData Definition Language (or DDL) statements are used to define, change, or drop database objects such as tables.\n Common DDL statement types include CREATE, ALTER, TRUNCATE, and DROP:\nCREATE statement: which is used for creating tables and defining its columns;\nALTER statement: is used for altering tables including adding and dropping columns and modifying their datatypes;\nTRUNCATE statement: is used for deleting data in a table but not the table itself;\nDROP statement: is used for deleting tables.\nData Manipulation Language (or DML) statements are used to read and modify data in tables. These are also sometimes referred to as CRUD operations, that is, Create, Read, Update and Delete rows in a table.\n Common DML statement types include INSERT, SELECT, UPDATE, and DELETE:\nINSERT statement: is used for inserting a row or several rows of data into a table;\nSELECT statement: reads or selects column/row or columns/rows from a table;\nUPDATE statement: edits row or rows in a table;\nDELETE statement: removes a row or rows of data from a table.\nIn these notes we will primarly use the SELECT statement."
  },
  {
    "objectID": "sql.html#connecting-to-a-database",
    "href": "sql.html#connecting-to-a-database",
    "title": "12  SQL",
    "section": "\n12.4 Connecting to a database",
    "text": "12.4 Connecting to a database\nThe first step from RStudio is creating a connection object that opens up a channel of communication to the database file. We will connect to our database using the DBI package. For the sake of example, we simply connect to an “in-memory” database, but a wide range of database connectors are available depending on where our data lives.\n\n# connect to the database\nmammals <- DBI::dbConnect(RSQLite::SQLite(),\n                          here(\"data\", \"portal_mammals.sqlite\"))\n\nThis command uses 2 packages that helps dbplyr and dplyr talk to the SQLite database. DBI is not something that we’ll use directly as a user. It allows R to send commands to databases irrespective of the database management system used. The RSQLite allows R to interface with SQLite databases.\nThis command does not load the data into the R session (as the read_csv() function does). Instead, it merely instructs R to connect to the SQLite database contained in the portal_mammals.sqlite file.\nUsing a similar approach, we could connect to many other database management systems that are supported by R including MySQL, PostgreSQL, etc."
  },
  {
    "objectID": "sql.html#explore-the-database",
    "href": "sql.html#explore-the-database",
    "title": "12  SQL",
    "section": "\n12.5 Explore the database",
    "text": "12.5 Explore the database\nWith the connection object availble, we can begin exploring the database.\nFirst, we can list the tables at the connection:\n\n# mammals SQLite database can contain multiple tables (datasets)\ndbListTables(mammals)\n\n[1] \"plots\"   \"species\" \"surveys\"\n\n\nor, alternately using the src_dbi() from {dbplyr}:\n\nsrc_dbi(mammals)\n\nsrc:  sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\ntbls: plots, species, surveys\n\n\nJust like a spreadsheet with multiple worksheets, a SQLite database can contain multiple tables. In this case three of them are listed in the tbls row in the output above:\nThe three key tables in the relational database are:\n\nplots\nsurveys\nspecies\n\nNow, we’re done with set-up. Let’s explore the fields (variables) contained in a particular table:\n\n# List the fields (variables) in a particular table\ndbListFields(mammals, \"plots\")\n\n[1] \"plot_id\"   \"plot_type\"\n\ndbListFields(mammals, \"surveys\")\n\n[1] \"record_id\"       \"month\"           \"day\"             \"year\"           \n[5] \"plot_id\"         \"species_id\"      \"sex\"             \"hindfoot_length\"\n[9] \"weight\"         \n\ndbListFields(mammals, \"species\")\n\n[1] \"species_id\" \"genus\"      \"species\"    \"taxa\""
  },
  {
    "objectID": "sql.html#simple-database-queries-with-sql-syntax-select-statements",
    "href": "sql.html#simple-database-queries-with-sql-syntax-select-statements",
    "title": "12  SQL",
    "section": "\n12.6 Simple database queries with SQL syntax (SELECT statements)",
    "text": "12.6 Simple database queries with SQL syntax (SELECT statements)\nSELECT command (select columns)\nTo connect to tables within a database, you can use the tbl() function from dplyr. This function can be used to send SQL queries to the database if it is combined with the sql() function. To demonstrate this functionality, let’s select the columns record_id, year, species_id, and plot_id from the surveys table:\n\n## SELECT statement\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         3  1977 DM               2\n4         4  1977 DM               7\n5         5  1977 DM               3\n6         6  1977 PF               1\n\n\nAlthough it looks like we just got a data frame from the database, we didn’t! It’s a reference, showing us data that is still in the SQLite database (note the first two lines of the output). It does this because databases are often more efficient at selecting, filtering and joining large data sets than R. And typically, the database will not even be stored on our computer, but rather a more powerful machine somewhere on the web. So R is lazy and waits to bring this data into memory until we explicitly tell it to do so using the collect function from the dbplyr package.\nNote that SQL is case insensitive, so capitalization only helps for readability and is a good style to adopt.\nAlternatively, we can use dbGetQuery() function from {DBI} to pass SQL code to the database file:\n\ndbGetQuery(mammals, \n           \"SELECT record_id, year, species_id, plot_id \n           FROM surveys\") %>% \n  head()\n\n  record_id year species_id plot_id\n1         1 1977         NL       2\n2         2 1977         NL       3\n3         3 1977         DM       2\n4         4 1977         DM       7\n5         5 1977         DM       3\n6         6 1977         PF       1\n\n\nNote that the same operation can be done using dplyr’s verbs instead of writing SQL. First, we select the table on which to do the operations by creating the surveys object, and then we use the standard dplyr syntax as if it were a data frame:\n\nsurveys <- tbl(mammals, \"surveys\")\nquery1 <- surveys %>%\n  select(year, species_id, plot_id) %>% \n  head()\n\nAdditionally, we can use dplyr’s show_query() function to show which SQL commands are actually sent to the database:\n\nshow_query(query1)\n\n<SQL>\nSELECT `year`, `species_id`, `plot_id`\nFROM `surveys`\nLIMIT 6\n\n\nWHERE clause (filtering rows)\nRelational operation helps us in restricting the result set by allowing us to use the clause WHERE. The WHERE clause always requires a predicate. A predicate is conditioned evaluates to true, false or unknown. Predicates are used in the search condition of the WHERE clause.\nSo, if we need to select the rows from the surveys table where the species_id is DM (Dipodomys), we use the WHERE clause with the predicate species_id equals DM. The result set is now restricted to rows whose condition evaluates to true.\n\n## Filtering with WHERE statement and using basic operators\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id = 'DM'\")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         3  1977 DM               2\n2         4  1977 DM               7\n3         5  1977 DM               3\n4         8  1977 DM               1\n5         9  1977 DM               1\n6        12  1977 DM               7\n\n\nAdditionally, using BETWEEN-AND comparison operator we can filter a range of values:\n\n# BETWEEN ... AND ....  operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE plot_id BETWEEN 3 AND 5\")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         2  1977 NL               3\n2         5  1977 DM               3\n3        11  1977 DS               5\n4        13  1977 DM               3\n5        16  1977 DM               4\n6        17  1977 DS               3\n\n\nWe can also find the missing values NA for a specific field:\n\n# IS NULL operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id IS NULL\")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1       324  1977 <NA>             7\n2       325  1977 <NA>            10\n3       326  1977 <NA>            23\n4       401  1977 <NA>             3\n5       402  1977 <NA>            15\n6       403  1977 <NA>            19\n\n\nOther operators is IN that we can use for searching specific values:\n\n# IN operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE plot_id IN (1, 2, 7)\")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         1  1977 NL               2\n2         3  1977 DM               2\n3         4  1977 DM               7\n4         6  1977 PF               1\n5         7  1977 PE               2\n6         8  1977 DM               1\n\n\nand OR operator\n\n# OR operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id = 'NL' OR species_id = 'PF' \")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         6  1977 PF               1\n4        10  1977 PF               6\n5        19  1977 PF               4\n6        22  1977 NL              15\n\n\nWe can also combine OR and AND operators:\n\n# OR with AND (NOTE: use parenthesis, SQL processes AND before OR)\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE (plot_id = 2 OR plot_id = 7) AND species_id = 'DM' \")) %>% \nhead()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         3  1977 DM               2\n2         4  1977 DM               7\n3        12  1977 DM               7\n4        64  1977 DM               7\n5        67  1977 DM               7\n6        71  1977 DM               7\n\n\nAnother operator is NOT that excludes the records with a specific value:\n\n# NOT operator (exclude records/rows)\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE NOT species_id = 'PF' AND NOT species_id = 'DM' \")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         7  1977 PE               2\n4        11  1977 DS               5\n5        17  1977 DS               3\n6        18  1977 PP               2\n\n\nAdditional useful expressions, COUNT and LIMIT\n\nNext, we’ll briefly present a few additional useful expressions that are used with select statements.\nThe first one is COUNT that is a built-in database function that retrieves the number of rows that match the query criteria.\n\n## COUNT species_id = 'DM'\ntbl(mammals, sql(\"SELECT COUNT (species_id)\n                 FROM surveys\n                 WHERE species_id = 'DM'\"))\n\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  `COUNT (species_id)`\n                 <int>\n1                10596\n\n\nThe second expression is LIMIT that is used for restricting the number of rows retrieved from the database. For example, we can retrieve just the first 10 rows from surveys table.\n\n## LIMIT (just a few rows)\ntbl(mammals, sql(\"SELECT *\n                 FROM surveys\n                 LIMIT 10 \"))\n\n# Source:   SQL [10 x 9]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <int> <int> <int> <int>   <int> <chr>      <chr>           <int>  <int>\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n\n\nNote that if we use the asterisk in the SELECT, we request all columns of the table (instead of column names).\nWe can also retrieve just a few rows in the surveys table for a particular year such as 1985.\n\n## WHERE and LIMIT (just a few rows for a particular year)\ntbl(mammals, sql(\"SELECT *\n                 FROM surveys\n                 WHERE year = 1985 LIMIT 10 \"))\n\n# Source:   SQL [10 x 9]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <int> <int> <int> <int>   <int> <chr>      <chr>           <int>  <int>\n 1      9790     1    19  1985      16 RM         F                  16      4\n 2      9791     1    19  1985      17 OT         F                  20     16\n 3      9792     1    19  1985       6 DO         M                  35     48\n 4      9793     1    19  1985      12 DO         F                  35     40\n 5      9794     1    19  1985      24 RM         M                  16      4\n 6      9795     1    19  1985      12 DO         M                  34     48\n 7      9796     1    19  1985       6 DM         F                  37     35\n 8      9797     1    19  1985      14 DM         M                  36     45\n 9      9798     1    19  1985       6 DM         F                  36     38\n10      9799     1    19  1985      19 RM         M                  16      4\n\n\nSorting results sets with ORDER BY clause\n\n## ORDER BY species_id\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 ORDER BY species_id DESC\")) %>% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      <int> <int> <chr>        <int>\n1     14250  1988 ZL              18\n2     14351  1988 ZL              23\n3     35512  2002 US              11\n4     35513  2002 US              11\n5     35528  2002 US              13\n6     35544  2002 US              15\n\n\nOf note, the ORDER BY clause must be always the last in a select statement.\nGrouping Result Sets, GROUP BY\n\n\n## Just COUNT sex\ntbl(mammals, sql(\"SELECT COUNT (sex)\n                 FROM surveys\n                 \"))\n\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  `COUNT (sex)`\n          <int>\n1         33038\n\n\n\n## COUNT BY GROUP\ntbl(mammals, sql(\"SELECT sex, COUNT(sex)\n                 AS count FROM surveys GROUP BY sex\n                 \"))\n\n# Source:   SQL [3 x 2]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  sex   count\n  <chr> <int>\n1 <NA>      0\n2 F     15690\n3 M     17348\n\n\n\n## COUNT BY GROUP and use HAVING clause for selection \ntbl(mammals, sql(\"SELECT sex, COUNT(sex)\n                 AS count FROM surveys GROUP BY sex\n                 HAVING COUNT(sex) > 16000\"))\n\n# Source:   SQL [1 x 2]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  sex   count\n  <chr> <int>\n1 M     17348\n\n\nWildcards (using with string paterns) with LIKE predicate\n\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\"))\n\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   species_id genus            taxa   \n   <chr>      <chr>            <chr>  \n 1 AB         Amphispiza       Bird   \n 2 AH         Ammospermophilus Rodent \n 3 AS         Ammodramus       Bird   \n 4 BA         Baiomys          Rodent \n 5 CB         Campylorhynchus  Bird   \n 6 CM         Calamospiza      Bird   \n 7 CQ         Callipepla       Bird   \n 8 CS         Crotalus         Reptile\n 9 CT         Cnemidophorus    Reptile\n10 CU         Cnemidophorus    Reptile\n# … with more rows\n\n\n\n## grabs anything ending with letters 'za' \ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE '%za' \"))\n\n# Source:   SQL [2 x 3]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus       taxa \n  <chr>      <chr>       <chr>\n1 AB         Amphispiza  Bird \n2 CM         Calamospiza Bird \n\n\n\n## grabs anything that starts with the letter 'A'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'A%' \"))\n\n# Source:   SQL [3 x 3]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus            taxa  \n  <chr>      <chr>            <chr> \n1 AB         Amphispiza       Bird  \n2 AH         Ammospermophilus Rodent\n3 AS         Ammodramus       Bird  \n\n\n\n## grabs anything before and after the letters 'sp'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE '%sp%' \"))\n\n# Source:   SQL [7 x 3]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus            taxa  \n  <chr>      <chr>            <chr> \n1 AB         Amphispiza       Bird  \n2 AH         Ammospermophilus Rodent\n3 CM         Calamospiza      Bird  \n4 SB         Spizella         Bird  \n5 SS         Spermophilus     Rodent\n6 ST         Spermophilus     Rodent\n7 US         Sparrow          Bird  \n\n\n\n## grabs anything that starts with 'c' and ends with 'us'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'c%us' \"))\n\n# Source:   SQL [9 x 3]\n# Database: sqlite 3.39.4 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus           taxa   \n  <chr>      <chr>           <chr>  \n1 CB         Campylorhynchus Bird   \n2 CS         Crotalus        Reptile\n3 CT         Cnemidophorus   Reptile\n4 CU         Cnemidophorus   Reptile\n5 CV         Crotalus        Reptile\n6 PB         Chaetodipus     Rodent \n7 PI         Chaetodipus     Rodent \n8 PP         Chaetodipus     Rodent \n9 PX         Chaetodipus     Rodent"
  },
  {
    "objectID": "sql.html#close-the-connection",
    "href": "sql.html#close-the-connection",
    "title": "12  SQL",
    "section": "\n12.7 Close the connection",
    "text": "12.7 Close the connection\nGood housekeeping means always remembering to disconnect once you’re done.\n\ndbDisconnect(mammals) # closes our DB connection"
  }
]