[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to R",
    "section": "",
    "text": "Preface\nThis is a working draft.\nThis online textbook is based on notes from a series of lectures given for a few years at the Aristotle University of Thessaloniki in the Laboratory of Hygiene, Social-Preventive Medicine & Medical Statistics.\nThis textbook can be used as support material for lectures on R at any level from beginner to advanced. We have paid particular attention to the form of the book, which we think should aid understanding. It can also be used as a support for self-teaching.\nAll sections of this textbook are reproducible as they were made using Quarto® which is an open-source scientific and technical publishing system built on Pandoc.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "An Introduction to R",
    "section": "License",
    "text": "License\nThis textbook is free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "list.html#creating-a-list",
    "href": "list.html#creating-a-list",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.1 Creating a list",
    "text": "1.1 Creating a list\nA list in R allows us to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related to each other in any way. We could say that a list is some kind super data type: we can store practically any piece of information in it!\nWe construct a list using the list() function. The list items (or components of a list) can be matrices, vectors, other lists. For example:\n\nmy_list &lt;- list(1:5, c(\"apple\", \"orange\"), TRUE)\nmy_list\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"apple\"  \"orange\"\n\n[[3]]\n[1] TRUE\n\n\nThis list consists of three components that are atomic vectors of different types of data (numeric, characters, and logical).\nWe can assign names to the list items:\n\nmy_list &lt;- list(\n              numbers = 1:5, \n              strings = c(\"apple\", \"orange\"), \n              logicals = TRUE)\nmy_list\n\n$numbers\n[1] 1 2 3 4 5\n\n$strings\n[1] \"apple\"  \"orange\"\n\n$logicals\n[1] TRUE\n\n\nWe can also confirm that the class of the object is list:\n\nclass(my_list)\n\n[1] \"list\""
  },
  {
    "objectID": "list.html#subsetting-a-list",
    "href": "list.html#subsetting-a-list",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.2 Subsetting a list",
    "text": "1.2 Subsetting a list\nSubset list and preserve output as a list\nWe can use the [ ] operator to extract one or more list items while preserving the output in list format:\n\nmy_list[1]    # extract the first list item\n\n$numbers\n[1] 1 2 3 4 5\n\nclass(my_list[1])\n\n[1] \"list\"\n\n\n \nSubset list and simplify the output\nWe can use the [[ ]] to extract one or more list items while simplifying the output:\n\nmy_list[[1]]   # extract the first list item and simplify it to a vector\n\n[1] 1 2 3 4 5\n\nclass(my_list[[1]])\n\n[1] \"integer\"\n\nmy_list[[\"numbers\"]]   # same as above but using the item's name\n\n[1] 1 2 3 4 5\n\n\nWe can also access the content of the list by typing the name of the list followed by a dollar sign $ folowed by the name of the list item:\n\nmy_list$numbers  # extract the numbers and simplify to a vector\n\n[1] 1 2 3 4 5\n\n\nOne thing that differentiates the [[ operator from the $ is that the [[ operator can be used with computed indices and names. The $ operator can only be used with names.\n\n\n\n\n\n\nSimplifying Vs Preserving subsetting\n\n\n\nIt’s important to understand the difference between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output. Preserving subsets keeps the structure of the output the same as the input.\n\n\n \nSubset list to get individual elements out of a list item\nTo extract individual elements out of a specific list item combine the [[ (or $) operator with the [ operator:\n\nmy_list[[2]][2]          # using the index\n\n[1] \"orange\"\n\nmy_list[[\"strings\"]][2]  # using the name of the list item\n\n[1] \"orange\"\n\nmy_list$strings[2]       # using the $\n\n[1] \"orange\""
  },
  {
    "objectID": "list.html#recursive-vectors-and-nested-lists",
    "href": "list.html#recursive-vectors-and-nested-lists",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.3 Recursive vectors and Nested Lists",
    "text": "1.3 Recursive vectors and Nested Lists\nA recursive vector is a list that contains other lists. The sublists of a recursive vector are known as nested lists. For example:\n\nmy_list2 &lt;- list(item1 = 3.14,\n            item2 = list(item2a_num = 5:10,\n                         item2b_char = c(\"a\",\"b\",\"c\")))\n\nmy_list2\n\n$item1\n[1] 3.14\n\n$item2\n$item2$item2a_num\n[1]  5  6  7  8  9 10\n\n$item2$item2b_char\n[1] \"a\" \"b\" \"c\"\n\n\n \nSubsetting a nested list\nWe can access list items of a nested list by using the combination of [[ ]] or $ operator and the [ ] operator. For example:\n\n# preserve the output as a list\nmy_list2[[2]][1]\n\n$item2a_num\n[1]  5  6  7  8  9 10\n\nclass(my_list2[[2]][1])\n\n[1] \"list\"\n\n# same as above but simplify the output\nmy_list2[[2]][[1]]\n\n[1]  5  6  7  8  9 10\n\nclass(my_list2[[2]][[1]])\n\n[1] \"integer\"\n\n# same as above with names\nmy_list2[[\"item2\"]][[\"item2a_num\"]]\n\n[1]  5  6  7  8  9 10\n\n# same as above with $ operator\nmy_list2$item2$item2a_num\n\n[1]  5  6  7  8  9 10\n\n\n \nWe can also extract individual elements from the list items of a nested list. For example:\n\n# extract individual element\nmy_list2[[2]][[2]][3]\n\n[1] \"c\"\n\nclass(my_list2[[2]][[2]][3])\n\n[1] \"character\""
  },
  {
    "objectID": "list.html#unlist-a-list",
    "href": "list.html#unlist-a-list",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.4 Unlist a list",
    "text": "1.4 Unlist a list\nWe can turn a list into an atomic vector with unlist():\n\nmy_unlist &lt;- unlist(my_list)\nmy_unlist\n\nnumbers1 numbers2 numbers3 numbers4 numbers5 strings1 strings2 logicals \n     \"1\"      \"2\"      \"3\"      \"4\"      \"5\"  \"apple\" \"orange\"   \"TRUE\" \n\nclass(my_unlist)\n\n[1] \"character\""
  },
  {
    "objectID": "list.html#data-frames",
    "href": "list.html#data-frames",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.5 Data frames",
    "text": "1.5 Data frames\nA data frame is the most common way of storing data in R and, generally, is the data structure most often used for data analyses.\n\n\n\n\n\n\nData frame\n\n\n\nA data frame is a special type of list with equal-length atomic vectors. Each component of the list can be thought of as a column and the length of each component of the list is the number of rows.\n\n\n \nBasic characteristics of data frames\n\nEach column of a data frame is an atomic vector and remember that the data in an atomic vector must only be of one type (numeric, character, or logical).\n\nData frames are similar to the datasets we’d typically see in spreadsheets (e.g., Excell files, Google sheets, LibreOffice Calc).\n\nData frames are the most common data structure we’ll deal with in R. A data frame can be created with the data.frame() function in base R, the tibble() function in the tidyverse package (an improvement over data.frame), or the “fast” data.table() in the data.table package.\n\nDifferent traditions have different names for the rows and columns of a dataset. Statisticians refer to them as observations and variables, database analysts call them records and fields, and those from the data mining/machine learning disciplines call them examples and attributes. We’ll use the terms observations and variables throughout this textbook.\nThe two basic variable categories are the categorical and numerical variables.\n \nCreating a data frame with tibble()\n\nWe can create a data frame from column vectors with the tibble() function from tibble package which belongs to the “tidyverse” family of packages. A tibble is a specific kind of data frame and is short for “tidy table”.\nIn order to use the tidyverse packages, our input data frames must be in “tidy” format (long/narrow format). In tidy data there are three interrelated rules:\n\nEach variable must have its own column.\nEach observation must have its own row.\nEach value must have its own cell.\n\n\n\n\n\nFigure 1.1: Tidy data.\n\n\n\nHere, we provide a simple example of patient dataset:\n\nlibrary(tidyverse)   # load the tidyverse package\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\n\nWarning: package 'purrr' was built under R version 4.3.1\n\n\nWarning: package 'dplyr' was built under R version 4.3.1\n\nlibrary(lubridate)   # load the lubridate package\n\npatient_data &lt;- tibble(\npatientID = c(1, 2, 3, 4, 5, 6, 7, 8),\nage = c(25, 30, 28, 22, 31, 45, 37, 43),\nweight = c(94, 83, 71, 87, 94, 73, 89, 74),\ndiabetes = c(\"Type 1\", \"Type 2\", \"Type 1\", \"Type 1\", \n              \"Type 2\", \"Type 1\", \"Type 1\", \"Type 2\"),\nstatus = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\", \n            \"Poor\",\"Excellent\", \"Improved\", \"Improved\"),\ndates = ymd(\"2020-10-09\", \"2020-10-12\", \"2020-10-18\", \"2020-10-27\",\n           \"2020-11-04\", \"2020-11-09\", \"2020-11-22\", \"2020-12-02\"))\npatient_data\n\n# A tibble: 8 × 6\n  patientID   age weight diabetes status    dates     \n      &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;     &lt;date&gt;    \n1         1    25     94 Type 1   Poor      2020-10-09\n2         2    30     83 Type 2   Improved  2020-10-12\n3         3    28     71 Type 1   Excellent 2020-10-18\n4         4    22     87 Type 1   Poor      2020-10-27\n5         5    31     94 Type 2   Poor      2020-11-04\n6         6    45     73 Type 1   Excellent 2020-11-09\n7         7    37     89 Type 1   Improved  2020-11-22\n8         8    43     74 Type 2   Improved  2020-12-02\n\n\nIn this data frame, patientID is a row or case identifier, age (in years) and weight (in kg) are continuous variables, diabetes (Type 1, Type 2) is a nominal (dichotomous) variable, status is an ordinal variable (Poor/Improved/Excellent), and dates variable with dates (note that we used the ymd() function to create this variable).\nWe might have noticed the row of three (or four) letter abbreviations under the column names. These describe the type of each variable:\n\ndbl stands for doubles, or real numbers.\nchr stands for character vectors, or strings.\ndate stands for dates.\n\nThere are some other common types of variables that aren’t used in this dataset:\n\nint stands for integers.\nlgl stands for logical, vectors that contain only TRUE or FALSE.\nfct stands for factors, which R uses to represent categorical variables with fixed possible values.\ndttm stands for date-times (a date + a time).\n\nOften we use the glimpse() function in order to have a quick look at the structure of the data frame:\n\nglimpse(patient_data)\n\nRows: 8\nColumns: 6\n$ patientID &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8\n$ age       &lt;dbl&gt; 25, 30, 28, 22, 31, 45, 37, 43\n$ weight    &lt;dbl&gt; 94, 83, 71, 87, 94, 73, 89, 74\n$ diabetes  &lt;chr&gt; \"Type 1\", \"Type 2\", \"Type 1\", \"Type 1\", \"Type 2\", \"Type 1\", …\n$ status    &lt;chr&gt; \"Poor\", \"Improved\", \"Excellent\", \"Poor\", \"Poor\", \"Excellent\"…\n$ dates     &lt;date&gt; 2020-10-09, 2020-10-12, 2020-10-18, 2020-10-27, 2020-11-04, …\n\n\nWe can also find the type, class and dim for the data frame:\n\ntypeof(patient_data)\n\n[1] \"list\"\n\nclass(patient_data)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\ndim(patient_data)\n\n[1] 8 6\n\n\nThe type is a list but the class is a tbl (tibble) object which is a “tidy” data frame (tibbles work better in the tidyverse). The dimensions are 8x6.\nThe attribute() function help us to explore the characteristics/attributives of the tibbles:\n\nattributes(patient_data)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5 6 7 8\n\n$names\n[1] \"patientID\" \"age\"       \"weight\"    \"diabetes\"  \"status\"    \"dates\"    \n\n\n \nAccess only one variable at a time from a tibble\nTo access the variable age, we can use the dollar sign ($) like this:\n\npatient_data$age\n\n[1] 25 30 28 22 31 45 37 43\n\n\nFor example, if we want to cross tabulate diabetes type by status, we could use the following code:\n\ntable(patient_data$diabetes, patient_data$status)\n\n        \n         Excellent Improved Poor\n  Type 1         2        1    2\n  Type 2         0        2    1\n\n\n\n\n\n\n\n\nTable\n\n\n\nThe table() function builds a contingency table of the counts at each combination of levels of the variables."
  },
  {
    "objectID": "list.html#access-variables-using-the-with-function",
    "href": "list.html#access-variables-using-the-with-function",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.6 Access variables using the with() function",
    "text": "1.6 Access variables using the with() function\nIt can get tiresome typing patient_data$ at the beginning of every variable name. An alternative approach is to use with() function. For example:\n\nwith(patient_data, table(diabetes, status))\n\n        status\ndiabetes Excellent Improved Poor\n  Type 1         2        1    2\n  Type 2         0        2    1"
  },
  {
    "objectID": "list.html#factors",
    "href": "list.html#factors",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.7 Factors",
    "text": "1.7 Factors\nCategorical (nominal) and ordered categorical (ordinal) variables in R are usually transformed to factors. Factors can contain only predefined values and are crucial in R because they determine how data will be analyzed in statistical models and presented visually.\nIn our example, we should convert the diabetes and status variables from character to factor variables. This can be done by applying the convert_as_factor() function from the rstatix package:\n\n# convert from character to factor\npatient_data &lt;- rstatix::convert_as_factor(patient_data, diabetes, status)\npatient_data\n\n# A tibble: 8 × 6\n  patientID   age weight diabetes status    dates     \n      &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;fct&gt;    &lt;fct&gt;     &lt;date&gt;    \n1         1    25     94 Type 1   Poor      2020-10-09\n2         2    30     83 Type 2   Improved  2020-10-12\n3         3    28     71 Type 1   Excellent 2020-10-18\n4         4    22     87 Type 1   Poor      2020-10-27\n5         5    31     94 Type 2   Poor      2020-11-04\n6         6    45     73 Type 1   Excellent 2020-11-09\n7         7    37     89 Type 1   Improved  2020-11-22\n8         8    43     74 Type 2   Improved  2020-12-02\n\n\nNow, we can inspect the order of the levels for both factor variables using the levels() function:\n\nlevels(patient_data$diabetes) # show the levels of diabetes variable\n\n[1] \"Type 1\" \"Type 2\"\n\nlevels(patient_data$status) # show the levels of status variable\n\n[1] \"Excellent\" \"Improved\"  \"Poor\"     \n\n\nAdditionally, we may want to reorder the levels in the status variable using the fct_relevel() function from the forcats package. In this case, the argument rev in the function will reverse the order:\n\n# reverse the order of the levels\npatient_data$status &lt;-  fct_relevel(patient_data$status, rev)\n\nlevels(patient_data$status)  # show the order of the levels\n\n[1] \"Poor\"      \"Improved\"  \"Excellent\"\n\n\nor using the fct_rev() from forcats package:\n\npatient_data$status &lt;- fct_rev(patient_data$status)\n\nThe status variable has a natural ordering between its categories. If we want to compare the values, we have to pass this information to R.\n\npatient_data$status &lt;-  factor(patient_data$status, ordered = TRUE)\n\npatient_data$status\n\n[1] Poor      Improved  Excellent Poor      Poor      Excellent Improved \n[8] Improved \nLevels: Poor &lt; Improved &lt; Excellent\n\n\nNow we can use, for example, the comparison operators &gt; to check whether one element of the ordered vector is larger than the other.\n\npatient_data$status[2] &gt; patient_data$status[6]\n\n[1] FALSE\n\n\nFactors are also useful when we know the set of possible values (based on theory or experimental design, not of the data) but they’re not all present in a given dataset. In contrast to a character vector, when we tabulate a factor (e.g. using the table() function) we will get counts of all categories, even unobserved ones:\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\ntable(sex_factor)\n\nsex_factor\nm f \n3 0"
  },
  {
    "objectID": "list.html#dates-in-r",
    "href": "list.html#dates-in-r",
    "title": "1  Data structures in R: lists and data frames",
    "section": "\n1.8 Dates in R",
    "text": "1.8 Dates in R\nThere are three types of date/time data that refer to an instant in time:\n\nA date. Tibbles print this as &lt;date&gt;.\nA time within a day. Tibbles print this as &lt;time&gt;.\nA date-time is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). Tibbles print this as &lt;dttm&gt;. Elsewhere in R these are called POSIXct.\n\nTo get the current date or date-time you can use Sys.Date() or now():\n\nSys.Date()\nnow()\n\nDate vectors are built on top of double vectors but they have the special class “Date”:\n\ntoday &lt;- Sys.Date()\ntypeof(today)\n\n[1] \"double\"\n\nclass(today)\n\n[1] \"Date\"\n\n\nThe value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01:\n\nunclass(today)\n\n[1] 19635\n\n\nSo, in numeric form, Date counts the days since 1970-01-01. For example:\n\ndate1 &lt;- as.Date('2020-06-28')\nas.numeric(date1)\n\n[1] 18441\n\n\nNow, we can use difftime() to find the amount of time in DAYS that has passed since we created date1.\n\ndifftime(Sys.time(), date1, units = 'days')\n\nTime difference of 1194.794 days\n\n\nPOSIXct stores a date and time. In numeric form, the number of seconds since 1970-01-01.\n\ndate2 &lt;- as.POSIXct('2012-06-28 18:00')\nas.numeric(date2)\n\n[1] 1340895600\n\n\nWe’ve seen also one approach to parsing strings into dates variable in our data frame using the ymd() function from lubridate package. This is the most concise way to create a single date/time object, as we might need when filtering date/time data. The class of this object is:\n\nclass(patient_data$dates)\n\n[1] \"Date\""
  },
  {
    "objectID": "sql.html#introduction-to-relational-databases",
    "href": "sql.html#introduction-to-relational-databases",
    "title": "2  SQL queries within R",
    "section": "\n2.1 Introduction to relational databases",
    "text": "2.1 Introduction to relational databases\nSo far, we have dealt with datasets that easily fit into our computer’s memory. But what about datasets that are too large for our computer to handle as a whole? In this case, storing the data outside of R and organizing it in a database is helpful. Connecting to the database allows us to retrieve only the chunks needed for the current analysis.\nA very common form of data storage is the relational database. There are many relational database management systems (RDBMS), such as SQLite, MySQL, PostgreSQL, Oracle, and many more. These different RDBMS each have their own advantages and limitations. Almost all employ SQL (structured query language) to pull data from the database.\nThankfully, several packages have been written that allows R to connect to relational databases and use the R programming language as the front end (what the user types in) to pull data from them. In this tutorial, we will give examples of how to read and analyzed data using R with SQLite RDBMS.\nData from the Portal Project\nThe Portal Project is a long-term ecological study being conducted near Portal, AZ. Since 1977, the site has been a primary focus of research on interactions among rodents, ants and plants and their respective responses to climate.\nData from the Portal project is recorded in a relational database designed for reliable storage and rapid access to the bounty of information produced by this long-term ecological experiment.\nThe research site consists of many plots – patches of the Arizona desert that are intensively manipulated and repeatedly surveyed (Figure 2.1). The plots have some fixed characteristics, such as the type of manipulation, geographic location, aspect, etc.\n\n\nFigure 2.1: Location of all 24 plots (numbered and outlined in white). Blue flag marks the weather station location.\n\nThe plots have a lot of dynamic characteristics, and those changes are recorded in repeated surveys. In particular, the animals captured during each survey are identified to species, weighed, and measured.\nThere is also the portalr R package that provides a collection of basic functions to summarize the Portal project data on rodents, plants, ants, and weather at our long-term field site in the Chihuahuan Desert.\nBasic definitions in SQL\nDatabase: a container/repository (usually a file or set of files) to store organized data; a set of relational information.\nTables: the information inside the database is organized in tables; a structured list of data\nDatabase terminology builds on common ways of characterizing data files. The breakdown of a table into records (also named rows) or fields (also named columns, or variables) is familiar to anyone who’s worked in spreadsheets. The descriptions below formalize these terms, and provide an example referencing the Portal mammals database.\nTypes of SQL statements (DDL vs. DML)\nSQL statements fall into two different categories: Data Definition Language statements and Data Manipulation Language statements.\nA. Data Definition Language (or DDL) statements are used to define, change, or drop database objects such as tables. Common DDL statement types include CREATE, ALTER, TRUNCATE, and DROP.\nCREATE statement: which is used for creating tables and defining its columns;\nALTER statement: is used for altering tables including adding and dropping columns and modifying their datatypes;\nTRUNCATE statement: is used for deleting data in a table but not the table itself;\nDROP statement: is used for deleting tables.\nB. Data Manipulation Language (or DML) statements are used to read and modify data in tables. These are also sometimes referred to as CRUD operations, that is, Create, Read, Update and Delete rows in a table. Common DML statement types include INSERT, SELECT, UPDATE, and DELETE.\nINSERT statement: is used for inserting a row or several rows of data into a table;\nSELECT statement: reads or selects column/row or columns/rows from a table;\nUPDATE statement: edits row or rows in a table;\nDELETE statement: removes a row or rows of data from a table.\nIn this textbook we will primary use the SELECT statement."
  },
  {
    "objectID": "sql.html#connecting-to-a-database",
    "href": "sql.html#connecting-to-a-database",
    "title": "2  SQL queries within R",
    "section": "\n2.2 Connecting to a database",
    "text": "2.2 Connecting to a database\nThe first step from RStudio is creating a connection object that opens up a channel of communication to the database file. We will connect to our database using the DBI package. For the sake of example, we simply connect to an “in-memory” database, but a wide range of database connectors are available depending on where our data lives.\n\n# connect to the database\nmammals &lt;- DBI::dbConnect(RSQLite::SQLite(),\n                          here(\"data\", \"portal_mammals.sqlite\"))\n\nThis command uses 2 packages that helps dbplyr and dplyr talk to the SQLite database. DBI is not something that we’ll use directly as a user. It allows R to send commands to databases irrespective of the database management system used. The RSQLite allows R to interface with SQLite databases.\nThis command does not load the data into the R session (as the read_csv() function does). Instead, it merely instructs R to connect to the SQLite database contained in the portal_mammals.sqlite file.\nUsing a similar approach, we could connect to many other database management systems that are supported by R including MySQL, PostgreSQL, etc."
  },
  {
    "objectID": "sql.html#explore-the-database",
    "href": "sql.html#explore-the-database",
    "title": "2  SQL queries within R",
    "section": "\n2.3 Explore the database",
    "text": "2.3 Explore the database\nWith the connection object availble, we can begin exploring the database.\nFirst, we can list the tables at the connection:\n\n# mammals SQLite database can contain multiple tables (datasets)\ndbListTables(mammals)\n\n[1] \"plots\"   \"species\" \"surveys\"\n\n\nor, alternately using the src_dbi() from {dbplyr}:\n\nsrc_dbi(mammals)\n\nsrc:  sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\ntbls: plots, species, surveys\n\n\nJust like a spreadsheet with multiple worksheets, a SQLite database can contain multiple tables. In this case three of them are listed in the tbls row in the output above:\nThe three key tables in the relational database are:\n\nplots\nsurveys\nspecies\n\nNow, we’re done with set-up. Let’s explore the fields (variables) contained in a particular table:\n\n# List the fields (variables) in a particular table\ndbListFields(mammals, \"plots\")\n\n[1] \"plot_id\"   \"plot_type\"\n\ndbListFields(mammals, \"surveys\")\n\n[1] \"record_id\"       \"month\"           \"day\"             \"year\"           \n[5] \"plot_id\"         \"species_id\"      \"sex\"             \"hindfoot_length\"\n[9] \"weight\"         \n\ndbListFields(mammals, \"species\")\n\n[1] \"species_id\" \"genus\"      \"species\"    \"taxa\"      \n\n\nTo connect to tables within a database, we can use the tbl() function from dplyr:\n\n## connect to tables with tbl\n\ntbl(mammals, \"plots\")\n\n# Source:   table&lt;plots&gt; [?? x 2]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   plot_id plot_type                \n     &lt;int&gt; &lt;chr&gt;                    \n 1       1 Spectab exclosure        \n 2       2 Control                  \n 3       3 Long-term Krat Exclosure \n 4       4 Control                  \n 5       5 Rodent Exclosure         \n 6       6 Short-term Krat Exclosure\n 7       7 Rodent Exclosure         \n 8       8 Control                  \n 9       9 Spectab exclosure        \n10      10 Rodent Exclosure         \n# ℹ more rows\n\ntbl(mammals, \"surveys\") \n\n# Source:   table&lt;surveys&gt; [?? x 9]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;int&gt;  &lt;int&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n# ℹ more rows\n\ntbl(mammals, \"species\")\n\n# Source:   table&lt;species&gt; [?? x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   species_id genus            species         taxa   \n   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;           &lt;chr&gt;  \n 1 AB         Amphispiza       bilineata       Bird   \n 2 AH         Ammospermophilus harrisi         Rodent \n 3 AS         Ammodramus       savannarum      Bird   \n 4 BA         Baiomys          taylori         Rodent \n 5 CB         Campylorhynchus  brunneicapillus Bird   \n 6 CM         Calamospiza      melanocorys     Bird   \n 7 CQ         Callipepla       squamata        Bird   \n 8 CS         Crotalus         scutalatus      Reptile\n 9 CT         Cnemidophorus    tigris          Reptile\n10 CU         Cnemidophorus    uniparens       Reptile\n# ℹ more rows\n\n\nIf we pay attention to the output for species table, we may notice “Source:” at the very first line of the calling. It says table&lt;species&gt; with no information of the rows and 4 columns [?? x 4]. This is what happens when we navigate a table from relational database through R, it creates a local lazy tibble (tbl_lazy)."
  },
  {
    "objectID": "sql.html#simple-database-queries-with-sql-syntax-select-statements",
    "href": "sql.html#simple-database-queries-with-sql-syntax-select-statements",
    "title": "2  SQL queries within R",
    "section": "\n2.4 Simple database queries with SQL syntax (SELECT statements)",
    "text": "2.4 Simple database queries with SQL syntax (SELECT statements)\nSELECT command (select columns)\nThe tbl() function can be used to send SQL queries to the database if it is combined with the sql() function. To demonstrate this functionality, let’s select the columns record_id, year, species_id, and plot_id from the surveys table:\n\n## SELECT statement\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         3  1977 DM               2\n4         4  1977 DM               7\n5         5  1977 DM               3\n6         6  1977 PF               1\n\n\nAlthough it looks like we just got a data frame from the database, we didn’t! It’s a reference, showing us data that is still in the SQLite database (note the first two lines of the output). It does this because databases are often more efficient at selecting, filtering and joining large data sets than R. And typically, the database will not even be stored on our computer, but rather a more powerful machine somewhere on the web. So R is lazy and waits to bring this data into memory until we explicitly tell it to do so using the collect function from the dbplyr package.\nNote that SQL is case insensitive, so capitalization only helps for readability and is a good style to adopt.\nAlternatively, we can use dbGetQuery() function from {DBI} to pass SQL code to the database file:\n\ndbGetQuery(mammals, \n           \"SELECT record_id, year, species_id, plot_id \n           FROM surveys\") %&gt;% \n  head()\n\n  record_id year species_id plot_id\n1         1 1977         NL       2\n2         2 1977         NL       3\n3         3 1977         DM       2\n4         4 1977         DM       7\n5         5 1977         DM       3\n6         6 1977         PF       1\n\n\nNote that the same operation can be done using dplyr’s verbs instead of writing SQL. First, we select the table on which to do the operations by creating the surveys object, and then we use the standard dplyr syntax as if it were a data frame:\n\nsurveys &lt;- tbl(mammals, \"surveys\")\nquery1 &lt;- surveys %&gt;%\n  select(year, species_id, plot_id) %&gt;% \n  head()\n\nAdditionally, we can use dplyr’s show_query() function to show which SQL commands are actually sent to the database:\n\nshow_query(query1)\n\n&lt;SQL&gt;\nSELECT `year`, `species_id`, `plot_id`\nFROM `surveys`\nLIMIT 6\n\n\nWHERE clause (filtering rows)\nRelational operation helps us in restricting the result set by allowing us to use the clause WHERE. The WHERE clause always requires a predicate. A predicate is conditioned evaluates to true, false or unknown. Predicates are used in the search condition of the WHERE clause.\nSo, if we need to select the rows from the surveys table where the species_id is DM (Dipodomys), we use the WHERE clause with the predicate species_id equals DM. The result set is now restricted to rows whose condition evaluates to true.\n\n## Filtering with WHERE statement and using basic operators\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id = 'DM'\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         3  1977 DM               2\n2         4  1977 DM               7\n3         5  1977 DM               3\n4         8  1977 DM               1\n5         9  1977 DM               1\n6        12  1977 DM               7\n\n\nAdditionally, using BETWEEN-AND comparison operator we can filter a range of values:\n\n# BETWEEN ... AND ....  operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE plot_id BETWEEN 3 AND 5\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         2  1977 NL               3\n2         5  1977 DM               3\n3        11  1977 DS               5\n4        13  1977 DM               3\n5        16  1977 DM               4\n6        17  1977 DS               3\n\n\nWe can also find the missing values NA for a specific field:\n\n# IS NULL operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id IS NULL\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1       324  1977 &lt;NA&gt;             7\n2       325  1977 &lt;NA&gt;            10\n3       326  1977 &lt;NA&gt;            23\n4       401  1977 &lt;NA&gt;             3\n5       402  1977 &lt;NA&gt;            15\n6       403  1977 &lt;NA&gt;            19\n\n\nOther operators is IN that we can use for searching specific values:\n\n# IN operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE plot_id IN (1, 2, 7)\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         3  1977 DM               2\n3         4  1977 DM               7\n4         6  1977 PF               1\n5         7  1977 PE               2\n6         8  1977 DM               1\n\n\nand OR operator\n\n# OR operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id = 'NL' OR species_id = 'PF' \")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         6  1977 PF               1\n4        10  1977 PF               6\n5        19  1977 PF               4\n6        22  1977 NL              15\n\n\nWe can also combine OR and AND operators:\n\n# OR with AND (NOTE: use parenthesis, SQL processes AND before OR)\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE (plot_id = 2 OR plot_id = 7) AND species_id = 'DM' \")) %&gt;% \nhead()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         3  1977 DM               2\n2         4  1977 DM               7\n3        12  1977 DM               7\n4        64  1977 DM               7\n5        67  1977 DM               7\n6        71  1977 DM               7\n\n\nAnother operator is NOT that excludes the records with a specific value:\n\n# NOT operator (exclude records/rows)\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE NOT species_id = 'PF' AND NOT species_id = 'DM' \")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         7  1977 PE               2\n4        11  1977 DS               5\n5        17  1977 DS               3\n6        18  1977 PP               2\n\n\nAdditional useful expressions, COUNT and LIMIT\n\nNext, we’ll briefly present a few additional useful expressions that are used with select statements.\nThe first one is COUNT that is a built-in database function that retrieves the number of rows that match the query criteria.\n\n## COUNT species_id = 'DM'\ntbl(mammals, sql(\"SELECT COUNT (species_id)\n                 FROM surveys\n                 WHERE species_id = 'DM'\"))\n\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  `COUNT (species_id)`\n                 &lt;int&gt;\n1                10596\n\n\nThe second expression is LIMIT that is used for restricting the number of rows retrieved from the database. For example, we can retrieve just the first 10 rows from surveys table.\n\n## LIMIT (just a few rows)\ntbl(mammals, sql(\"SELECT *\n                 FROM surveys\n                 LIMIT 10 \"))\n\n# Source:   SQL [10 x 9]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;int&gt;  &lt;int&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n\n\nNote that if we use the asterisk in the SELECT, we request all columns of the table (instead of column names).\nWe can also retrieve just a few rows in the surveys table for a particular year such as 1985.\n\n## WHERE and LIMIT (just a few rows for a particular year)\ntbl(mammals, sql(\"SELECT *\n                 FROM surveys\n                 WHERE year = 1985 LIMIT 10 \"))\n\n# Source:   SQL [10 x 9]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;int&gt;  &lt;int&gt;\n 1      9790     1    19  1985      16 RM         F                  16      4\n 2      9791     1    19  1985      17 OT         F                  20     16\n 3      9792     1    19  1985       6 DO         M                  35     48\n 4      9793     1    19  1985      12 DO         F                  35     40\n 5      9794     1    19  1985      24 RM         M                  16      4\n 6      9795     1    19  1985      12 DO         M                  34     48\n 7      9796     1    19  1985       6 DM         F                  37     35\n 8      9797     1    19  1985      14 DM         M                  36     45\n 9      9798     1    19  1985       6 DM         F                  36     38\n10      9799     1    19  1985      19 RM         M                  16      4\n\n\nSorting results sets with ORDER BY clause\n\n## ORDER BY species_id\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 ORDER BY species_id DESC\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1     14250  1988 ZL              18\n2     14351  1988 ZL              23\n3     35512  2002 US              11\n4     35513  2002 US              11\n5     35528  2002 US              13\n6     35544  2002 US              15\n\n\nOf note, the ORDER BY clause must be always the last in a select statement.\nGrouping Result Sets, GROUP BY\n\n\n## Just COUNT sex\ntbl(mammals, sql(\"SELECT COUNT (sex)\n                 FROM surveys\n                 \"))\n\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  `COUNT (sex)`\n          &lt;int&gt;\n1         33038\n\n\n\n## COUNT BY GROUP\ntbl(mammals, sql(\"SELECT sex, COUNT(sex)\n                 AS count FROM surveys GROUP BY sex\n                 \"))\n\n# Source:   SQL [3 x 2]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  sex   count\n  &lt;chr&gt; &lt;int&gt;\n1 &lt;NA&gt;      0\n2 F     15690\n3 M     17348\n\n\n\n## COUNT BY GROUP and use HAVING clause for selection \ntbl(mammals, sql(\"SELECT sex, COUNT(sex)\n                 AS count FROM surveys GROUP BY sex\n                 HAVING count &gt; 16000\"))\n\n# Source:   SQL [1 x 2]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  sex   count\n  &lt;chr&gt; &lt;int&gt;\n1 M     17348\n\n\nWildcards (using with string paterns) with LIKE predicate\n\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\"))\n\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   species_id genus            taxa   \n   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;  \n 1 AB         Amphispiza       Bird   \n 2 AH         Ammospermophilus Rodent \n 3 AS         Ammodramus       Bird   \n 4 BA         Baiomys          Rodent \n 5 CB         Campylorhynchus  Bird   \n 6 CM         Calamospiza      Bird   \n 7 CQ         Callipepla       Bird   \n 8 CS         Crotalus         Reptile\n 9 CT         Cnemidophorus    Reptile\n10 CU         Cnemidophorus    Reptile\n# ℹ more rows\n\n\n\n## grabs anything ending with letters 'za' \ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE '%za' \"))\n\n# Source:   SQL [2 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus       taxa \n  &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;\n1 AB         Amphispiza  Bird \n2 CM         Calamospiza Bird \n\n\n\n## grabs anything that starts with the letter 'A'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'A%' \"))\n\n# Source:   SQL [3 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus            taxa  \n  &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt; \n1 AB         Amphispiza       Bird  \n2 AH         Ammospermophilus Rodent\n3 AS         Ammodramus       Bird  \n\n\n\n## grabs anything before and after the letters 'sp'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE '%sp%' \"))\n\n# Source:   SQL [7 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus            taxa  \n  &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt; \n1 AB         Amphispiza       Bird  \n2 AH         Ammospermophilus Rodent\n3 CM         Calamospiza      Bird  \n4 SB         Spizella         Bird  \n5 SS         Spermophilus     Rodent\n6 ST         Spermophilus     Rodent\n7 US         Sparrow          Bird  \n\n\n\n## grabs anything that starts with 'c' and ends with 'us'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'c%us' \"))\n\n# Source:   SQL [9 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus           taxa   \n  &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;  \n1 CB         Campylorhynchus Bird   \n2 CS         Crotalus        Reptile\n3 CT         Cnemidophorus   Reptile\n4 CU         Cnemidophorus   Reptile\n5 CV         Crotalus        Reptile\n6 PB         Chaetodipus     Rodent \n7 PI         Chaetodipus     Rodent \n8 PP         Chaetodipus     Rodent \n9 PX         Chaetodipus     Rodent \n\n\nFinally, we may add the collect() command from dplyr package that allows R to retrieve the data from the database. The data is then stored as a tbl, not as a tbl_lazy anymore. For example:\n\n## Collect the data\nspecies_c_us &lt;- tbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'c%us' \")) %&gt;% \n  collect()  # retrieves data into a local tibble\n\nspecies_c_us\n\n# A tibble: 9 × 3\n  species_id genus           taxa   \n  &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;  \n1 CB         Campylorhynchus Bird   \n2 CS         Crotalus        Reptile\n3 CT         Cnemidophorus   Reptile\n4 CU         Cnemidophorus   Reptile\n5 CV         Crotalus        Reptile\n6 PB         Chaetodipus     Rodent \n7 PI         Chaetodipus     Rodent \n8 PP         Chaetodipus     Rodent \n9 PX         Chaetodipus     Rodent \n\nclass(species_c_us)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\""
  },
  {
    "objectID": "sql.html#close-the-connection",
    "href": "sql.html#close-the-connection",
    "title": "2  SQL queries within R",
    "section": "\n2.5 Close the connection",
    "text": "2.5 Close the connection\nGood housekeeping means always remembering to disconnect once you’re done.\n\ndbDisconnect(mammals) # closes our DB connection"
  }
]