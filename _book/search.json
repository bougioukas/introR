[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to R",
    "section": "",
    "text": "Preface\nThis is a working draft.\nThis online textbook is based on notes from a series of lectures given for a few years at the Aristotle University of Thessaloniki in the Laboratory of Hygiene, Social-Preventive Medicine & Medical Statistics.\nThis textbook can be used as support material for lectures on R at any level from beginner to advanced. We have paid particular attention to the form of the book, which we think should aid understanding. It can also be used as a support for self-teaching.\nAll sections of this textbook are reproducible as they were made using Quarto® which is an open-source scientific and technical publishing system built on Pandoc.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "An Introduction to R",
    "section": "License",
    "text": "License\nThis textbook is free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "calculations.html#arithmetic-operators-in-r",
    "href": "calculations.html#arithmetic-operators-in-r",
    "title": "1  Calculations in R",
    "section": "\n1.1 Arithmetic Operators in R",
    "text": "1.1 Arithmetic Operators in R\nThe simplest thing we could do with R is arithmetic operations with numbers. For example:\n\n1 + 100 \n\n[1] 101\n\n\nR printed out the result, with a preceding [1].\n \nIn the previous calculation the + sign was used to carry out the addition. Table 1.1 presents a list of arithmetic operators available in R.\n\n\nTable 1.1: Arithmetic Operators in R\n\nOperator\nDescription\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^\nexponent\n\n\n%%\nmodulus (remainder from division)\n\n\n%/%\ninteger division\n\n\n\n\nRemember when using R as a calculator, the order of operations is the same as we would have learned back in school.\nFrom highest to lowest precedence:\n\nParentheses: ( )\n\nExponents: ^ or **\n\nDivision: /\n\nMultiplication: *\n\nAddition: +\n\nSubtraction: -\n\n\nTherefore:\n\n3 + 5 * 2\n\n[1] 13\n\n\n \nParentheses\nUse parentheses to group operations in order to force the order of evaluation if it differs from the default, or to make clear what we intend.\n\n(3 + 5) * 2\n\n[1] 16\n\n\nThis can get unwieldy when not needed, but clarifies our intentions. Remember that others may later read our code.\n\n(3 + (5 * (2 ^ 2))) # hard to read\n3 + 5 * 2 ^ 2       # clear, if we remember the rules\n3 + 5 * (2 ^ 2)     # if we forget some rules, this might help\n\n\n\n\n\n\n\nImportant\n\n\n\nRemember that the text after each line of code is a comment. Anything that follows after the hash symbol # is ignored by R when executes code.\n\n\n \nModular arithmetic\nSuppose we want to know the integer part of a division: say, how many 13s there are in 119:\n\n119 %/% 13\n\n[1] 9\n\n\nNow suppose we wanted to know the remainder (what is left over when 119 is divided by 13): in maths this is known as 119 modulo 13, and the value 13 is known as the modulus:\n\n119 %% 13\n\n[1] 2\n\n\nModulo is very useful for testing whether one number is an exact multiple of some other number. For example, to find out whether 15421 is a multiple of 7:\n\n15421 %% 7\n\n[1] 0\n\n\nIt is as there is no remainder. We can then carry out more complex modular arithmetic:\n\n(123 + 456) %% 19\n\n[1] 9\n\n\nBut don’t forget to put brackets around the expression for which we want to carry out the modular calculation."
  },
  {
    "objectID": "calculations.html#relational-operators-in-r",
    "href": "calculations.html#relational-operators-in-r",
    "title": "1  Calculations in R",
    "section": "\n1.2 Relational Operators in R",
    "text": "1.2 Relational Operators in R\nRelational (or comparison) operators are used to compare between values. Comparisons in R typically evaluate to TRUE or FALSE (which in certain circumstances we can abbreviate to T and F). Here is a list of relational operators available in R (Table 1.2).\n\n\nTable 1.2: Relational (comparison) operators in R\n\nsymbol\nread as\n\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n==\nequal to\n\n\n&lt;=\nless than or equal to\n\n\n&gt;=\ngreater than or equal to\n\n\n!=\nnot equal to\n\n\n\n\nSome simple comparisons with integer numbers follow:\n\n\n\n\n\n\nExamples\n\n\n\n\n2 &lt; 1  # less than\n\n[1] FALSE\n\n\n\n1 &gt; 0  # greater than\n\n[1] TRUE\n\n\n\n1 == 1  # equal to (double equal sign for equality)\n\n[1] TRUE\n\n\n\n1 &lt;= 1  # less than or equal to\n\n[1] TRUE\n\n\n\n-9 &gt;= -3 # greater than or equal to\n\n[1] FALSE\n\n\n\n1 != 2  # not equal to (inequality)\n\n[1] TRUE"
  },
  {
    "objectID": "calculations.html#floating-point-number",
    "href": "calculations.html#floating-point-number",
    "title": "1  Calculations in R",
    "section": "\n1.3 Floating point number",
    "text": "1.3 Floating point number\nWhen dealing with real numbers floating point number, we must be very careful when checking equality.\nFor example, we know from trigonometry that:\n\\[\\cos(\\frac{\\pi}{2}) = \\cos( \\frac{3 \\pi}{2}) = 0  \\]\nHowever, if we compare the two numbers we get:\n\ncos(pi/2) == cos(3*pi/2)\n\n[1] FALSE\n\n\nIn this instance, we can test for ‘near equality’ applying the all.equal() function which tests for equality with a difference tolerance of 1.5e-8.\n\nall.equal(cos(pi/2), cos(3*pi/2))\n\n[1] TRUE\n\n\nIf the difference is greater than the tolerance level 1.5e-8 the function will return the mean relative difference.\nTry to test this:\n\nall.equal(4.0000007, 4.0000008)\n\n\n\n\n\n\n\nDon’t use == to compare two numbers\n\n\n\nWe should never use == to compare two numbers unless they are integers (whole numbers) or fractions whose denominator is a power of 2 (\\(2^n\\), where n is integer). Computers may only represent decimal numbers with a certain degree of precision (rounded to typically 53 binary digits accuracy which allows representing decimal numbers to 15 or 16 significant digits), so two numbers which look the same when printed out by R, may actually have different underlying representations and therefore be different by a small margin of error (called Machine numeric tolerance)."
  },
  {
    "objectID": "calculations.html#scientific-notation",
    "href": "calculations.html#scientific-notation",
    "title": "1  Calculations in R",
    "section": "\n1.4 Scientific notation",
    "text": "1.4 Scientific notation\nScientific notation is a special way of expressing numbers that are too big or too small to be conveniently written in decimal form. Generally, it expresses numbers in forms of \\(m \\times 10^n\\) and R uses the e notation.\n\n\n\n\n\n\nExamples\n\n\n\n\n0.0055 is written \\(5.5 \\times 10^{-3}\\)\nbecause 0.0055 = 5.5 × 0.001 = 5.5 × \\(10^{-3}\\) or 5.5e-3\n0.000000015 is written \\(1.5 \\times 10^{-8}\\)\nbecause 0.000000015 = 1.5 × 0.00000001 = 1.5 × \\(10^{-8}\\) or 1.5e-8\n5500 is written \\(5.5 \\times 10^{3}\\)\nbecause 5500 = 5.5 × 1000 = 5.5 × \\(10^{3}\\) or 5.5e3\n150000000 is written \\(1.5 \\times 10^{8}\\)\nbecause 150000000 = 1.5 × 100000000 = 1.5 × \\(10^{8}\\) or 1.5e8\n\n\n\n\n\n\n\n\n\nScientific notation Vs Euler’s number\n\n\n\nNote that the e notation has nothing to do with the Euler’s number e=2.718 ."
  },
  {
    "objectID": "calculations.html#special-values-in-r",
    "href": "calculations.html#special-values-in-r",
    "title": "1  Calculations in R",
    "section": "\n1.5 Special values in R",
    "text": "1.5 Special values in R\nThere are a few special values that are used in R.\nMissing values (NA)\nFor example, in the real world, missing values may occur when recording sensor information. R uses a special numeric value NA standing for “Not available” and represents a missing value. Mathematical functions/operations using NA produces NA:\n\ncos(NA)\n\n[1] NA\n\n\n\n1 + NA\n\n[1] NA\n\n\n \nInfinitive: -Inf or Inf\nThere is also a special number Inf which represents infinity. Fortunately, R has special numbers for this.\nThis allows us to represent entities like:\n\n1/0\n\n[1] Inf\n\n\nThe Inf can also be used in ordinary calculations:\n\nexp(-Inf)\n\n[1] 0\n\n\n \nNot A Number (NaN)\nThe value NaN (stands for “not a number”) represents an undefined value and it is usually the product of some arithmetic operations. For example:\n\nInf/Inf\n\n[1] NaN\n\n\n\n0/0\n\n[1] NaN\n\n\n\ncos(Inf)\n\nWarning in cos(Inf): NaNs produced\n\n\n[1] NaN\n\n\n \nNULL\nAdditionally, there is a null object in R, represented by the symbol NULL. (The symbol NULL always points to the same object.) NULL is often used as an argument in functions to mean that no value was assigned to the argument. Additionally, some functions may return NULL. Note that NULL is not the same as NA, Inf, -Inf, or NaN."
  },
  {
    "objectID": "sql.html#introduction-to-relational-databases",
    "href": "sql.html#introduction-to-relational-databases",
    "title": "2  SQL queries within R",
    "section": "\n2.1 Introduction to relational databases",
    "text": "2.1 Introduction to relational databases\nSo far, we have dealt with datasets that easily fit into our computer’s memory. But what about datasets that are too large for our computer to handle as a whole? In this case, storing the data outside of R and organizing it in a database is helpful. Connecting to the database allows us to retrieve only the chunks needed for the current analysis.\nA very common form of data storage is the relational database. There are many relational database management systems (RDBMS), such as SQLite, MySQL, PostgreSQL, Oracle, and many more. These different RDBMS each have their own advantages and limitations. Almost all employ SQL (structured query language) to pull data from the database.\nThankfully, several packages have been written that allows R to connect to relational databases and use the R programming language as the front end (what the user types in) to pull data from them. In this tutorial, we will give examples of how to read and analyzed data using R with SQLite RDBMS.\nData from the Portal Project\nThe Portal Project is a long-term ecological study being conducted near Portal, AZ. Since 1977, the site has been a primary focus of research on interactions among rodents, ants and plants and their respective responses to climate.\nData from the Portal project is recorded in a relational database designed for reliable storage and rapid access to the bounty of information produced by this long-term ecological experiment.\nThe research site consists of many plots – patches of the Arizona desert that are intensively manipulated and repeatedly surveyed (Figure 2.1). The plots have some fixed characteristics, such as the type of manipulation, geographic location, aspect, etc.\n\n\nFigure 2.1: Location of all 24 plots (numbered and outlined in white). Blue flag marks the weather station location.\n\nThe plots have a lot of dynamic characteristics, and those changes are recorded in repeated surveys. In particular, the animals captured during each survey are identified to species, weighed, and measured.\nThere is also the portalr R package that provides a collection of basic functions to summarize the Portal project data on rodents, plants, ants, and weather at our long-term field site in the Chihuahuan Desert.\nBasic definitions in SQL\nDatabase: a container/repository (usually a file or set of files) to store organized data; a set of relational information.\nTables: the information inside the database is organized in tables; a structured list of data\nDatabase terminology builds on common ways of characterizing data files. The breakdown of a table into records (also named rows) or fields (also named columns, or variables) is familiar to anyone who’s worked in spreadsheets. The descriptions below formalize these terms, and provide an example referencing the Portal mammals database.\nTypes of SQL statements (DDL vs. DML)\nSQL statements fall into two different categories: Data Definition Language statements and Data Manipulation Language statements.\nA. Data Definition Language (or DDL) statements are used to define, change, or drop database objects such as tables. Common DDL statement types include CREATE, ALTER, TRUNCATE, and DROP.\nCREATE statement: which is used for creating tables and defining its columns;\nALTER statement: is used for altering tables including adding and dropping columns and modifying their datatypes;\nTRUNCATE statement: is used for deleting data in a table but not the table itself;\nDROP statement: is used for deleting tables.\nB. Data Manipulation Language (or DML) statements are used to read and modify data in tables. These are also sometimes referred to as CRUD operations, that is, Create, Read, Update and Delete rows in a table. Common DML statement types include INSERT, SELECT, UPDATE, and DELETE.\nINSERT statement: is used for inserting a row or several rows of data into a table;\nSELECT statement: reads or selects column/row or columns/rows from a table;\nUPDATE statement: edits row or rows in a table;\nDELETE statement: removes a row or rows of data from a table.\nIn this textbook we will primary use the SELECT statement."
  },
  {
    "objectID": "sql.html#connecting-to-a-database",
    "href": "sql.html#connecting-to-a-database",
    "title": "2  SQL queries within R",
    "section": "\n2.2 Connecting to a database",
    "text": "2.2 Connecting to a database\nThe first step from RStudio is creating a connection object that opens up a channel of communication to the database file. We will connect to our database using the DBI package. For the sake of example, we simply connect to an “in-memory” database, but a wide range of database connectors are available depending on where our data lives.\n\n# connect to the database\nmammals &lt;- DBI::dbConnect(RSQLite::SQLite(),\n                          here(\"data\", \"portal_mammals.sqlite\"))\n\nThis command uses 2 packages that helps dbplyr and dplyr talk to the SQLite database. DBI is not something that we’ll use directly as a user. It allows R to send commands to databases irrespective of the database management system used. The RSQLite allows R to interface with SQLite databases.\nThis command does not load the data into the R session (as the read_csv() function does). Instead, it merely instructs R to connect to the SQLite database contained in the portal_mammals.sqlite file.\nUsing a similar approach, we could connect to many other database management systems that are supported by R including MySQL, PostgreSQL, etc."
  },
  {
    "objectID": "sql.html#explore-the-database",
    "href": "sql.html#explore-the-database",
    "title": "2  SQL queries within R",
    "section": "\n2.3 Explore the database",
    "text": "2.3 Explore the database\nWith the connection object availble, we can begin exploring the database.\nFirst, we can list the tables at the connection:\n\n# mammals SQLite database can contain multiple tables (datasets)\ndbListTables(mammals)\n\n[1] \"plots\"   \"species\" \"surveys\"\n\n\nor, alternately using the src_dbi() from {dbplyr}:\n\nsrc_dbi(mammals)\n\nsrc:  sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\ntbls: plots, species, surveys\n\n\nJust like a spreadsheet with multiple worksheets, a SQLite database can contain multiple tables. In this case three of them are listed in the tbls row in the output above:\nThe three key tables in the relational database are:\n\nplots\nsurveys\nspecies\n\nNow, we’re done with set-up. Let’s explore the fields (variables) contained in a particular table:\n\n# List the fields (variables) in a particular table\ndbListFields(mammals, \"plots\")\n\n[1] \"plot_id\"   \"plot_type\"\n\ndbListFields(mammals, \"surveys\")\n\n[1] \"record_id\"       \"month\"           \"day\"             \"year\"           \n[5] \"plot_id\"         \"species_id\"      \"sex\"             \"hindfoot_length\"\n[9] \"weight\"         \n\ndbListFields(mammals, \"species\")\n\n[1] \"species_id\" \"genus\"      \"species\"    \"taxa\"      \n\n\nTo connect to tables within a database, we can use the tbl() function from dplyr:\n\n## connect to tables with tbl\n\ntbl(mammals, \"plots\")\n\n# Source:   table&lt;plots&gt; [?? x 2]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   plot_id plot_type                \n     &lt;int&gt; &lt;chr&gt;                    \n 1       1 Spectab exclosure        \n 2       2 Control                  \n 3       3 Long-term Krat Exclosure \n 4       4 Control                  \n 5       5 Rodent Exclosure         \n 6       6 Short-term Krat Exclosure\n 7       7 Rodent Exclosure         \n 8       8 Control                  \n 9       9 Spectab exclosure        \n10      10 Rodent Exclosure         \n# ℹ more rows\n\ntbl(mammals, \"surveys\") \n\n# Source:   table&lt;surveys&gt; [?? x 9]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;int&gt;  &lt;int&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n# ℹ more rows\n\ntbl(mammals, \"species\")\n\n# Source:   table&lt;species&gt; [?? x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   species_id genus            species         taxa   \n   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;           &lt;chr&gt;  \n 1 AB         Amphispiza       bilineata       Bird   \n 2 AH         Ammospermophilus harrisi         Rodent \n 3 AS         Ammodramus       savannarum      Bird   \n 4 BA         Baiomys          taylori         Rodent \n 5 CB         Campylorhynchus  brunneicapillus Bird   \n 6 CM         Calamospiza      melanocorys     Bird   \n 7 CQ         Callipepla       squamata        Bird   \n 8 CS         Crotalus         scutalatus      Reptile\n 9 CT         Cnemidophorus    tigris          Reptile\n10 CU         Cnemidophorus    uniparens       Reptile\n# ℹ more rows\n\n\nIf we pay attention to the output for species table, we may notice “Source:” at the very first line of the calling. It says table&lt;species&gt; with no information of the rows and 4 columns [?? x 4]. This is what happens when we navigate a table from relational database through R, it creates a local lazy tibble (tbl_lazy)."
  },
  {
    "objectID": "sql.html#simple-database-queries-with-sql-syntax-select-statements",
    "href": "sql.html#simple-database-queries-with-sql-syntax-select-statements",
    "title": "2  SQL queries within R",
    "section": "\n2.4 Simple database queries with SQL syntax (SELECT statements)",
    "text": "2.4 Simple database queries with SQL syntax (SELECT statements)\nSELECT command (select columns)\nThe tbl() function can be used to send SQL queries to the database if it is combined with the sql() function. To demonstrate this functionality, let’s select the columns record_id, year, species_id, and plot_id from the surveys table:\n\n## SELECT statement\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         3  1977 DM               2\n4         4  1977 DM               7\n5         5  1977 DM               3\n6         6  1977 PF               1\n\n\nAlthough it looks like we just got a data frame from the database, we didn’t! It’s a reference, showing us data that is still in the SQLite database (note the first two lines of the output). It does this because databases are often more efficient at selecting, filtering and joining large data sets than R. And typically, the database will not even be stored on our computer, but rather a more powerful machine somewhere on the web. So R is lazy and waits to bring this data into memory until we explicitly tell it to do so using the collect function from the dbplyr package.\nNote that SQL is case insensitive, so capitalization only helps for readability and is a good style to adopt.\nAlternatively, we can use dbGetQuery() function from {DBI} to pass SQL code to the database file:\n\ndbGetQuery(mammals, \n           \"SELECT record_id, year, species_id, plot_id \n           FROM surveys\") %&gt;% \n  head()\n\n  record_id year species_id plot_id\n1         1 1977         NL       2\n2         2 1977         NL       3\n3         3 1977         DM       2\n4         4 1977         DM       7\n5         5 1977         DM       3\n6         6 1977         PF       1\n\n\nNote that the same operation can be done using dplyr’s verbs instead of writing SQL. First, we select the table on which to do the operations by creating the surveys object, and then we use the standard dplyr syntax as if it were a data frame:\n\nsurveys &lt;- tbl(mammals, \"surveys\")\nquery1 &lt;- surveys %&gt;%\n  select(year, species_id, plot_id) %&gt;% \n  head()\n\nAdditionally, we can use dplyr’s show_query() function to show which SQL commands are actually sent to the database:\n\nshow_query(query1)\n\n&lt;SQL&gt;\nSELECT `year`, `species_id`, `plot_id`\nFROM `surveys`\nLIMIT 6\n\n\nWHERE clause (filtering rows)\nRelational operation helps us in restricting the result set by allowing us to use the clause WHERE. The WHERE clause always requires a predicate. A predicate is conditioned evaluates to true, false or unknown. Predicates are used in the search condition of the WHERE clause.\nSo, if we need to select the rows from the surveys table where the species_id is DM (Dipodomys), we use the WHERE clause with the predicate species_id equals DM. The result set is now restricted to rows whose condition evaluates to true.\n\n## Filtering with WHERE statement and using basic operators\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id = 'DM'\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         3  1977 DM               2\n2         4  1977 DM               7\n3         5  1977 DM               3\n4         8  1977 DM               1\n5         9  1977 DM               1\n6        12  1977 DM               7\n\n\nAdditionally, using BETWEEN-AND comparison operator we can filter a range of values:\n\n# BETWEEN ... AND ....  operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE plot_id BETWEEN 3 AND 5\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         2  1977 NL               3\n2         5  1977 DM               3\n3        11  1977 DS               5\n4        13  1977 DM               3\n5        16  1977 DM               4\n6        17  1977 DS               3\n\n\nWe can also find the missing values NA for a specific field:\n\n# IS NULL operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id IS NULL\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1       324  1977 &lt;NA&gt;             7\n2       325  1977 &lt;NA&gt;            10\n3       326  1977 &lt;NA&gt;            23\n4       401  1977 &lt;NA&gt;             3\n5       402  1977 &lt;NA&gt;            15\n6       403  1977 &lt;NA&gt;            19\n\n\nOther operators is IN that we can use for searching specific values:\n\n# IN operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE plot_id IN (1, 2, 7)\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         3  1977 DM               2\n3         4  1977 DM               7\n4         6  1977 PF               1\n5         7  1977 PE               2\n6         8  1977 DM               1\n\n\nand OR operator\n\n# OR operator\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE species_id = 'NL' OR species_id = 'PF' \")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         6  1977 PF               1\n4        10  1977 PF               6\n5        19  1977 PF               4\n6        22  1977 NL              15\n\n\nWe can also combine OR and AND operators:\n\n# OR with AND (NOTE: use parenthesis, SQL processes AND before OR)\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE (plot_id = 2 OR plot_id = 7) AND species_id = 'DM' \")) %&gt;% \nhead()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         3  1977 DM               2\n2         4  1977 DM               7\n3        12  1977 DM               7\n4        64  1977 DM               7\n5        67  1977 DM               7\n6        71  1977 DM               7\n\n\nAnother operator is NOT that excludes the records with a specific value:\n\n# NOT operator (exclude records/rows)\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 WHERE NOT species_id = 'PF' AND NOT species_id = 'DM' \")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1         1  1977 NL               2\n2         2  1977 NL               3\n3         7  1977 PE               2\n4        11  1977 DS               5\n5        17  1977 DS               3\n6        18  1977 PP               2\n\n\nAdditional useful expressions, COUNT and LIMIT\n\nNext, we’ll briefly present a few additional useful expressions that are used with select statements.\nThe first one is COUNT that is a built-in database function that retrieves the number of rows that match the query criteria.\n\n## COUNT species_id = 'DM'\ntbl(mammals, sql(\"SELECT COUNT (species_id)\n                 FROM surveys\n                 WHERE species_id = 'DM'\"))\n\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  `COUNT (species_id)`\n                 &lt;int&gt;\n1                10596\n\n\nThe second expression is LIMIT that is used for restricting the number of rows retrieved from the database. For example, we can retrieve just the first 10 rows from surveys table.\n\n## LIMIT (just a few rows)\ntbl(mammals, sql(\"SELECT *\n                 FROM surveys\n                 LIMIT 10 \"))\n\n# Source:   SQL [10 x 9]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;int&gt;  &lt;int&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n\n\nNote that if we use the asterisk in the SELECT, we request all columns of the table (instead of column names).\nWe can also retrieve just a few rows in the surveys table for a particular year such as 1985.\n\n## WHERE and LIMIT (just a few rows for a particular year)\ntbl(mammals, sql(\"SELECT *\n                 FROM surveys\n                 WHERE year = 1985 LIMIT 10 \"))\n\n# Source:   SQL [10 x 9]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;int&gt;  &lt;int&gt;\n 1      9790     1    19  1985      16 RM         F                  16      4\n 2      9791     1    19  1985      17 OT         F                  20     16\n 3      9792     1    19  1985       6 DO         M                  35     48\n 4      9793     1    19  1985      12 DO         F                  35     40\n 5      9794     1    19  1985      24 RM         M                  16      4\n 6      9795     1    19  1985      12 DO         M                  34     48\n 7      9796     1    19  1985       6 DM         F                  37     35\n 8      9797     1    19  1985      14 DM         M                  36     45\n 9      9798     1    19  1985       6 DM         F                  36     38\n10      9799     1    19  1985      19 RM         M                  16      4\n\n\nSorting results sets with ORDER BY clause\n\n## ORDER BY species_id\ntbl(mammals, sql(\"SELECT record_id, year, species_id, plot_id \n                 FROM surveys\n                 ORDER BY species_id DESC\")) %&gt;% \n  head()\n\n# Source:   SQL [6 x 4]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  record_id  year species_id plot_id\n      &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;\n1     14250  1988 ZL              18\n2     14351  1988 ZL              23\n3     35512  2002 US              11\n4     35513  2002 US              11\n5     35528  2002 US              13\n6     35544  2002 US              15\n\n\nOf note, the ORDER BY clause must be always the last in a select statement.\nGrouping Result Sets, GROUP BY\n\n\n## Just COUNT sex\ntbl(mammals, sql(\"SELECT COUNT (sex)\n                 FROM surveys\n                 \"))\n\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  `COUNT (sex)`\n          &lt;int&gt;\n1         33038\n\n\n\n## COUNT BY GROUP\ntbl(mammals, sql(\"SELECT sex, COUNT(sex)\n                 AS count FROM surveys GROUP BY sex\n                 \"))\n\n# Source:   SQL [3 x 2]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  sex   count\n  &lt;chr&gt; &lt;int&gt;\n1 &lt;NA&gt;      0\n2 F     15690\n3 M     17348\n\n\n\n## COUNT BY GROUP and use HAVING clause for selection \ntbl(mammals, sql(\"SELECT sex, COUNT(sex)\n                 AS count FROM surveys GROUP BY sex\n                 HAVING count &gt; 16000\"))\n\n# Source:   SQL [1 x 2]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  sex   count\n  &lt;chr&gt; &lt;int&gt;\n1 M     17348\n\n\nWildcards (using with string paterns) with LIKE predicate\n\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\"))\n\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n   species_id genus            taxa   \n   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;  \n 1 AB         Amphispiza       Bird   \n 2 AH         Ammospermophilus Rodent \n 3 AS         Ammodramus       Bird   \n 4 BA         Baiomys          Rodent \n 5 CB         Campylorhynchus  Bird   \n 6 CM         Calamospiza      Bird   \n 7 CQ         Callipepla       Bird   \n 8 CS         Crotalus         Reptile\n 9 CT         Cnemidophorus    Reptile\n10 CU         Cnemidophorus    Reptile\n# ℹ more rows\n\n\n\n## grabs anything ending with letters 'za' \ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE '%za' \"))\n\n# Source:   SQL [2 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus       taxa \n  &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;\n1 AB         Amphispiza  Bird \n2 CM         Calamospiza Bird \n\n\n\n## grabs anything that starts with the letter 'A'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'A%' \"))\n\n# Source:   SQL [3 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus            taxa  \n  &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt; \n1 AB         Amphispiza       Bird  \n2 AH         Ammospermophilus Rodent\n3 AS         Ammodramus       Bird  \n\n\n\n## grabs anything before and after the letters 'sp'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE '%sp%' \"))\n\n# Source:   SQL [7 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus            taxa  \n  &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt; \n1 AB         Amphispiza       Bird  \n2 AH         Ammospermophilus Rodent\n3 CM         Calamospiza      Bird  \n4 SB         Spizella         Bird  \n5 SS         Spermophilus     Rodent\n6 ST         Spermophilus     Rodent\n7 US         Sparrow          Bird  \n\n\n\n## grabs anything that starts with 'c' and ends with 'us'\ntbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'c%us' \"))\n\n# Source:   SQL [9 x 3]\n# Database: sqlite 3.41.2 [C:\\My_R\\introR\\data\\portal_mammals.sqlite]\n  species_id genus           taxa   \n  &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;  \n1 CB         Campylorhynchus Bird   \n2 CS         Crotalus        Reptile\n3 CT         Cnemidophorus   Reptile\n4 CU         Cnemidophorus   Reptile\n5 CV         Crotalus        Reptile\n6 PB         Chaetodipus     Rodent \n7 PI         Chaetodipus     Rodent \n8 PP         Chaetodipus     Rodent \n9 PX         Chaetodipus     Rodent \n\n\nFinally, we may add the collect() command from dplyr package that allows R to retrieve the data from the database. The data is then stored as a tbl, not as a tbl_lazy anymore. For example:\n\n## Collect the data\nspecies_c_us &lt;- tbl(mammals, sql(\"SELECT species_id, genus, taxa \n                 FROM species\n                 WHERE genus LIKE 'c%us' \")) %&gt;% \n  collect()  # retrieves data into a local tibble\n\nspecies_c_us\n\n# A tibble: 9 × 3\n  species_id genus           taxa   \n  &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;  \n1 CB         Campylorhynchus Bird   \n2 CS         Crotalus        Reptile\n3 CT         Cnemidophorus   Reptile\n4 CU         Cnemidophorus   Reptile\n5 CV         Crotalus        Reptile\n6 PB         Chaetodipus     Rodent \n7 PI         Chaetodipus     Rodent \n8 PP         Chaetodipus     Rodent \n9 PX         Chaetodipus     Rodent \n\nclass(species_c_us)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\""
  },
  {
    "objectID": "sql.html#close-the-connection",
    "href": "sql.html#close-the-connection",
    "title": "2  SQL queries within R",
    "section": "\n2.5 Close the connection",
    "text": "2.5 Close the connection\nGood housekeeping means always remembering to disconnect once you’re done.\n\ndbDisconnect(mammals) # closes our DB connection"
  }
]