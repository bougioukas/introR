[
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "An Introduction to R",
    "section": "License",
    "text": "License\nThis textbook is free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License."
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction to R and Rstudio",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "introduction.html#installing-r-and-rstudio",
    "href": "introduction.html#installing-r-and-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.1 Installing R and RStudio",
    "text": "1.1 Installing R and RStudio\nFirst things first. We need to download and install both R and RStudio (an integrated development environment for R) on our personal computer. First, we install R, then we will need to install RStudio.\n\nFirst, we must Download and install R:\n\n\nIf our operating system (OS) is Windows: we click on “Download R for Windows”, then click on “base”, then click on the Download link.\nIf our operating system (OS) is macOS: we click on “Download R for (Mac) OS X”, then under “Latest release:” click on R-X.X.X.pkg, where R-X.X.X is the version number.\n\n\nSecond, we must Download and install RStudio:\n\n\nWe scroll down near the bottom of the page.\nWe click on the download link corresponding to your computer’s operating system.\n\nWe follow the usual installation procedures for R and RSudio."
  },
  {
    "objectID": "introduction.html#what-are-r-and-rstudio",
    "href": "introduction.html#what-are-r-and-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.2 What are R and RStudio?",
    "text": "1.2 What are R and RStudio?\nWe will use R via RStudio. Beginners often confuse the two applications. Using an analogy, R is like an airplane’s engine while RStudio is like an airplane’s dashboard (Figure 1.1).\nSpecifically, R is a statistical programming language (an implementation of the S programming language) and a powerful graphics engine, which was created by Ross Ihahka and Robert Gentleman at the University of Auckland in 1993.\nThe name R for the language was coined after the initials of the forenames of the inventors, plus the influence of the S language.\nR does all the heavy work (like an airplane engine) while RStudio is an integrated development environment (IDE) that was founded by J.J. Allaire in 2009. RStudio provides a friendly interface by adding a plenty of great features, auto-complete functions and tools (like an airplane dashboard with electronic monitors, and navigation systems) and makes life a lot easier.\n\n\nFigure 1.1: Analogy of difference between R and RStudio\n\n\nAfter we install R and RStudio on our computer, we’ll have two new programs (also called applications) we can open. In this textbook, we’ll always work in RStudio.\n\n\n\n\n\n\nWhy R Programming Language?\n\n\n\n\nR programming is used as a leading tool for machine learning, statistics, and data analysis. Objects, functions, and packages can easily be created by R.\nIt’s a platform-independent language. This means it can be applied to all operating systems.\nIt’s an open-source free language. That means anyone can install it in any organization without purchasing a license.\nR programming language is not only a statistic software but also allows us to integrate with other languages (C, C++). Thus, we can easily interact with many data sources and statistical tools.\nThe R programming language has a vast community of users and it’s growing day by day.\nR is currently one of the most requested programming languages in the Data Science job market that makes it the hottest trend nowadays."
  },
  {
    "objectID": "introduction.html#starting-r-rstudio",
    "href": "introduction.html#starting-r-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.3 Starting R & RStudio",
    "text": "1.3 Starting R & RStudio\nAfter the RStudio installation is finished, click the RStudio icon \nR starts automatically when we open RStudio Figure 1.2 and we are greeted by three panes:\n\n\nFigure 1.2: RStudio Screenshot with Console on the left and Help tab in the bottom right.\n\n\nThe three main panes that divide the screen are:\n\nthe large Console pane on the left runs R code.\n\nthe workspace pane, which includes the Environment and History tabs, in the upper right.\n\nThe Environment tab keeps track of the objects we create as we work with R (a major part of our tasks involves creating objects).\nThe History tab tracks all of the commands that we have sent to the R console in the session.\n\n\n\nthe Files/Plots/Packages/Help/Viewer pane in the lower right.\n\nThe Files tab lets us create new folders (directories) on our computer, as well as copy, move, delete, or rename files.\nThe Plots tab holds graphs and charts we generate from our data and during the analysis.\nThe Packages tab lists of all the R packages installed on our hard drive and indicates whether or not they are currently loaded. We’ll discuss packages in more detail in the next sections.\nThe Help tab, provides links to search for help directly from our RStudio window.\nThe Viewer tab in RStudio allows us to view local web content (e.g., to view an html table).\n\n\n\nThroughout this textbook, we’ll come to learn what purpose each of these panes serve.\n\n\n\n\n\n\nCommand prompt  >\n\n\n\nThe Console pane starts with information about the version number, license and contributors, and provides some guidance on how to get help. The last line is a standard command prompt (the greater than sign > symbol) that indicates R is ready and expecting instructions to do something.\n\n\n \nLet’s type 14 + 16 at the R command prompt and press Enter:\n\n14 + 16\n\n[1] 30\n\n\nSo what happened?\nWell, R gave us a response (output) to our input (14 + 16). That response came after we pressed the Enter key. It was [1] 30. It’s clear that 30 is the answer to the 14 + 16. However, what does the [1] mean? At this point we can pretty much ignore it, but technically it refers to the index of the first item on each line. (Sometimes R prints out many lines as an output. The number inside the brackets helps us figure out where in the sequence we are per line)."
  },
  {
    "objectID": "introduction.html#r-scripts",
    "href": "introduction.html#r-scripts",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.4 R scripts",
    "text": "1.4 R scripts\nOpen a new R script\nUsually, we do our programming by writing our code in script files. An R script (with the .R extension) is simply a text file in which our R code is stored, and then can be “sent” to the console, where R will execute it.\nIn the RStudio menu, we go to:\n\n\n\n\n\nflowchart LR\n  A[File] -.-> B(New File) -.-> C(R Script)\n\n\n\n\n\n\n\n\nAnother pane (Q1) is opened on the left above the interactive console Figure 1.3. This is where we can write a length script with lots of lines of code, and save the file for future use.\n\n\nFigure 1.3: RStudio Screenshot with four panes.\n\n\nTherefore, the RStudio window is divided into four panes (quadrants) that contain:\n\nQ1 - code editor (script)\nQ2 - console\nQ3 - environment (workspace), history\nQ4 - files, plots, packages, help, viewer (for local web content)\n\nWe can change the shape of the panes by either clicking the minimize or maximize buttons on the top right of each pane, or by clicking and dragging the middle of the borders of the windows.\nThe four panes might be in a different order that those in Figure 1.3. If we’d like, we can change the order of the windows under RStudio preferences. We select from RStudio menu:\n\n\n\n\n\nflowchart LR\n  A[Tools] -.-> B(Global Options) -.-> C(Pane layout)\n\n\n\n\n\n\n\n\n \nExecute the code written in R script\nNow, let’s type 14 + 16 at a new R script and press the run button . The result is printed in the console:\n\n\nFigure 1.4: The script pane.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn .R script, we can execute our code line by line (by putting the cursor on the line) or selecting a chunk of lines (by highlighting the text) and pressing the run button in the source window. We can also run our selected code using the keywboard shortcut Ctrl + Enter.\n\n\nComments can also be used to explain R code, and to make it more readable (it can also be used to prevent execution when testing alternative code). Comments start with a # . When executing the R-code, R will ignore anything that starts with #. It is considered good practice to comment our code when working in an .R script.\nKeyboard Shortcut for commenting out/commenting in multiple lines at a time: Control+Shift+C\n \n\n\n\n\n\n\nAdvantages writing our R code as an R script file\n\n\n\n\nWe can save and reuse our code\nWe can document our work (however, we can only include one-line comments and these must be prefixed with the hash symbol,  #)\nWe can share our work with others\nWe can move beyond writing one line of code at a time"
  },
  {
    "objectID": "introduction.html#errors-warnings-and-messages-in-r",
    "href": "introduction.html#errors-warnings-and-messages-in-r",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.5 Errors, warnings, and messages in R",
    "text": "1.5 Errors, warnings, and messages in R\nLet’s type the following at the R command prompt and press Enter:\n\nhello\n\nwe get the following error:Error: object ‘hello’ not found\nOne thing that intimidates new R and RStudio users is how it reports errors, warnings, and messages. R reports errors, warnings, and messages in a glaring red font, which makes it seem like it is scolding us. However, seeing red text in the console is not always bad.\nR will show red text in the console pane in three different situations:\n\nErrors: When the red text is a legitimate error, it will be prefaced with “Error…” and try to explain what went wrong. Generally when there’s an error, the code will not run.\nWarnings: When the red text is a warning, it will be prefaced with “Warning:” and R will try to explain why there’s a warning. Generally our code will still work, but with some caveats.\nMessages: When the red text doesn’t start with either “Error” or “Warning”, it’s just a friendly message.\n\nNow, let’s type the following:\n\n1 + 2 -\n+\n\n\n\n\n\n\n\nIf a command is not complete then R will show a Plus sign (+) prompt\n\n\n\nIf an R command is not complete then R will show a plus sign (+) prompt on second and subsequent lines until the command syntax is correct (this means that we can type something to finish the command we are trying to execute). We can also hit the escape key (ESC) to cancel whatever command R is waiting for us to finish."
  },
  {
    "objectID": "introduction.html#r-help-resources",
    "href": "introduction.html#r-help-resources",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.6 R Help resources",
    "text": "1.6 R Help resources\nBefore asking others for help, it’s generally a good idea for us to try to help ourself. It is strongly recommended to learn how to use R’s useful and extensive built-in help system which is an essential part of finding solutions to our R programming problems.\nWe can use the help() function or ? help operator which provide access to the R documentation pages for a specific term. For example, if we want information for the mean we type the following commands (which give the same result):\n\nhelp(mean)\n\nor\n\n?mean\n\n\n\nFigure 1.5: R help() function search for specific term such as mean\n\n\nSo, R tried to find something called mean (Figure 1.5).\n\n\n\n\n\n\nRecall a previously typed command in console\n\n\n\nIn console to recall a previously typed commands use the up arrow key (\\(\\uparrow\\)). To go between previously typed commands use the up and down arrow (\\(\\downarrow\\)) keys. To modify or correct a command use the left (\\(\\leftarrow\\)) and right arrow (\\(\\rightarrow\\)) keys.\n\n\nTwo question marks (??) will search R documentation for a phrase or term and it is a shortcut to help.search() function. So for example, let’s say we want to search documentation for linear regression analysis. Keep in mind if our phrase is more than one word long, we must put it in quotation marks.\n\n??\"linear regression\"\n\nTo do a keyword search use the apropos() command with the keyword in double quotes, \"keyword\", or single quote, 'keyword'. For example:\n\napropos(\"mean\")\n\nUse the example() command to run the examples at the end of the help for a function:\n\nexample(mean)\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nRStudio also provides search box in the “Help” tab to make our life easier (Figure 1.2).\nLike Google, but for R is the RSeek.Org. This is not included in R but is a great search engine built specifically for R-related queries.\nAdditionally, there are a lot of on-line resources that can help (e.g., R-bloggers). However, we must understand that blindly copying and pasting could be harmful and further it won’t help us to learn and develop."
  },
  {
    "objectID": "introduction.html#working-with-rstudio-projects",
    "href": "introduction.html#working-with-rstudio-projects",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.7 Working with RStudio Projects",
    "text": "1.7 Working with RStudio Projects\nWhen we are working in R, the program needs to know where to find inputs and deliver outputs, and will look first in what is called a “working directory”. Moreover, we want to organize all of the files for a given project in one folder, and that particular folder should be established as our working directory.\nCreate a new RStudio Project\nKeeping all the files associated with a project organized together – input data, R scripts, documents and figures – is such a wise and common practice that RStudio has built-in support for this via its projects. RStudio projects are associated with R working directories Figure 1.6.\nWe can create an RStudio project:\n\nIn a new directory\nIn an existing directory where we already have R code and data\nBy cloning a version control (Git or Subversion) repository\n\nLet’s create one to use for the rest of this textbook. From the RStudio menu:\n\n\n\n\n\nflowchart LR\n  A[File] -.-> B(New Project)\n\n\n\n\n\n\n\n\nThe directory name we choose here will be the project name. We call it whatever we want (e.g., introR).\n\n\nFigure 1.6: RStudio projects are associated with R working directories\n\n\n\n\n\n\n\n\nStore the RStudio Project somewhere sensible\n\n\n\nWe must think carefully in which subdirectory we will create the RStudio project. If we don’t store it somewhere sensible, it will be hard to find it in the future!\n\n\n \nRStudio Project folder structure\nThe files on our computer are organised into folders. RStudio Projects live in our computer’s normal folders - they placemark the working directory of each analysis project. These project folders can be viewed or moved around the same way we normally work with files and folders on our computer.\nThe proposed RStudio Project should contain the following sub-folders Figure 1.7:\n\ndata: data files of any kind, such as .csv, .xlsx, .txt, etc.\ndocuments: documents of any formats, such as .docx, .pdf, .tex, .Rmd, etc.\nfigures: plots, diagrams, and other figures\nscripts: all your R scripts and codes (.R extension)\n\nAdditionally, there are two important files in the project folder that are created automatically by Rstudio: name_of_project.Rproj, and .Rhistory:\n\nname_of_project.Rproj: contains options and meta-data of the project (encoding, the number of spaces used for indentation, whether or not to restore a workspace with launch, etc) and can also be used as a shortcut for opening the project directly from the filesystem.\n.Rhistory: contains a history of code executed\n\n\n\nFigure 1.7: Project folder structure\n\n\nIt is recommended to work with RStudio Projects. This enables us to switch between different projects without getting the data, scripts, or output files all mixed up. Everything gets read in or saved to the correct place. No more exporting a plot and then going through the various Documents, etc., folders on our computer trying to figure out where our plot might have been saved to. It got saved to the project folder."
  },
  {
    "objectID": "introduction.html#quitting-r-rstudio",
    "href": "introduction.html#quitting-r-rstudio",
    "title": "1  Introduction to R and Rstudio",
    "section": "\n1.8 Quitting R & RStudio",
    "text": "1.8 Quitting R & RStudio\nWhen we quit RStudio we will be asked whether to save workspace with two options:\n\n“Yes” – Our current R workspace (containing the work that we have done) will be restored next time we open RStudio.\n“No” – We will start with a fresh R session next time we open RStudio. For now select “No” to prevent errors being carried over from previous sessions."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "2  R functions",
    "section": "",
    "text": "In programming, we use functions to incorporate sets of commands that we want to use repeatedly or that, because of their complexity, are better self-contained in a sub program and called when needed.\nWe have already used some R functions searching for help (i.e., help(), example(), apropos()). Most of the computations in R involves using functions. The base version of R includes many other functions, and thousands of others can be added (by installing packages or by creating them from scratch).\nwhere arg1, arg2, … are called the arguments of the function, whereas value1 is the value given to the argument arg1, etc."
  },
  {
    "objectID": "functions.html#characteristics-of-r-functions",
    "href": "functions.html#characteristics-of-r-functions",
    "title": "2  R functions",
    "section": "\n2.1 Characteristics of R Functions",
    "text": "2.1 Characteristics of R Functions\nA. Name and argumnets of a function\n\nA function essentially has a name and a list of arguments separated by a comma.\n\nLet’s have look at an example:\n\nseq(from = 5, to = 8, by = 0.5)\n\n[1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\n\nThe function name is seq and it has three explicitly named arguments from, to and by. The arguments from and to are the start and end values of a sequence that we want to create, and by is the increment of the sequence.\nThe above result can also be obtained without naming the arguments as follows:\n\nseq(5, 8, 0.5)\n\n[1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0\n\n\n\n\n\n\n\n\nName the arguments in the functions\n\n\n\nWe do not necessarily need to indicate the names of the arguments, but only the values, as long as we follow their order. However, it’s a good idea to name at least some of the arguments in the functions. This practice minimizes errors assigning unnamed arguments to options and makes code more readable.\n\n\n \nB. Positional matching of arguments\nAnd what about this?\n\nseq(5, 8)\n\n[1] 5 6 7 8\n\n\nThis result demonstrates something about how R resolves function arguments.\n\nIf we don’t use argument names, R will match the arguments in the order that they appeared (positional matching).\n\nHere, it is assumed that we want a sequence from = 5 that goes to = 8. Since we didn’t specify step size, the default value of by in the function definition is used, which ends up being 1 in this case.\nMoreover, the seq() function has other arguments that we could use which are documented in the help page running ?seq. For example, we could use the argument length.out (instead of by) to fix the length of the sequence as follows:\n\nseq(from = 5, to = 8, length.out = 26)  # 26 elements in the sequence\n\n [1] 5.00 5.12 5.24 5.36 5.48 5.60 5.72 5.84 5.96 6.08 6.20 6.32 6.44 6.56 6.68\n[16] 6.80 6.92 7.04 7.16 7.28 7.40 7.52 7.64 7.76 7.88 8.00\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe numbers inside the brackets, [1] and [16], helps us figure out where in the sequence we are per line. For example, [16] is the id number of the first value (6.80) returned on the second line. Obviously, this number may change depending on the width of the console.\n\n\n \nC. Required and optional arguments\n\nSome arguments in a function are required while others may be optional. We can use args() for displaying the argument names and corresponding default values of a function.\n\nLet’s see for example the log() function:\n\nargs(log)\n\nfunction (x, base = exp(1)) \nNULL\n\n\nIn the log() function x is a required argument while base is an optional argument and comes with a default value exp(1).\nIf we don’t supply a value for base, R will use the default value exp(1):\n\nlog(15)  # R uses the default value of `exp(1)`\n\n[1] 2.70805\n\n\nOtherwise, R will use for base the value that we supply:\n\nlog(15, base = 10)  # R uses our value 10\n\n[1] 1.176091\n\n\nIn contrast, x is a required argument because if we don’t supply x argument the log() function will fail:\n\nlog(base=10)\n\nError: argument x is missing, with no default\n\n\n\n\n\n\nRequired and optional arguments\n\n\n\nFor R functions, some arguments must be specified (they are required) and others are optional (because a default value is already given in the code of the function).\n\n\n \n\n\n\n\n\n\nPlaying with the arguments in several different ways\n\n\n\nTo calculate the natural logarithm of 3, any of the following expressions can be used:\n\nlog(3)\nlog(x=3)\nlog(x=3, base=exp(1))\nlog(x=3, exp(1))\nlog(3, base=exp(1))\nlog(3, exp(1))\n\nlog(base=exp(1), 3)\nlog(base=exp(1), x=3)\n\n\n\n \n\n\n\n\n\n\nCaution\n\n\n\nNote that calling\n\nlog(exp(1), 3)\n\ncalculates the logarithm of exp(1) in base 3.\n\n\n \nNot all functions have (or require) arguments.\nFor example:\n\ndate()\n\n[1] \"Fri Sep 23 06:35:44 2022\"\n\n\n \nD. Functions “live” in packages\n\nFunctions “live” in Base R and in R packages!\n\n\n\nFigure 2.1: Functions live inside the R packages that can be downloaded from the internet"
  },
  {
    "objectID": "functions.html#mathematical-functions",
    "href": "functions.html#mathematical-functions",
    "title": "2  R functions",
    "section": "\n2.2 Mathematical functions",
    "text": "2.2 Mathematical functions\nR has many built in mathematical functions such as the log(x) that we have already seen.\nLogarithms and exponentials\n \n\n\nFigure 2.2: The natural logarithm function ln(x) is the inverse of the exponential function y = e^x\n\n\n\n\nTable 2.1: The Four Basic Properties of Logs\n\nRule name\nRule\n\n\n\nLogarithm product\n\\(log_b(x*y) = log_bx + log_by\\)\n\n\nLogarithm quotient rule\n\\(log_b(x/y) = log_bx - log_by\\)\n\n\nLogarithm power rule\n\\(log_b(x^y) = y \\cdot log_b(x)\\)\n\n\nLogarithm base change rule\n\\(log_b(x) = log_c(x) / log_c(b)\\)\n\n\n\n\n \n\n\n\n\n\n\nExamples: Logarithms and exponentials\n\n\n\n\nlog(100) # natural logarithm ln(x)\n\n[1] 4.60517\n\nlog10(100) # base-10 logarithm\n\n[1] 2\n\nexp(0.5) # exponential e^(1/2)\n\n[1] 1.648721\n\n\n\n\n \nTrigonometric functions\nTrigonometric functions define the relationship among the sides and angles of a right angle triangle (Figure 2.3 (a)). They also allow us to use angle measures, in radians or degrees, to find the coordinates of a point on a circle (e.g., unit circle)(Figure 2.3 (b)).\n\n\n\n\n(a) Right-Angled Triangle\n\n\n\n\n(b) Trigonometric circle\n\n\n\nFigure 2.3: Basic Trigonometry\n\n\nThe main functions in trigonometry are sine, cosine and tangent.\n\\[ sin(\\theta)=\\frac{opposite}{hypotenuse}  \\tag{2.1}\\] \\[ cos(\\theta)=\\frac{adjacent}{hypotenuse}  \\tag{2.2}\\] \\[ tan(\\theta)=\\frac{opposite}{adjacent}  \\tag{2.3}\\]\n \n\n\n\n\n\n\nExamples: Trigonometric functions in R (angles in radians)\n\n\n\n\nsin(pi/2)  # pi equals to 3.14\n\n[1] 1\n\ncos(pi)\n\n[1] -1\n\ntan(pi/3)\n\n[1] 1.732051\n\n\n\n\n \nOther mathematical functions\n\n\n\n\n\n\nExamples: Other mathematical functions\n\n\n\n\nsqrt(9)       # squared root\n\n[1] 3\n\nabs(-9)       # absolute value\n\n[1] 9\n\nsign(-9)      # the sign of the value, -1, 0, or 1\n\n[1] -1\n\nfactorial(3)  # factorial 3! = 1x2x3\n\n[1] 6\n\nchoose(6, 2)  # number of combinations without replacement 6!/(6-2)!2!\n\n[1] 15\n\n\n\n\n \nThe round() function\nThe round() function is often very useful. The round function follows the rounding principle. By default, we will get the nearest integer. For example:\n\nround(7 / 3)  # rounding 7/3 (2.333) to the nearest integer\n\n[1] 2\n\n\nIf we want to control the approximation accuracy, we can add a digits argument to specify how many digits we want after the decimal point. For example:\n\nround(7 / 3, digits = 2)  # rounding 7/3 to two decimal places\n\n[1] 2.33\n\n\n \n\n\n\n\n\n\nRound rule when the dropped digit is 5\n\n\n\nIf the first digit that is dropped is exactly 5, R uses a rule that’s common in programming languages: Always round to the nearest even number. For example:\n\nround(1.5)\n\n[1] 2\n\nround(2.5)\n\n[1] 2\n\nround(4.5)\n\n[1] 4\n\nround(5.5)\n\n[1] 6\n\n\n\n\nThere are a couple of further functions that can be useful:\n\nceiling(16.2)       # round to the nearest integer above\n\n[1] 17\n\nfloor(16.2)         # round to the nearest integer below\n\n[1] 16\n\ntrunc(125.2395)     #  truncates that values in the decimal places\n\n[1] 125\n\nsignif (2718214, 3)  # round to the specified number of significant digits\n\n[1] 2720000"
  },
  {
    "objectID": "functions.html#the-sessioninfo-and-option-functions",
    "href": "functions.html#the-sessioninfo-and-option-functions",
    "title": "2  R functions",
    "section": "\n2.3 The sessionInfo() and option() functions",
    "text": "2.3 The sessionInfo() and option() functions\nWe can obtain information about R, the OS and attached or loaded packages running the following function:\n\nsessionInfo()\n\n \nAdditionally, the options() function in R can be used to change various default behaviors. For example, the digits argument controls the number of digits to display in output. The current options are returned when options() is called, to allow them to be restored. The command help(options) lists all of the set table options.\n\nhelp(options)"
  },
  {
    "objectID": "functions.html#user-defined-functions-udf",
    "href": "functions.html#user-defined-functions-udf",
    "title": "2  R functions",
    "section": "\n2.4 User Defined Functions (UDF)",
    "text": "2.4 User Defined Functions (UDF)\nWe can create our own functions, using the function(), which is a very powerful way to extend R. Figure 2.4 displays the syntax for creating an R function.\n \n\n\nFigure 2.4: The syntax of a function in R\n\n\n \n\n\n\n\n\n\nWhat do we need to create a function?\n\n\n\n\nthe function’s name\nthe arguments of the function\nthe code of the function (statements)\n\n\n\nFor example a function that convert Celsius to Kelvin is:\n\ncelsius_to_kelvin <- function(temp_C) {\n  temp_K <- temp_C + 273.15\n  return(temp_K)\n}\n# freezing point of water in Kelvin\ncelsius_to_kelvin(0)\n\n[1] 273.15\n\n\nWe defined the function by “assigning” the function(temp_C) to the name celsius_to_kelvin using the assignment operator <- (see Chapter 5).\nSo, in most cases, a function has a name (e.g., celsius_to_kelvin), some arguments used as input to the function, within the () following the keyword ‘function’ (e.g., temp_C); a body, which is the code within the curly braces {}, where we carry out the computation; and can have one or more return values (the output here is the temp_K which is a numeric value).\n\n\n\n\n\n\n Function components\n\n\n\n\n\nA function has three components:\n\nThe formals(), the list of arguments that control how you call the function.\nThe body(), the code inside the function.\nThe environment(), the data structure that determines how the function finds the values associated with the names.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where we defined the function. The function environment always exists, but it is only printed when the function isn’t defined in the R global environment. For example:\n\nformals(celsius_to_kelvin)         # the argument of the function\n\n$temp_C\n\nbody(celsius_to_kelvin)            # the code of the function\n\n{\n    temp_K <- temp_C + 273.15\n    return(temp_K)\n}\n\nenvironment(celsius_to_kelvin)     # the function's environment\n\n<environment: R_GlobalEnv>"
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "3  R packages",
    "section": "",
    "text": "R installs automatically a set of standard packages (base packages) during installation process. Base packages contain the basic functions that allow R to work, and enable standard statistical and graphical functions on data sets.\n\nMore packages can be added later from repositories, when they are needed for some specific purpose (add-on R packages). Add-on R packages are written by a world-wide community of developers and R users and most of them can be installed for free from repositories.\nA repository is a place where packages are located and stored so we can install them from it. Some of the most popular repositories for R packages are:\n\nCRAN: Comprehensive R Archive Network(CRAN) is the official repository.\nGithub: Github is the most popular repository for open source projects.\nBioconductor: Bioconductor is a topic-specific repository, intended for open source software for bioinformatics.\n\n \n\n\n\n\n\n\nAdd-on R packages\n\n\n\nAdd-on R packages extend the functionality of R by providing additional collection of functions, sample data, compiled code, some tests to check everything works as it should, and documentation for the package and the functions inside in a well-defined format.\n\n\nTo use an add-on package we need to:\n\nInstall the package from a repository. Once we’ve installed a package, we likely won’t install it again unless we want to update it to a newer version.\nLoad the package in R session. Add-on packages are not loaded by default when we start RStudio on our computer. Each add-on package needs to be loaded explicitly every time we start RStudio.\n\nFor example, among the many add-on packages, we will use in this textbook are the dplyr package for data wrangling, the ggplot2 package for data visualization and and the rstatix package for statistical tests.\nLet’s now show how to perform these two steps for the ggplot2 package for data visualization."
  },
  {
    "objectID": "packages.html#package-installation",
    "href": "packages.html#package-installation",
    "title": "3  R packages",
    "section": "\n3.2 Package installation",
    "text": "3.2 Package installation\nThere are two ways to install an add-on R package: an easy way and a more advanced way.\nA. Installing Packages Using RStudio UI\nLet’s install the rstatix package the easy way first as shown in Figure Figure 3.1. In the Q4 - files, plots, packages, help pane of RStudio:\n\nClick on the “Packages” tab.\nClick on “Install”.\nType the name of the package under “Packages (separate multiple with space or comma):” In this case, type rstatix.\nClick “Install.”\n\n\n\nFigure 3.1: Installing packages in R the easy way\n\n\nB. Installing packages from repositories using command\nFor installing the rstatix package from CRAN we type the following command in the console pane of RStudio and press Enter on our keyboard:\n\ninstall.packages(\"rstatix\")\n\nNote we must include the quotation marks around the name of the package.\nIn order to install several package at once, we just have to write:\n\ninstall.packages(c(\"rstatix\", \"dplyr\", \"ggplot2\"))\n\nWe only have to install a package once. However, if we want to update a previously installed package to a newer version, we need to re-install it by repeating the earlier steps.\nMoreover, suppose, for instance, that we want to download the development version of the rstatix package from GitHub. The first step is to install and load the devtools package, available in CRAN. On Windows, in case we encounter some error means we also need to install the Rtools. Then we can call the install_github() function to install the R package from GitHub.\nIn case we need to install an older version of a package the simplest method is to use the provided install_version() function of the devtools package to install the version we need."
  },
  {
    "objectID": "packages.html#package-loading",
    "href": "packages.html#package-loading",
    "title": "3  R packages",
    "section": "\n3.3 Package loading",
    "text": "3.3 Package loading\nRecall that after we’ve installed a package, we need to load it. In other words, we need to “open it.” We do this by using the library() command (note that the the quotation marks are not necessary when we are loading a package). For example, to load the rstatix package, run the following code in the console pane.\n\nlibrary(rstatix)\n\nIf after running the earlier code, a blinking cursor returns next to the > “prompt” sign in console, it means we were successful and the rstatix package is now loaded and ready to use. If however, we get a red “error message” that reads…\nError in library(rstatix) : there is no package called ‘rstatix’\n… it means that we didn’t successfully install it.\nThere is one way in R that can use a function without using library(). To do this, we can simply use the notation package::function .\nFor example:\n\nrstatix::t_test()\n\nThe above notation tells R to use the t_test function from rstatix without load the rstatix package.\n \n\n\n\n\n\n\nPackages Vs Libraries\n\n\n\nThere is always confusion between a package and a library, and we find people calling libraries as packages. The directories in R where the packages are stored are called the libraries."
  },
  {
    "objectID": "packages.html#the-tidyverse-package",
    "href": "packages.html#the-tidyverse-package",
    "title": "3  R packages",
    "section": "\n3.4 The {tidyverse} package",
    "text": "3.4 The {tidyverse} package\nIn this textbook we will use the tidyverse package. The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\nThe command install.packages(\"tidyverse\") will install the complete tidyverse. The tidyverse package provides a shortcut for downloading the following packages:\n\n\n [1] \"broom\"         \"cli\"           \"crayon\"        \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"readr\"        \n[21] \"readxl\"        \"reprex\"        \"rlang\"         \"rstudioapi\"   \n[25] \"rvest\"         \"stringr\"       \"tibble\"        \"tidyr\"        \n[29] \"xml2\"          \"tidyverse\"    \n\n\nWhen we load the tidyverse package with the command library(tidyverse), R will load the core tidyverse and make it available in our current R session (Figure 3.2):\n\n\nFigure 3.2: Hex logos for the eight core tidyverse packages and their primary purposes (Image from Mine Çetinkaya-Rundel).\n\n\n\n\n\n\n\n\nAdd-on R packages\n\n\n\nThe tidyverse packages out of the core list have more specialized usage and are not loaded automatically with library(tidyverse), so we’ll need to load each one with its own call to library()."
  },
  {
    "objectID": "packages.html#the-here-package",
    "href": "packages.html#the-here-package",
    "title": "3  R packages",
    "section": "\n3.5 The {here} package",
    "text": "3.5 The {here} package\nWe’ve talked about what Projects are and why we should use them, but what really makes Projects in RStudio shine is the use of the here() function from the {here} package. What here() does is eliminate the need for us to do what’s called “hard-coding” our file path.\n\nThe place where the file lives on our computer is called the path. We can think of the path as directions to the file. There are two kinds of paths: absolute paths and relative paths.\n\nFor example, suppose Alice and Bob are working on a project together and want to read in R studio of their computers a data set file named covid19.csv data. They could do this using either a relative or an absolute path. We show what both choices below:\nA. Reading data using an absolute path\nAlice’s file is stored at C:/alice/project/data/covid19.csv\nand the command in R script should be:\n\ncovid19 <- read_csv(\"C:/alice/project/data/covid19.csv\")  \n\nwhile Bob’s is stored at C:/bob/project/data/covid19.csv\nand the command in R script should be:\n\ncovid19 <- read_csv(\"C:/bob/project/data/covid19.csv\")\n\nEven though Alice and Bob stored their files in the same place on their computers (in their C disk), the absolute paths are different due to their different usernames. If Bob has code that loads the covid19.csv data using an absolute path, the code won’t work on Alice’s computer.\n \nB. Reading data using a relative path\nThe command in R script should be:\n\ncovid19 <- read_csv(here(\"data\", \"covid19.csv\"))\n\nWhat here() does is tell R that the file structure starts at the Project-level, and so every subsequent call starts at the Project-level, and allows us to navigate throughout each of the folders and files within a given Project.\nThe relative path from inside the project folder (data/covid19.csv) is the same on both computers; any code that uses relative paths will work on both!"
  },
  {
    "objectID": "packages.html#the-reprex-package",
    "href": "packages.html#the-reprex-package",
    "title": "3  R packages",
    "section": "\n3.6 The {reprex} package",
    "text": "3.6 The {reprex} package\nIf we are looking for help with an rstats problem, it is recommend that we:\n  do not email an individual author or open source software (OSS) maintainer\n   create a minimum reproducible example (a reprex) demonstrating your problem\n   post on a public forum like RStudio Community or Stack Overflow\nWhat is a reprex?\nThe purpose of a reprex is to illustrate a particular outcome. The reader should know what outcome to expect. The reprex should do that one thing, and only that thing.\nThe reprex should be able to be run by any user who so wishes and return the exact same result.\nIt contains only the functions that are absolutely necessary to illustrate the point. If this is in the context of data analysis, the included dataset is as small as possible.\nWhy would we need a reprex?\n\nTo demonstrate an issue or bug in our code\nTo demonstrate a solution to an issue or bug in someone else’s code\nTo document a useful snippet of code for future reference\nUsing the reprex package\nIf we install reprex package we can use a function, reprex() to generate clean example code, with commented output. Of course, we need to create the minimal code our-self, but once we have it, calling the reprex function adds in the output so that others can see exactly what our computer returned. It’s a minor change but can make all the difference to someone who wants to help us.\n\n\nFigure 3.3: A reprex example."
  },
  {
    "objectID": "calculations.html",
    "href": "calculations.html",
    "title": "4  Calculations in R",
    "section": "",
    "text": "The simplest thing we could do with R is arithmetic operations with numbers. For example:\n\n1 + 100 \n\n[1] 101\n\n\nR printed out the result, with a preceding [1].\n \nIn the previous calculation the + sign was used to carry out the addition. Table 4.1 presents a list of arithmetic operators available in R.\n\n\nTable 4.1: Arithmetic Operators in R\n\nOperator\nDescription\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^\nexponent\n\n\n%%\nmodulus (remainder from division)\n\n\n%/%\ninteger division\n\n\n\n\nRemember when using R as a calculator, the order of operations is the same as we would have learned back in school.\nFrom highest to lowest precedence:\n\nParentheses: ( )\n\nExponents: ^ or **\n\nDivision: /\n\nMultiplication: *\n\nAddition: +\n\nSubtraction: -\n\n\nTherefore:\n\n3 + 5 * 2\n\n[1] 13\n\n\n \n\nUse parentheses to group operations in order to force the order of evaluation if it differs from the default, or to make clear what we intend.\n\n(3 + 5) * 2\n\n[1] 16\n\n\nThis can get unwieldy when not needed, but clarifies our intentions. Remember that others may later read our code.\n\n(3 + (5 * (2 ^ 2))) # hard to read\n3 + 5 * 2 ^ 2       # clear, if we remember the rules\n3 + 5 * (2 ^ 2)     # if we forget some rules, this might help\n\n\n\n\n\n\n\nImportant\n\n\n\nRemember that the text after each line of code is a comment. Anything that follows after the hash symbol # is ignored by R when executes code.\n\n\n \n\nSuppose we want to know the integer part of a division: say, how many 13s there are in 119:\n\n119 %/% 13\n\n[1] 9\n\n\nNow suppose we wanted to know the remainder (what is left over when 119 is divided by 13): in maths this is known as 119 modulo 13, and the value 13 is known as the modulus:\n\n119 %% 13\n\n[1] 2\n\n\nModulo is very useful for testing whether one number is an exact multiple of some other number. For example, to find out whether 15421 is a multiple of 7:\n\n15421 %% 7\n\n[1] 0\n\n\nIt is as there is no remainder. We can then carry out more complex modular arithmetic:\n\n(123 + 456) %% 19\n\n[1] 9\n\n\nBut don’t forget to put brackets around the expression for which we want to carry out the modular calculation."
  },
  {
    "objectID": "calculations.html#relational-operators-in-r",
    "href": "calculations.html#relational-operators-in-r",
    "title": "4  Calculations in R",
    "section": "\n4.2 Relational Operators in R",
    "text": "4.2 Relational Operators in R\nRelational (or comparison) operators are used to compare between values. Comparisons in R typically evaluate to TRUE or FALSE (which in certain circumstances we can abbreviate to T and F). Here is a list of relational operators available in R (Table 4.2).\n\n\nTable 4.2: Relational (comparison) operators in R\n\nsymbol\nread as\n\n\n\n<\nless than\n\n\n>\ngreater than\n\n\n==\nequal to\n\n\n<=\nless than or equal to\n\n\n>=\ngreater than or equal to\n\n\n!=\nnot equal to\n\n\n\n\nSome simple comparisons with integer numbers follow:\n\n\n\n\n\n\nExamples\n\n\n\n\n2 < 1  # less than\n\n[1] FALSE\n\n\n\n1 > 0  # greater than\n\n[1] TRUE\n\n\n\n1 == 1  # equal to (double equal sign for equality)\n\n[1] TRUE\n\n\n\n1 <= 1  # less than or equal to\n\n[1] TRUE\n\n\n\n-9 >= -3 # greater than or equal to\n\n[1] FALSE\n\n\n\n1 != 2  # not equal to (inequality)\n\n[1] TRUE"
  },
  {
    "objectID": "calculations.html#floating-point-number",
    "href": "calculations.html#floating-point-number",
    "title": "4  Calculations in R",
    "section": "\n4.3 Floating point number",
    "text": "4.3 Floating point number\nWhen dealing with real numbers floating point number, we must be very careful when checking equality.\nFor example, we know from trigonometry that:\n\\[\\cos(\\frac{\\pi}{2}) = \\cos( \\frac{3 \\pi}{2}) = 0  \\]\nHowever, if we compare the two numbers we get:\n\ncos(pi/2) == cos(3*pi/2)\n\n[1] FALSE\n\n\nIn this instance, we can test for ‘near equality’ applying the all.equal() function which tests for equality with a difference tolerance of 1.5e-8.\n\nall.equal(cos(pi/2), cos(3*pi/2))\n\n[1] TRUE\n\n\nIf the difference is greater than the tolerance level 1.5e-8 the function will return the mean relative difference.\nTry to test this:\n\nall.equal(4.0000007, 4.0000008)\n\n\n\n\n\n\n\nDon’t use == to compare two numbers\n\n\n\nWe should never use == to compare two numbers unless they are integers (whole numbers) or fractions whose denominator is a power of 2 (\\(2^n\\), where n is integer). Computers may only represent decimal numbers with a certain degree of precision (rounded to typically 53 binary digits accuracy which allows representing decimal numbers to 15 or 16 significant digits), so two numbers which look the same when printed out by R, may actually have different underlying representations and therefore be different by a small margin of error (called Machine numeric tolerance)."
  },
  {
    "objectID": "calculations.html#scientific-notation",
    "href": "calculations.html#scientific-notation",
    "title": "4  Calculations in R",
    "section": "\n4.4 Scientific notation",
    "text": "4.4 Scientific notation\nScientific notation is a special way of expressing numbers that are too big or too small to be conveniently written in decimal form. Generally, it expresses numbers in forms of \\(m \\times 10^n\\) and R uses the e notation.\n\n\n\n\n\n\nExamples\n\n\n\n\n0.0055 is written \\(5.5 \\times 10^{-3}\\)\nbecause 0.0055 = 5.5 × 0.001 = 5.5 × \\(10^{-3}\\) or 5.5e-3\n0.000000015 is written \\(1.5 \\times 10^{-8}\\)\nbecause 0.000000015 = 1.5 × 0.00000001 = 1.5 × \\(10^{-8}\\) or 1.5e-8\n5500 is written \\(5.5 \\times 10^{3}\\)\nbecause 5500 = 5.5 × 1000 = 5.5 × \\(10^{3}\\) or 5.5e3\n150000000 is written \\(1.5 \\times 10^{8}\\)\nbecause 150000000 = 1.5 × 100000000 = 1.5 × \\(10^{8}\\) or 1.5e8\n\n\n\n\n\n\n\n\n\nScientific notation Vs Euler’s number\n\n\n\nNote that the e notation has nothing to do with the Euler’s number e=2.718 ."
  },
  {
    "objectID": "calculations.html#special-values-in-r",
    "href": "calculations.html#special-values-in-r",
    "title": "4  Calculations in R",
    "section": "\n4.5 Special values in R",
    "text": "4.5 Special values in R\nThere are a few special values that are used in R.\nMissing values (NA)\nFor example, in the real world, missing values may occur when recording sensor information. R uses a special numeric value NA standing for “Not available” and represents a missing value. Mathematical functions/operations using NA produces NA:\n\ncos(NA)\n\n[1] NA\n\n\n\n1 + NA\n\n[1] NA\n\n\n \nInfinitive: -Inf or Inf\nThere is also a special number Inf which represents infinity. Fortunately, R has special numbers for this.\nThis allows us to represent entities like:\n\n1/0\n\n[1] Inf\n\n\nThe Inf can also be used in ordinary calculations:\n\nexp(-Inf)\n\n[1] 0\n\n\n \nNot A Number (NaN)\nThe value NaN (stands for “not a number”) represents an undefined value and it is usually the product of some arithmetic operations. For example:\n\nInf/Inf\n\n[1] NaN\n\n\n\n0/0\n\n[1] NaN\n\n\n\ncos(Inf)\n\nWarning in cos(Inf): NaNs produced\n\n\n[1] NaN\n\n\n \nNULL\nAdditionally, there is a null object in R, represented by the symbol NULL. (The symbol NULL always points to the same object.) NULL is often used as an argument in functions to mean that no value was assigned to the argument. Additionally, some functions may return NULL. Note that NULL is not the same as NA, Inf, -Inf, or NaN."
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "5  R objects",
    "section": "",
    "text": "R works with objects (it is an object-oriented programming language). All the things that we manipulate or encounter in R such as numbers, data structures, functions, the results from a function (e.g., graphs) are types of objects. Some objects come with the packages in R. Other objects are user-created. User-created objects have names that are assigned by the user. R has a workspace known as the global environment that can be used to store objects.\nObjects in R can have many properties associated with them, called attributes. These properties explain what an object represents and how it should be interpreted by R. Two of the most important attributes of an R object are the class and the dimension of the object.\nAttributes of an object (if any) can be accessed using the attributes() function. Not all R objects contain attributes, in which case the attributes() function returns NULL.\nFor example, the attributes of the famous iris data set is a data.frame that contains 150 rows and 5 columns:\n\nclass(iris); dim(iris)   # Note: R commands can be separated by a semicolon\n\n[1] \"data.frame\"\n\n\n[1] 150   5\n\nattributes(iris)\n\n$names\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n[145] 145 146 147 148 149 150\n\n\n\n\n\n\n\n\nAvoid to separate R commands with a semicolon\n\n\n\nR commands are usually separated by a new line but they can also be separated by a semicolon (;). However, this is bad practice and should be avoided wherever possible: it can lead to code that is difficult to follow."
  },
  {
    "objectID": "objects.html#named-storage-of-objects",
    "href": "objects.html#named-storage-of-objects",
    "title": "5  R objects",
    "section": "\n5.2 Named storage of objects",
    "text": "5.2 Named storage of objects\nAssignment operator (<-)\nIn R we can store things in objects using the leftward assignment operator (<-) which is an arrow that points to the left, created with the less-than (<) sign and the hyphen (-) sign (keyboard shortcut: Alt + - for Windows and Option + - for Mac).\nFor example, suppose we would like to store the number 1/40 for future use. We will assign this value to an object called x:\n\nx <- 1/40\n\nNotice that assignment does not print a value. Instead, R stores it for later in the object x. Call object x now and see that it contains the value 0.025:\n\nx\n\n[1] 0.025\n\n\nIf we look for the Environment tab in one of the panes of RStudio, we will see that x and its value have appeared.\n \n\n\n\n\n\n\nHow to print the results of assignment immediately\n\n\n\nSurrounding the assignment with parentheses results in both assignment and print to screen to happen. For example:\n\n(x <- 1/40)\n\n[1] 0.025\n\n\n\n\n \nOur object x can be used in place of a number in any calculation that expects a number. For example:\n\nlog(x)\n\n[1] -3.688879\n\n\n \n\n\n\n\n\n\nUse space before and after operators (Highly Recommended)\n\n\n\nIt is important the space before and after comparison operators and assignments. For example, suppose we want to code the expression x smaller than -1/50 (note that x is 1/40):\n\n\nWith spaces\n\n\nx < -1/50    # with spaces \n\n[1] FALSE\n\n\nThe result is the logical FALSE because the value x (equals to 1/40) is higher than -1/50.\n\n\nWithout spaces\n\n\nx<-1/50    # without spaces\nx\n\n[1] 0.02\n\n\nIf we omit the spaces we end up with the assignment operator and we have x <- 1/50 which equals to 0.02.\n\n\n \nOther types of assignment\nIt is also possible to use the = or -> rightward operator for assignment (but these are much less common among R users).\nFor example:\n\nx = 1/40\nx\n\n[1] 0.025\n\n\nor\n\n1/40 -> x\nx\n\n[1] 0.025\n\n\nIt is a good idea to be consistent with the operator we use."
  },
  {
    "objectID": "objects.html#reassigning-an-object",
    "href": "objects.html#reassigning-an-object",
    "title": "5  R objects",
    "section": "\n5.3 Reassigning an object",
    "text": "5.3 Reassigning an object\nNotice also that objects can be reassigned. For example, recall the x object:\n\nx\n\n[1] 0.025\n\n\nthen type the following:\n\nx <- 100\nx\n\n[1] 100\n\n\nx used to contain the value 0.025 and now it has the value 100.\nMoreover, assignment values can contain the object being assigned to:\n\nx <- x + 1 \nx\n\n[1] 101\n\n\nThe right hand side of the assignment can be any valid R expression and it is fully evaluated before the assignment takes place."
  },
  {
    "objectID": "objects.html#legal-object-names",
    "href": "objects.html#legal-object-names",
    "title": "5  R objects",
    "section": "\n5.4 Legal object names",
    "text": "5.4 Legal object names\nObject names must start with a letter and can contain letters, numbers, underscores ( _ ) and periods (.). They cannot start with a number or underscore, nor contain spaces at all. Moreover, they can not contain Reserved words.\nDifferent people use different conventions for long object names, these include:\n\nperiods.between.words\nunderscores_between_words\ncamelCaseToSeparateWords\n\nWhat we use is up to us, but we must be consistent. We might ask help:\n\n??make.names\n??clean_names\n\n\n\n\n\n\n\nR is case-sensitive\n\n\n\nR treats capital letters differently from lower-case letters.\n\n\n\nY <- 50\nY\n\nbut…\n\ny\n\nError: object ‘y’ not found"
  },
  {
    "objectID": "objects.html#we-are-not-limited-to-store-numbers-in-objects",
    "href": "objects.html#we-are-not-limited-to-store-numbers-in-objects",
    "title": "5  R objects",
    "section": "\n5.5 We are not limited to store numbers in objects",
    "text": "5.5 We are not limited to store numbers in objects\nIn objects we can also store other data types. For example, we can store strings of characters:\n\nsentence <- \"the cat sat on the mat\"\n\nNote that we need to put strings of characters inside quotes.\n \nBut the type of data that is stored in an object affects what we can do with it:\n\nsentence + 1\n\nError in sentence + 1: non-numeric argument to binary operator"
  },
  {
    "objectID": "vector.html",
    "href": "vector.html",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "vector.html#introduction-to-vectors-in-r",
    "href": "vector.html#introduction-to-vectors-in-r",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.1 Introduction to vectors in R",
    "text": "6.1 Introduction to vectors in R\nThe most fundamental concept in base R are the vectors. Vectors come in two flavours: atomic vectors and lists (generic vectors). The atomic vectors must have all elements of the same basic type (e.g., integers, characters). On the contrary, in the lists different elements can have different types (e.g., some elements may be integers and some characters).\nThe R language supports many types of data structures that we can use to organize and store information. We will see that complex structures such as matrices, arrays, and data frames can be created. Each data structure type serves a specific purpose and can contain specific kinds of data. They differ in terms of the type of data they can hold, how they’re created, their structural complexity, the RAM that they occupy, and the notation used to identify and access individual elements. So, it’s important to understand the differences between them so we can make the right choice based on our scenario. These data structures are schematically illustrated in Figure 6.1\n\n\n\n\nFigure 6.1: Data structures in R."
  },
  {
    "objectID": "vector.html#atomic-vectors",
    "href": "vector.html#atomic-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.2 Atomic vectors",
    "text": "6.2 Atomic vectors\nThere are four primary types of atomic vectors (also known as “atomic” classes):\n\nlogical\ninteger\ndouble\ncharacter (which may contain strings)\n\nCollectively integer and double vectors are known as numeric vectors.\nThere are also two rare types: complex and raw. We won’t discuss them further because complex numbers are rarely needed in statistics, and raw vectors are a special type that’s only needed when handling binary data (raw bytes).\nOne-element atomic vectors\nEach of the four primary types has a special syntax to create an individual value. R has no 0-dimensional or scalar types. Individual numbers or strings, are actually vectors of length one and in some instances we call them scalars.\nTherefore, an one-element vector (oev) is just a single value like a number and they can be used to construct more complex objects (longer vectors). We present some examples of one-element vectors for each of the four primary types (in order from least to most general):\n1. Logical one-element vector: Logical values are boolean values of TRUE or FALSE which can be abbreviated, when we type them as T or F (we do not suggest this).\n\n# Examples of logical one-element vectors (oev)\noev_a <- TRUE  # assign the TRUE value to an object named oev_a\noev_a          # call the object with its name\n\n[1] TRUE\n\noev_b <- FALSE\noev_b\n\n[1] FALSE\n\noev_c <- T\noev_c\n\n[1] TRUE\n\noev_d <- F\noev_d\n\n[1] FALSE\n\n\n \n2. Numeric (integer or double) one-element vector: Even if we see a number like 1 or 2 in R, which we might think of as integers, they are likely represented behind the scenes as 1.00 or 2.00. We need to place an “L” suffix for integer numbers. Doubles can be specified in decimal (e.g., 0.03) or scientific (e.g, 3e-2) format.\n\n# Examples of integer and double one-element vectors (oev)\noev_e <- 3L          # integer\noev_e\n\n[1] 3\n\noev_f <- 100L        # integer\noev_f\n\n[1] 100\n\noev_g <- oev_e / oev_f\noev_g               # double\n\n[1] 0.03\n\noev_scientific <- 3e-2\noev_scientific     # double\n\n[1] 0.03\n\n\n\n\n\n\n\n\nDouble format\n\n\n\nDouble format is a computer number format, usually occupying 64 bits in computer memory.\n\n\n \n3. Character one-element vector: One-element vectors can also be characters (also known as strings). In R, we denote characters using quotation marks ” or ’. Here are examples of character one-element vectors:\n\n# Examples of character one-element vectors (oev)\noev_h <- \"hello\"      # double quotation marks\noev_h\n\n[1] \"hello\"\n\noev_i <- 'covid-19'   # single quotation marks\noev_i\n\n[1] \"covid-19\"\n\noev_j <- \"I love data analysis\"\noev_j\n\n[1] \"I love data analysis\"\n\n\nR treats numeric and character one-element vectors differently. For example, while we can do basic arithmetic operations on numeric one-element vectors – they won’t work on character one-element vectors. If we try to perform numeric operations (like addition) on character one-element vector, we’ll get an error like the following:\n\nh <- \"1\"\nk <- \"2\"\nh + k\n\nError in h + k : non-numeric argument to binary operator\nIf we see an error like this one, it means that we’re trying to apply numeric operations to character objects that’s wrong.\nIt’s very rare that single values (one-element vectors) will be the center of an R session, so one of the first questions encountered when working with data in R is what sort of object should be used to hold collections of data. Next, we are going to talk about “longer” atomic vectors."
  },
  {
    "objectID": "vector.html#making-longer-atomic-vectors",
    "href": "vector.html#making-longer-atomic-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.3 Making longer atomic vectors",
    "text": "6.3 Making longer atomic vectors\nAtomic vectors can consisted of more than one element. In this case, the vector elements are ordered, and they must all be of the same type of data. Common example types of “long” atomic vectors are numeric (whole numbers and fractions), logical (e.g., TRUE or FALSE), and character (e.g., letters or words).\nLet’s see how we can create “long” atomic vectors and some usefull vector properties through examples.\nThe colon operator (:)\n\nThe colon operator : will generate sequences of consecutive values. For example:\n\n1:5\n\n[1] 1 2 3 4 5\n\n\nIn this example, the colon operator : takes two integers 1 and 5 as arguments, and returns an atomic vector of integer numbers from the starting point 1 to the ending point 5 in steps of 1.\nWe can assign (or name) the atomic vector to an object named x_seq:\n\nx_seq <- 1:5\n\nand call it with its name:\n\nx_seq\n\n[1] 1 2 3 4 5\n\n\nWe can determine the type of a vector with typeof().\n\ntypeof(x_seq)\n\n[1] \"integer\"\n\n\nThe elements of the x_seq vector are integers.\nWe can also find how many elements a vector contains applying the length() function:\n\nlength(x_seq)\n\n[1] 5\n\n\nOther examples:\n\n5:1\n\n[1] 5 4 3 2 1\n\n2.5:8.5\n\n[1] 2.5 3.5 4.5 5.5 6.5 7.5 8.5\n\n-3:4\n\n[1] -3 -2 -1  0  1  2  3  4\n\n\n \nThe function seq()\n\nWe have already explore in Chapter 2 the seq() function which creates vectors of consecutive values (seq stands for sequence):\n\nseq(1, 5)    # increment by 1\n\n[1] 1 2 3 4 5\n\n\n \nThe c() function\nWe can also create atomic vectors “by hand” using the c() function (or concatenate command) which combines values into a vector. Let’s create a vector of values 2, 4.5, and 1:\n\nc(2, 4.5, -1)\n\n[1]  2.0  4.5 -1.0\n\n\nOf course, we can have an atomic vector with logical elements as the following example:\n\nc(TRUE, FALSE, TRUE, FALSE)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nor equivalently\n\nc(T, F, T, F)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nand an atomic vector with character elements:\n\nc(\"male\", \"female\", \"female\", \"male\")\n\n[1] \"male\"   \"female\" \"female\" \"male\"  \n\n\n \n\n\n\n\n\n\nNote: An atomic vector can be element of another vector:\n\n\n\n\ny_seq <- 3:7\nc(y_seq, 2, 4.5, -1)  # y_seq is an element of a vector\n\n[1]  3.0  4.0  5.0  6.0  7.0  2.0  4.5 -1.0\n\n\n\n\nRepeating vectors\nThe rep() function allows us to conveniently repeat complete a vector or the elements of a vector. Let’s see some examples:\n1. Repeating the complete vector.\n\nrep(1:4, times = 5)               # 5 times to repeat the complete vector\n\n [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4\n\nrep(c(0, 4, 7), times = 3)        # 3 times to repeat the complete vector\n\n[1] 0 4 7 0 4 7 0 4 7\n\nrep(c(\"a\", \"b\", \"c\"), times = 2)  # 2 times to repeat the complete vector\n\n[1] \"a\" \"b\" \"c\" \"a\" \"b\" \"c\"\n\n\n \n2. Repeating each element of the vector.\n\nrep(1:4, each = 5)               # each element is repeated 5 times\n\n [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4\n\nrep(c(0, 4, 7), each = 3)        # each element is repeated 3 times\n\n[1] 0 0 0 4 4 4 7 7 7\n\nrep(c(\"a\", \"b\", \"c\"), each = 2)  # each element is repeated 2 times\n\n[1] \"a\" \"a\" \"b\" \"b\" \"c\" \"c\"\n\n\n \nDefault vectors\nR comes with a few built-in default vectors, containing useful values:\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nmonth.abb\n\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nWe will use some of these built-in vectors in the examples that follow."
  },
  {
    "objectID": "vector.html#mixing-things-in-a-vector---coercion",
    "href": "vector.html#mixing-things-in-a-vector---coercion",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.4 Mixing things in a vector - Coercion",
    "text": "6.4 Mixing things in a vector - Coercion\nImplicit coercion\nIn general, implicit coercion is an attempt by R to be flexible with data types. When an entry does not match the expected value, R tries to guess what we meant before throwing in an error.\nFor example, R assumes that everything in our atomic vector is of the same data type – that is, all numbers or all characters or all logical elements. Let’s create a “mixed” vector:\n\nmy_vector <- c(1, 4, \"hello\", TRUE)\n\nIn this case, we will not have a vector with two numeric objects, one character object and one logical object. Instead, R will do what it can to convert them all into all the same object type, in this case all character objects. So my_vector will contain 1, 4, hello and TRUE as characters.\nThe hierarchy for coercion is:\nlogical < integer < numeric < character\n\n\n\n\n\n\nExamples\n\n\n\n1. numeric Vs character\n\na <- c(10.5 , 3.2, \"I am a character\")\na\n\n[1] \"10.5\"             \"3.2\"              \"I am a character\"\n\ntypeof(a)\n\n[1] \"character\"\n\n\nAdding a character string to a numeric vector converts all the elements in the vector to character values.\n2. logical Vs character\n\nb <- c(TRUE, FALSE, \"Hello\")\nb\n\n[1] \"TRUE\"  \"FALSE\" \"Hello\"\n\ntypeof(b)\n\n[1] \"character\"\n\n\nAdding a character string to a logical vector converts all the elements in the vector to character values.\n3. logical Vs numeric\n\nd <- c(FALSE, TRUE, 2)\nd\n\n[1] 0 1 2\n\ntypeof(d)\n\n[1] \"double\"\n\n\nAdding a numeric value to a logical vector converts all the elements in the vector to double (numeric) values. Logical values are converted to numbers as folowing: TRUE is converted to 1 and FALSE to 0.\n\n\nExplicit coercion\nR also offers functions to force a specific coercion (explicit coercion). For example, we can turn numbers into characters with the as.character() function. Let’s create a numeric vector f, with numbers 1 through 5, and convert it to a character vector g:\n\nf <- 1:5\n\ng <- as.character(f)\ng\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nWe can turn the characters back to numbers using the as.numeric() function which converts characters or other data types into numeric:\n\nas.numeric(g)\n\n[1] 1 2 3 4 5\n\n\nThis function is actually quite useful in practice, because many public datasets that include numbers, include them in a form that makes them appear to be character strings.\nNow, suppose we define an object q of character strings “1”, “b”, “3” and we want to convert them to numbers using the as.numeric() function:\n\nq <- c(\"1\", \"b\", \"3\")\n\nas.numeric(q)\n\nWarning: NAs introduced by coercion\n\n\n[1]  1 NA  3\n\n\nAs we can see R is able to convert the strings “1” and “3” to the numeric values 1 and 3, but it does not know what to do with “b”. As a result, if we call as.numeric() on this vector, we get a warning that NAs introduced by coercion (the element “b” was converted to a missing value NA).\nMoreover, when nonsensical coercion takes place, we will usually get a warning from R. For example:\n\nx_abc <- c(\"a\", \"b\", \"c\")\nas.numeric(x_abc)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA NA NA"
  },
  {
    "objectID": "vector.html#sort-rank-and-order-numeric-vectors",
    "href": "vector.html#sort-rank-and-order-numeric-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.5 Sort, rank, and order numeric vectors",
    "text": "6.5 Sort, rank, and order numeric vectors\nWe have learned how to create atomic vectors of different types including numeric, character and logical. In addition, we know how to create atomic vectors with patterns and how coercion works. An atomic vector usually contains more than one elements. Sometimes, we want to order the elements in various ways. In this section, we will introduce important functions that relate to ordering elements in an atomic vector.\nFirstly, let’s create a numeric vector which will be used throughout this part.\n\nnum_vect <- c(2, 3, 2, 0, 4, 7) \nnum_vect \n\n[1] 2 3 2 0 4 7\n\n\nSort vectors\nThe first function we will introduce is sort(). By default, the sort() function sorts elements in vector in the ascending order, namely from the smallest to largest.\n\nsort(num_vect)\n\n[1] 0 2 2 3 4 7\n\n\nIf we want to sort the vector in the descending order, namely from the largest to smallest, we can set a second argument decreasing = TRUE.\n\nsort(num_vect, decreasing = TRUE)\n\n[1] 7 4 3 2 2 0\n\n\nRanks of vectors\nNext, let’s talk about ranks. The rank() function references the position of the value in the sorted vector and is in the same order as the original sequence.\n\nnum_vect\n\n[1] 2 3 2 0 4 7\n\nrank(num_vect)\n\n[1] 2.5 4.0 2.5 1.0 5.0 6.0\n\n\nIf we check the values of num_vect, we can see that the smallest value of num_vect is 0, which corresponds to the fourth element. Thus, the fourth element has rank 1. The second smallest value of num_vect is 2, which is shared at the first and the third elements, resulting a tie (elements with the same value will result in a tie). Normally, these two elements would have ranks 2 and 3. To break the tie, the rank() function assigns all the elements involving in the tie (the first and third elements in this example) the same rank, which is average of all their ranks (the average of 2 and 3), by default. In addition to this default behavior for handling ties, rank() also provides other options by setting the ties.method argument.\nIf we want to break the ties by the order element appears in the vector, we can set ties.method = \"first\". Then the earlier appearing element will have smaller ranks than the later one. In this example, the first element will have rank 2 and the third element has rank 3, since the first element appears earlier than the third element.\n\nrank(num_vect, ties.method = \"first\")\n\n[1] 2 4 3 1 5 6\n\n\nNote that unlike sort(), we can’t get positions in the descending order from the rank() function, which means we can’t add decreasing = TRUE in rank().\nOrder of vectors\nThe next function we want to introduce is the order() function. Note that the function name order could be a bit misleading since ordering elements also has the same meaning of sorting. However, although it is related to sorting, order() is a very different function from sort().\nLet’s recall the values of num_vect and apply order() on num_vect:\n\nnum_vect\n\n[1] 2 3 2 0 4 7\n\norder(num_vect)\n\n[1] 4 1 3 2 5 6\n\n\nFrom the result, we can see that the order() function returns the position of the original value and is in the order of sorted sequence, that is smallest value to largest value. For example, the first output is 4, indicating the 4th element in num_vect is the smallest. The second output is 1, showing the 1st element in num_vect is the second smallest."
  },
  {
    "objectID": "vector.html#mathematical-operations-and-functions-applied-to-numeric-vectors",
    "href": "vector.html#mathematical-operations-and-functions-applied-to-numeric-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.6 Mathematical operations and functions applied to numeric vectors",
    "text": "6.6 Mathematical operations and functions applied to numeric vectors\nMathematical operations applied to all the elements of a numeric vector (that is called vectorization):\n\n(1:5) * 2\n\n[1]  2  4  6  8 10\n\n2^(1:5)\n\n[1]  2  4  8 16 32\n\n\nThe same rule is applied to the elements of the vectors using mathematical functions:\n\nz_seq <- 3:9      \nsqrt(z_seq)    # calculate the square root of all the elements of z_seq\n\n[1] 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 3.000000\n\n\nWe can also round the results using the round() function and set the argument digits = 2, as following:\n\nround(sqrt(z_seq), digits = 2)\n\n[1] 1.73 2.00 2.24 2.45 2.65 2.83 3.00"
  },
  {
    "objectID": "vector.html#relational-operators-applied-between-a-vector-and-a-scalar",
    "href": "vector.html#relational-operators-applied-between-a-vector-and-a-scalar",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.7 Relational operators applied between a vector and a scalar",
    "text": "6.7 Relational operators applied between a vector and a scalar\nFor relational operators (>, <, ==, <=, >=, !=), each element of the vector is compared with a defined value (scalar). The result of comparison is a Boolean value (TRUE or FALSE).\nExamples:\n\nm <- c(4, 2, 3, 8)\n\n\nm > 3\n\n[1]  TRUE FALSE FALSE  TRUE\n\nm >= 3\n\n[1]  TRUE FALSE  TRUE  TRUE\n\nm == 3\n\n[1] FALSE FALSE  TRUE FALSE\n\nm != 3\n\n[1]  TRUE  TRUE FALSE  TRUE"
  },
  {
    "objectID": "vector.html#operators-applied-between-two-vectors",
    "href": "vector.html#operators-applied-between-two-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.8 Operators applied between two vectors",
    "text": "6.8 Operators applied between two vectors\nArithmetic Operators\nThe arithmetic operators (+, -, *, /, ^) act on each element of the vector.\nExamples:\n\nv <- c(1, 2, 3)\nt <- c(8, 3, 2)\n\n\nt + v\n\n[1] 9 5 5\n\nt^v\n\n[1] 8 9 8\n\nt + 3 * v / 2\n\n[1] 9.5 6.0 6.5\n\n\nNote that R will follow the BODMAS (Brackets, Orders (powers/roots), Division, Multiplication, Addition, Subtraction) rule for the order in which it will carry out calculations.\n \nRelational Operators\nFor relational operators (>, <, ==, <=, >=, !=), each element of the first vector is compared with the corresponding element of the second vector. The result of comparison is a Boolean value (TRUE or FALSE).\nExamples:\n\nw <- c(2, 5.5, 6, 9)\nz <- c(8, 2.5, 14, 9)\n\n\nz > w\n\n[1]  TRUE FALSE  TRUE FALSE\n\nz == w\n\n[1] FALSE FALSE FALSE  TRUE\n\nz >= w\n\n[1]  TRUE FALSE  TRUE  TRUE\n\nz != w\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\n \nLogical Operators applied to vectors\nThe logical (Boolean) operators are:\n\n\n& , && (AND)\n\n| , || (OR)\n\n! (NOT)\n\nLogical operators are applicable to vectors of type logical or numeric. The result of comparison is a logical (Boolean) value.\nSuppose we have the following vectors:\n\ns <- c(1, 0, - 1, 0, TRUE, TRUE, FALSE)\ns\n\n[1]  1  0 -1  0  1  1  0\n\nu <- c(2, 0, - 2, 2, TRUE, FALSE, FALSE)\nu\n\n[1]  2  0 -2  2  1  0  0\n\n\nHow R will compute, for example, s & u?\nTHE RULE: all non-zero values in the vectors are considered as logical value TRUE and all zeros are considered as FALSE.\nTherefore:\n\ns\n\n[1]  1  0 -1  0  1  1  0\n\n\nLogicals: TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n\nu\n\n[1]  2  0 -2  2  1  0  0\n\n\nLogicals: TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n \nA. AND Operators (&, &&)\nThe & operator combines each element of the first vector with the corresponding element of the second vector and gives an output TRUE if both the elements are TRUE.\n\ns & u\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n\n\nAdditionally, the && operator takes the first element of both vectors and gives TRUE only if both are TRUE.\n\ns && u\n\nWarning in s && u: 'length(x) = 7 > 1' in coercion to 'logical(1)'\n\nWarning in s && u: 'length(x) = 7 > 1' in coercion to 'logical(1)'\n\n\n[1] TRUE\n\n\nB. OR operators (|, ||)\nThe | operator combines each element of the first vector with the corresponding element of the second vector and gives an output TRUE if one of the elements is TRUE.\n\ns | u\n\n[1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n\n\nAdditionally, the || operator takes the first element of both vectors and gives TRUE if one of them is TRUE.\n\ns || u\n\nWarning in s || u: 'length(x) = 7 > 1' in coercion to 'logical(1)'\n\n\n[1] TRUE\n\n\nC. NOT operator (!)\nThe ! operator takes each element of the vector and gives the opposite logical value.\n\n! s\n\n[1] FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n\n! u\n\n[1] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE"
  },
  {
    "objectID": "vector.html#statistical-functions-applied-to-vectors",
    "href": "vector.html#statistical-functions-applied-to-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.9 Statistical functions applied to vectors",
    "text": "6.9 Statistical functions applied to vectors\nStatistical functions in R such as sum() and arithmetic mean() take in the numeric values of a vector and return a single numeric value:\n\nv_seq <- 5:10   \nv_seq\n\n[1]  5  6  7  8  9 10\n\nsum(v_seq)     # adds all the elements of a vector\n\n[1] 45\n\nmean(v_seq)    # calculate the arithmetic mean\n\n[1] 7.5\n\nmedian(v_seq)  # calculate the median\n\n[1] 7.5\n\nsd(v_seq)      # calculate the standard deviation\n\n[1] 1.870829\n\nrange(v_seq)   # returns the minimum and maximum values\n\n[1]  5 10\n\n\n \nNext, we add a missing value NA in the v_seq vector:\n\nv_seq2 <- c(v_seq, NA)\ntypeof(v_seq2)\n\n[1] \"integer\"\n\n\nWe can see that the v_seq2 vector is of integer type.\nHowever, if we try to calculate the mean of the v_seq2, R returns a NA value:\n\nmean(v_seq2)\n\n[1] NA\n\n\nTherefore, if some of the values in a vector are missing, then the mean of the vector is unknown (NA). In this case, it makes sense to remove the NA and compute the mean of the other values in the vector setting the na.rm argument equals to TRUE:\n\nmean(v_seq2, na.rm = TRUE)\n\n[1] 7.5"
  },
  {
    "objectID": "vector.html#subsetting-vectors",
    "href": "vector.html#subsetting-vectors",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.10 Subsetting vectors",
    "text": "6.10 Subsetting vectors\nSubsetting (indexing) a vector using [ ]\n\nA. Extract specific elements of a vector\nHaving defined a vector, it’s often useful to extract parts of a vector. We do this with the [ ] operator. For example, using the built in month.name vector:\n\nmonth.name[2]     # we extract only the second month of the year\n\n[1] \"February\"\n\nmonth.name[2:4]   # we extract the second, third, and forth month of the year\n\n[1] \"February\" \"March\"    \"April\"   \n\n\nLet’s see the second example analytically. The vector 2:4 generates the sequence 2, 3, 4. This gets passed to the extract operator [ ].\nWe can also generate this sequence using the vector c(2, 3, 4):\n\nmonth.name[c(2, 3, 4)]\n\n[1] \"February\" \"March\"    \"April\"   \n\n\n\n\n\n\n\n\nThe first element of a vector\n\n\n\nIn R, the first element of a vector has an index of 1. (In many other programming languages [e.g., C and Python], the first element of a vector has an index of 0)\n\n\n \nNote that values are returned in the order that we specify with the indices. For example:\n\nmonth.name[4:2]  # extraction of 4, 3, 2 elements of the vector\n\n[1] \"April\"    \"March\"    \"February\"\n\n\nWe can also extract the same element more than once:\n\nmonth.name[c(1, 1, 2, 3, 4)]\n\n[1] \"January\"  \"January\"  \"February\" \"March\"    \"April\"   \n\n\n \n\n\n\n\n\n\nMissing data (NA) in vectors\n\n\n\nIf we try and extract an element that doesn’t exist in the vector, the missing values are NA:\n\nmonth.name[10:13]\n\n[1] \"October\"  \"November\" \"December\" NA        \n\n\n\n\n \nB. Skipping and removing elements from vectors\nIf we use a negative number as the index of a vector, R will return every element except for the one specified:\n\nmonth.name[-2]   # remove the second month February from the vector\n\n [1] \"January\"   \"March\"     \"April\"     \"May\"       \"June\"      \"July\"     \n [7] \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nWe can also skip multiple elements:\n\nmonth.name[c(-1, -5)]  # remove the first and fifth elements of the vector\n\n [1] \"February\"  \"March\"     \"April\"     \"June\"      \"July\"      \"August\"   \n [7] \"September\" \"October\"   \"November\"  \"December\" \n\n\nwhich is equivalent to:\n\nmonth.name[-c(1, 5)]  # remove the first and fifth elements of the vector\n\n [1] \"February\"  \"March\"     \"April\"     \"June\"      \"July\"      \"August\"   \n [7] \"September\" \"October\"   \"November\"  \"December\" \n\n\n \nA common error occurs when trying to skip slices of a vector. Suppose we want to skip the first five elements form the month.name vector. Most people first try to negate a sequence like so:\n\nmonth.name[-1:5]  \n\nThis gives an error:Error in month.name [-1:5]: only 0’s may be mixed with negative subscripts\nRemember that the colon operator : is a function and in this example takes its first argument as -1, and second as 5, so generates the sequence of numbers: -1, 0, 1, 2, 3, 4, 5.\nThe correct solution is to wrap that function call in brackets, so that the - operator is applied to the sequence:\n\n-(1:5)\n\n[1] -1 -2 -3 -4 -5\n\nmonth.name[-(1:5)]  # remove the 1st to fifth element of the vector\n\n[1] \"June\"      \"July\"      \"August\"    \"September\" \"October\"   \"November\" \n[7] \"December\" \n\n\n \nSubsetting with logical vectors (indexing by conditon)\nAs well as providing a list of indices we want to keep (or delete, if we prefix them with -), we can pass a logical vector to R indicating the indices we wish to select.\nFor example, let’s say that we want to select only the first four months of the year:\n\nfourmonths <- month.name[1:4]\nfourmonths\n\n[1] \"January\"  \"February\" \"March\"    \"April\"   \n\n\nwhich is equivalent to:\n\nmonth.name[c(TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, \n             FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]\n\n[1] \"January\"  \"February\" \"March\"    \"April\"   \n\n\nFurthermore, if we want to exlude “February” from the fourmonths vector we should code:\n\nfourmonths[c(TRUE, FALSE, TRUE, TRUE)]\n\n[1] \"January\" \"March\"   \"April\""
  },
  {
    "objectID": "vector.html#vector-recycling",
    "href": "vector.html#vector-recycling",
    "title": "6  Data structures in R: 1-Dimensional Vectors",
    "section": "\n6.11 Vector recycling",
    "text": "6.11 Vector recycling\nWhat happens if we supply a logical vector that is shorter than the vector we’re extracting the elements from?\nFor example:\n\nfourmonths[c(TRUE, FALSE)]\n\n[1] \"January\" \"March\"  \n\n\nThis illustrates the idea of vector recycling. The [ ] extract operator silently “recycled” the values of the shorter vector c(TRUE, FALSE) in order to make the length compatible to the fourmonths vector:\n\nfourmonths[c(TRUE,FALSE,TRUE,FALSE)]\n\n[1] \"January\" \"March\"  \n\n\nFor a further example, suppose we have two vectors c(1,2,4) , c(6,0,9,10,13), where the first one is shorter with only 3 elements. Now if we sum these two, we will get a warning message as follows.\n\nc(1,2,4) + c(6,0,9,10,13)\n\nWarning in c(1, 2, 4) + c(6, 0, 9, 10, 13): longer object length is not a\nmultiple of shorter object length\n\n\n[1]  7  2 13 11 15\n\n\nHere R , sums those vectors by recycling or repeating the elements in shorter one, until it is long enough to match the longer one as follows:\n\nc(1, 2, 4, 1, 2) + c(6, 0, 9, 10, 13)\n\n[1]  7  2 13 11 15"
  },
  {
    "objectID": "matrix.html",
    "href": "matrix.html",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "matrix.html#creating-a-matrix-in-r",
    "href": "matrix.html#creating-a-matrix-in-r",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.1 Creating a matrix in R",
    "text": "7.1 Creating a matrix in R\nEvery data object in R contains a number of attributes to describe the nature of the information in that object. For example, we can generate objects such as matrices using the dim (dimension) attribute. Using matrices we can perform a matrix algebra operations, a powerful type of mathematical technique.\n\n\n\n\n\n\nMatrix\n\n\n\nA matrix is an atomic vector with two dimensions and it is used to represent 2-dimensional data (they have rows and columns) of the same type (numeric, character, or logical).\n\n\nAdding a dimension attribute to a vector allows it to behave like a 2-dimensional matrix. For example:\n\nx_20 <- 1:20\n\ndim(x_20) <- c(5, 4)\n\nx_20\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\n \nMost often we define a matrix using the matrix() function. We need to specify the number of rows and columns.\nExample 1: numeric matrix\n\nX1 <- matrix(1:20, nrow=5, ncol=4)\nX1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nThe matrix is filled by columns (default column-wise), so entries can be thought of starting in the “upper left” corner and running down the columns. If we want the matrix to be filled by rows we must add an extra argument (byrow=TRUE) in the matrix() function, as follows:\n\nX2 <- matrix(1:20, nrow=5, ncol=4, byrow=TRUE)\nX2\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n\n\n \nThe type of data, the class and the dimensions of the X2 object are:\n\ntypeof(X2)\n\n[1] \"integer\"\n\nclass(X2)\n\n[1] \"matrix\" \"array\" \n\ndim(X2)\n\n[1] 5 4\n\n\nOf note, the typeof() function gives the type of data that the object includes (integer), while the class is the type of structure (matrix) of the object.\nThe dim() is an inbuilt R function that either sets or returns the dimension of the matrix, array, or data frame. The dim() function takes the R object as an argument and returns its dimension (as in our example), or if you assign the value to the dim() function, then it sets the dimension for that R Object.\n \nExample 2: logical matrix\n\nx_logical <- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)\nX3 <- matrix(x_logical, nrow=2, ncol=3)\nX3\n\n      [,1]  [,2]  [,3]\n[1,]  TRUE FALSE FALSE\n[2,] FALSE  TRUE FALSE\n\n\n \nThe type of data, the class and the dimensions of the X3 object are:\n\ntypeof(X3)\n\n[1] \"logical\"\n\nclass(X3)\n\n[1] \"matrix\" \"array\" \n\ndim(X3)\n\n[1] 2 3\n\n\n \nExample 3: character matrix\n\nx_char <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\nX4 <- matrix(x_char, nrow=2, ncol=3)\nX4\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"f\" \n\n\n \nThe type of data, the class and the dimensions of the X4 object are:\n\ntypeof(X4)\n\n[1] \"character\"\n\nclass(X4)\n\n[1] \"matrix\" \"array\" \n\ndim(X4)\n\n[1] 2 3"
  },
  {
    "objectID": "matrix.html#using-matrix-subscripts",
    "href": "matrix.html#using-matrix-subscripts",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.2 Using matrix subscripts",
    "text": "7.2 Using matrix subscripts\nWe can identify rows, columns, or elements of a matrix by using subscripts and brackets. Particularly, X[i, ] refers to the ith row of matrix X, X[ , j] refers to jth column, and X[i, j] refers to the ijth element, respectively.\nThe subscripts i and j can be numeric vectors in order to select multiple rows or columns, as shown in the following examples.\n\nX <- matrix(1:10, nrow=2)  # create a 2x5 numeric matrix filled by column\nX\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\nX[2, ]   # select the 2nd row\n\n[1]  2  4  6  8 10\n\nX[, 2]  # select the 2nd column\n\n[1] 3 4\n\nX[1, 4]  # select the element in the 1st row, 4th column\n\n[1] 7\n\nX[1, c(4, 5)]  # select the elements in the 1st row, 4th and 5th column \n\n[1] 7 9"
  },
  {
    "objectID": "matrix.html#basic-matrix-algebra",
    "href": "matrix.html#basic-matrix-algebra",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.3 Basic matrix algebra",
    "text": "7.3 Basic matrix algebra\nThe identity matrix\nA square matrix with ones on the main diagonal and zeros elsewhere:\n\ndiag(5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n\n\n \nThe transpose of a matrix\nThe transpose operation simply changes columns to rows. For example, for a matrix A:\n\nA <-matrix(c(4, -1, -5, 0, 1, -2), 2, 3, byrow = TRUE)\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\n\nthe transpose matrix is:\n\nt(A)\n\n     [,1] [,2]\n[1,]    4    0\n[2,]   -1    1\n[3,]   -5   -2\n\n\n \nMultiplying a number (scalar) with a matrix\nIn scalar multiplication, each element in the matrix is multiplied by the given number (scalar). For example:\n\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\n-3 * A\n\n     [,1] [,2] [,3]\n[1,]  -12    3   15\n[2,]    0   -3    6\n\n\n \nElement-wise multiplication of two matrices of the same dimensions\nThe element-wise multiplication of two matrices, A and B, of the same dimensions can also be computed with the * operator.\n\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\nB <-matrix(c(3, 1, -5, 0, 2, -2), 2, 3, byrow = TRUE)\nB\n\n     [,1] [,2] [,3]\n[1,]    3    1   -5\n[2,]    0    2   -2\n\n\nThe output will be a matrix of the same dimensions of the original matrices:\n\nA * B\n\n     [,1] [,2] [,3]\n[1,]   12   -1   25\n[2,]    0    2    4\n\n\n \nThe dot product (inner product) of two matrices\nIn R, an inner product of two matrices can be performed with the %*% operator.\n\nP <- matrix(c(3, 0, -5, -1, -3, 4), nrow = 2, ncol = 3, byrow = TRUE)\nQ <- matrix(c(-5, 5, 2, 1, -2, 0), nrow = 3, ncol = 2, byrow = TRUE)\nP\n\n     [,1] [,2] [,3]\n[1,]    3    0   -5\n[2,]   -1   -3    4\n\nQ\n\n     [,1] [,2]\n[1,]   -5    5\n[2,]    2    1\n[3,]   -2    0\n\nP %*% Q\n\n     [,1] [,2]\n[1,]   -5   15\n[2,]   -9   -8\n\n\nBefore inner multiplying two matrices check that the dimensions are compatible. The number of columns of the first matrix must be equal to the number of rows of the second.\n \nMatrix crossproduct\nIf we need to calculate the inner product of a matrix and the transpose we can type t(A) %*% B, being A and B the names of the matrices.\n\nA\n\n     [,1] [,2] [,3]\n[1,]    4   -1   -5\n[2,]    0    1   -2\n\nB\n\n     [,1] [,2] [,3]\n[1,]    3    1   -5\n[2,]    0    2   -2\n\nt(A) %*% B\n\n     [,1] [,2] [,3]\n[1,]   12    4  -20\n[2,]   -3    1    3\n[3,]  -15   -9   29\n\n\nHowever, in R it is more efficient and faster using the crossprod:\n\ncrossprod(A, B)\n\n     [,1] [,2] [,3]\n[1,]   12    4  -20\n[2,]   -3    1    3\n[3,]  -15   -9   29\n\n\n \nThe determinant of a matrix\nThe determinant is a scalar value that is a function of the entries of a square matrix:\n\nM <- matrix( c(5, 1, 0, 3,-1, 2, 4, 0,-1), nrow = 3, byrow = TRUE)\nM\n\n     [,1] [,2] [,3]\n[1,]    5    1    0\n[2,]    3   -1    2\n[3,]    4    0   -1\n\ndet(M)\n\n[1] 16\n\n\n \nThe inverse of a matrix\nThe det(M) is not zero, so inverse exists:\n\nM_inv  <- inv(M)\nM_inv\n\n       [,1]    [,2]   [,3]\n[1,] 0.0625  0.0625  0.125\n[2,] 0.6875 -0.3125 -0.625\n[3,] 0.2500  0.2500 -0.500\n\n\nThe inverse of a matrix M is defined as the M_inv matrix which multiplies M to give the identity matrix:\n\nM_inv %*% M\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\n \nSymmetric matrix\nIn linear algebra, a symmetric matrix is a square matrix that is equal to its transpose. For example:\n\nS <- matrix(c(13, -4, 2, -4, 11, -2, 2, -2, 8), 3, 3, byrow = TRUE)\nS\n\n     [,1] [,2] [,3]\n[1,]   13   -4    2\n[2,]   -4   11   -2\n[3,]    2   -2    8\n\nt(S)\n\n     [,1] [,2] [,3]\n[1,]   13   -4    2\n[2,]   -4   11   -2\n[3,]    2   -2    8\n\n\nA symmetric matrix guarantees that its eigenvalues are real numbers. Eigenvalues and eigenvectors are highly used by the data scientists as they are the core of the data science field. For example, eigenvalues and eigenvectors are very much useful in the principal component analysis which is a dimensionality reduction technique in machine learning and is highly used in the field of data science.\nThe eigen() built-in function in R calculates the eigenvalues and eigenvectors of a symmetric matrix. It returns a named list, with eigenvalues named values and eigenvectors named vectors:\n\nev <- eigen(S)\nev\n\neigen() decomposition\n$values\n[1] 17  8  7\n\n$vectors\n           [,1]       [,2]      [,3]\n[1,]  0.7453560  0.6666667 0.0000000\n[2,] -0.5962848  0.6666667 0.4472136\n[3,]  0.2981424 -0.3333333 0.8944272\n\n\nThe eigenvalues are always returned in decreasing order, and each column of vectors corresponds to the elements in values.\n \nApplication: calculation of the average using matrices\nIn ordinary algebra, the mean of a set of n observations, \\(v_1, v_2, v_3,...,v_i, ..., v_n\\) is computed by adding all of the observations and dividing by the number of observations:\n\\[\n\\overline{v} = \\frac{1}{n}\\sum_{i=1}^{n}v_i\n\\]\nwhere \\(\\overline{v}\\) is the mean of observations, \\(\\sum_{i=1}^{n}v_i\\) is the sum of all observations, and \\(n\\) is the number of observations.\nIn matrix algebra, given that:\n\\[\nU = \\left(\\begin{array}{c}\n1 \\\\\n1 \\\\\n\\vdots \\\\\n1\n\\end{array}\\right)\n\\]\nand\n\\[\nV = \\left(\\begin{array}{c}\nv_1 \\\\\nv_2 \\\\\n\\vdots \\\\\nv_n\n\\end{array}\\right)\n\\]\nthe mean can be computed as follows:\n\\[\n\\frac{1}{n} \\cdot U^T \\cdot V =\n\\frac{1}{n} \\cdot\n\\begin{pmatrix}\n      1 & 1 & 1 & ...& 1\n    \\end{pmatrix}\n    \\cdot\n    \\begin{pmatrix}\n      v_{1} \\\\\n      v_{2} \\\\\n      v_{3} \\\\\n      \\vdots \\\\\n      v_{n} \\\\\n    \\end{pmatrix} =\n\\]\n\\[\n=\n    \\frac{1}{n} \\cdot\n    \\begin{pmatrix}\n      1\\cdot v_{1} + 1\\cdot v_{2} +1\\cdot v_{3} +...1\\cdot v_{n}\n    \\end{pmatrix} =\n    \\frac{1}{n}\\sum_{i=1}^{n}v_i\n\\]\nwhere \\(U^T\\) is the transpose of \\(U\\).\nFor example:\n\nmy_values <- c(2, 5, 7, -4, 8, 6, 3)\nmean(my_values)\n\n[1] 3.857143\n\n\n\nn <- length(my_values)  # get the length (number of elements) of vector\nU <- matrix(1, n, 1)\nU\n\n     [,1]\n[1,]    1\n[2,]    1\n[3,]    1\n[4,]    1\n[5,]    1\n[6,]    1\n[7,]    1\n\nV <- matrix(my_values, n, 1)\nV\n\n     [,1]\n[1,]    2\n[2,]    5\n[3,]    7\n[4,]   -4\n[5,]    8\n[6,]    6\n[7,]    3\n\n\n\naverage_my_values <- t(U) %*% V/n\naverage_my_values \n\n         [,1]\n[1,] 3.857143"
  },
  {
    "objectID": "matrix.html#arrays",
    "href": "matrix.html#arrays",
    "title": "7  Data structures in R: matrices and arrays",
    "section": "\n7.4 Arrays",
    "text": "7.4 Arrays\nArrays are similar to matrices but can have more than two dimensions. They’re created with an array() function from base R:\n\n# build the 2x3x4 array\nmy_array <- array(1:24, dim = c(2,3,4))\nmy_array\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24\n\n\nAs you can see, arrays are a natural extension of matrices. They can be useful in programming new statistical methods. Like matrices, they contain a single type of data (e.g., numeric).\nWe can find the type, class and the dimensions of the array:\n\ntypeof(my_array)\n\n[1] \"integer\"\n\nclass(my_array)\n\n[1] \"array\"\n\ndim(my_array)\n\n[1] 2 3 4"
  },
  {
    "objectID": "list.html",
    "href": "list.html",
    "title": "8  Data structures in R: lists and data frames",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "list.html#creating-a-list",
    "href": "list.html#creating-a-list",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.1 Creating a list",
    "text": "8.1 Creating a list\nA list in R allows us to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related to each other in any way. We could say that a list is some kind super data type: we can store practically any piece of information in it!\nWe construct a list using the list() function. The list items (or components of a list) can be matrices, vectors, other lists. For example:\n\nmy_list <- list(1:5, c(\"apple\", \"orange\"), TRUE)\nmy_list\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"apple\"  \"orange\"\n\n[[3]]\n[1] TRUE\n\n\nThis list consists of three components that are atomic vectors of different types of data (numeric, characters, and logical).\nWe can assign names to the list items:\n\nmy_list <- list(\n              numbers = 1:5, \n              strings = c(\"apple\", \"orange\"), \n              logicals = TRUE)\nmy_list\n\n$numbers\n[1] 1 2 3 4 5\n\n$strings\n[1] \"apple\"  \"orange\"\n\n$logicals\n[1] TRUE\n\n\nWe can also confirm that the class of the object is list:\n\nclass(my_list)\n\n[1] \"list\""
  },
  {
    "objectID": "list.html#subsetting-a-list",
    "href": "list.html#subsetting-a-list",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.2 Subsetting a list",
    "text": "8.2 Subsetting a list\nSubset list and preserve output as a list\nWe can use the [ ] operator to extract one or more list items while preserving the output in list format:\n\nmy_list[1]    # extract the first list item\n\n$numbers\n[1] 1 2 3 4 5\n\nclass(my_list[1])\n\n[1] \"list\"\n\n\n \nSubset list and simplify the output\nWe can use the [[ ]] to extract one or more list items while simplifying the output:\n\nmy_list[[1]]   # extract the first list item and simplify it to a vector\n\n[1] 1 2 3 4 5\n\nclass(my_list[[1]])\n\n[1] \"integer\"\n\nmy_list[[\"numbers\"]]   # same as above but using the item's name\n\n[1] 1 2 3 4 5\n\n\nWe can also access the content of the list by typing the name of the list followed by a dollar sign $ folowed by the name of the list item:\n\nmy_list$numbers  # extract the numbers and simplify to a vector\n\n[1] 1 2 3 4 5\n\n\nOne thing that differentiates the [[ operator from the $ is that the [[ operator can be used with computed indices and names. The $ operator can only be used with names.\n\n\n\n\n\n\nSimplifying Vs Preserving subsetting\n\n\n\nIt’s important to understand the difference between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output. Preserving subsets keeps the structure of the output the same as the input.\n\n\n \nSubset list to get individual elements out of a list item\nTo extract individual elements out of a specific list item combine the [[ (or $) operator with the [ operator:\n\nmy_list[[2]][2]          # using the index\n\n[1] \"orange\"\n\nmy_list[[\"strings\"]][2]  # using the name of the list item\n\n[1] \"orange\"\n\nmy_list$strings[2]       # using the $\n\n[1] \"orange\""
  },
  {
    "objectID": "list.html#recursive-vectors-and-nested-lists",
    "href": "list.html#recursive-vectors-and-nested-lists",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.3 Recursive vectors and Nested Lists",
    "text": "8.3 Recursive vectors and Nested Lists\nA recursive vector is a list that contains other lists. The sublists of a recursive vector are known as nested lists. For example:\n\nmy_list2 <- list(item1 = 3.14,\n            item2 = list(item2a_num = 5:10,\n                         item2b_char = c(\"a\",\"b\",\"c\")))\n\nmy_list2\n\n$item1\n[1] 3.14\n\n$item2\n$item2$item2a_num\n[1]  5  6  7  8  9 10\n\n$item2$item2b_char\n[1] \"a\" \"b\" \"c\"\n\n\n \nSubsetting a nested list\nWe can access list items of a nested list by using the combination of [[ ]] or $ operator and the [ ] operator. For example:\n\n# preserve the output as a list\nmy_list2[[2]][1]\n\n$item2a_num\n[1]  5  6  7  8  9 10\n\nclass(my_list2[[2]][1])\n\n[1] \"list\"\n\n# same as above but simplify the output\nmy_list2[[2]][[1]]\n\n[1]  5  6  7  8  9 10\n\nclass(my_list2[[2]][[1]])\n\n[1] \"integer\"\n\n# same as above with names\nmy_list2[[\"item2\"]][[\"item2a_num\"]]\n\n[1]  5  6  7  8  9 10\n\n# same as above with $ operator\nmy_list2$item2$item2a_num\n\n[1]  5  6  7  8  9 10\n\n\n \nWe can also extract individual elements from the list items of a nested list. For example:\n\n# extract individual element\nmy_list2[[2]][[2]][3]\n\n[1] \"c\"\n\nclass(my_list2[[2]][[2]][3])\n\n[1] \"character\""
  },
  {
    "objectID": "list.html#unlist-a-list",
    "href": "list.html#unlist-a-list",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.4 Unlist a list",
    "text": "8.4 Unlist a list\nWe can turn a list into an atomic vector with unlist():\n\nmy_unlist <- unlist(my_list)\nmy_unlist\n\nnumbers1 numbers2 numbers3 numbers4 numbers5 strings1 strings2 logicals \n     \"1\"      \"2\"      \"3\"      \"4\"      \"5\"  \"apple\" \"orange\"   \"TRUE\" \n\nclass(my_unlist)\n\n[1] \"character\""
  },
  {
    "objectID": "list.html#data-frames",
    "href": "list.html#data-frames",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.5 Data frames",
    "text": "8.5 Data frames\nA data frame is the most common way of storing data in R and, generally, is the data structure most often used for data analyses.\n\n\n\n\n\n\nData frame\n\n\n\nA data frame is a special type of list with equal-length atomic vectors. Each component of the list can be thought of as a column and the length of each component of the list is the number of rows.\n\n\n \nBasic characteristics of data frames\n\nEach column of a data frame is an atomic vector and remember that the data in an atomic vector must only be of one type (numeric, character, or logical).\n\nData frames are similar to the datasets we’d typically see in spreadsheets (e.g., Excell files, Google sheets, LibreOffice Calc).\n\nData frames are the most common data structure we’ll deal with in R. A data frame can be created with the data.frame() function in base R, the tibble() function in the tidyverse package (an improvement over data.frame), or the “fast” data.table() in the data.table package.\n\nDifferent traditions have different names for the rows and columns of a dataset. Statisticians refer to them as observations and variables, database analysts call them records and fields, and those from the data mining/machine learning disciplines call them examples and attributes. We’ll use the terms observations and variables throughout this textbook.\nThe two basic variable categories are the categorical and numerical variables.\n \nCreating a data frame with tibble()\n\nWe can create a data frame from column vectors with the tibble() function from tibble package which belongs to the “tidyverse” family of packages. A tibble is a specific kind of data frame and is short for “tidy table”.\nIn order to use the tidyverse packages, our input data frames must be in “tidy” format (long/narrow format). In tidy data there are three interrelated rules:\n\nEach variable must have its own column.\nEach observation must have its own row.\nEach value must have its own cell.\n\n\n\n\n\nFigure 8.1: Tidy data.\n\n\n\n\nHere, we provide a simple example of patient dataset:\n\nlibrary(tidyverse)   # load the tidyverse package\nlibrary(lubridate)   # load the lubridate package\n\npatient_data <- tibble(\npatientID = c(1, 2, 3, 4, 5, 6, 7, 8),\nage = c(25, 30, 28, 22, 31, 45, 37, 43),\nweight = c(94, 83, 71, 87, 94, 73, 89, 74),\ndiabetes = c(\"Type 1\", \"Type 2\", \"Type 1\", \"Type 1\", \n              \"Type 2\", \"Type 1\", \"Type 1\", \"Type 2\"),\nstatus = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\", \n            \"Poor\",\"Excellent\", \"Improved\", \"Improved\"),\ndates = ymd(\"2020-10-09\", \"2020-10-12\", \"2020-10-18\", \"2020-10-27\",\n           \"2020-11-04\", \"2020-11-09\", \"2020-11-22\", \"2020-12-02\"))\npatient_data\n\n# A tibble: 8 × 6\n  patientID   age weight diabetes status    dates     \n      <dbl> <dbl>  <dbl> <chr>    <chr>     <date>    \n1         1    25     94 Type 1   Poor      2020-10-09\n2         2    30     83 Type 2   Improved  2020-10-12\n3         3    28     71 Type 1   Excellent 2020-10-18\n4         4    22     87 Type 1   Poor      2020-10-27\n5         5    31     94 Type 2   Poor      2020-11-04\n6         6    45     73 Type 1   Excellent 2020-11-09\n7         7    37     89 Type 1   Improved  2020-11-22\n8         8    43     74 Type 2   Improved  2020-12-02\n\n\nIn this data frame, patientID is a row or case identifier, age (in years) and weight (in kg) are continuous variables, diabetes (Type 1, Type 2) is a nominal (dichotomous) variable, status is an ordinal variable (Poor/Improved/Excellent), and dates variable with dates (note that we used the ymd() function to create this variable).\nFirst, let’s take a look at the structure of the object patient_data with the glimpse():\n\nglimpse(patient_data)\n\nRows: 8\nColumns: 6\n$ patientID <dbl> 1, 2, 3, 4, 5, 6, 7, 8\n$ age       <dbl> 25, 30, 28, 22, 31, 45, 37, 43\n$ weight    <dbl> 94, 83, 71, 87, 94, 73, 89, 74\n$ diabetes  <chr> \"Type 1\", \"Type 2\", \"Type 1\", \"Type 1\", \"Type 2\", \"Type 1\", …\n$ status    <chr> \"Poor\", \"Improved\", \"Excellent\", \"Poor\", \"Poor\", \"Excellent\"…\n$ dates     <date> 2020-10-09, 2020-10-12, 2020-10-18, 2020-10-27, 2020-11-04, …\n\n\nWe can also find the type, class and dim for the data table:\n\ntypeof(patient_data)\n\n[1] \"list\"\n\nclass(patient_data)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\ndim(patient_data)\n\n[1] 8 6\n\n\nThe type is a list but the class is a tbl (tibble) object which is a “tidy” data frame. The dimensions are 8x6.\nThe attribute() function help us to explore the characteristics/attributives of the tibbles:\n\nattributes(patient_data)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3 4 5 6 7 8\n\n$names\n[1] \"patientID\" \"age\"       \"weight\"    \"diabetes\"  \"status\"    \"dates\"    \n\n\n \nAccess only one variable at a time from a tibble\nTo access the variable age, we can use the dollar sign ($) like this:\n\npatient_data$age\n\n[1] 25 30 28 22 31 45 37 43\n\n\nFor example, if we want to cross tabulate diabetes type by status, we could use the following code:\n\ntable(patient_data$diabetes, patient_data$status)\n\n        \n         Excellent Improved Poor\n  Type 1         2        1    2\n  Type 2         0        2    1\n\n\n\n\n\n\n\n\nTable\n\n\n\nThe table() function builds a contingency table of the counts at each combination of levels of the variables."
  },
  {
    "objectID": "list.html#access-variables-using-the-with-function",
    "href": "list.html#access-variables-using-the-with-function",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.6 Access variables using the with() function",
    "text": "8.6 Access variables using the with() function\nIt can get tiresome typing patient_data$ at the beginning of every variable name. An alternative approach is to use with() function. For example:\n\nwith(patient_data, table(diabetes, status))\n\n        status\ndiabetes Excellent Improved Poor\n  Type 1         2        1    2\n  Type 2         0        2    1"
  },
  {
    "objectID": "list.html#factors",
    "href": "list.html#factors",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.7 Factors",
    "text": "8.7 Factors\nCategorical (nominal) and ordered categorical (ordinal) variables in R are usually transformed to factors. Factors can contain only predefined values and are crucial in R because they determine how data will be analyzed in statistical models and presented visually.\nIn our example, we should convert the diabetes and status variables from character to factor variables. This can be done by applying the convert_as_factor() function from the rstatix package:\n\n# convert from character to factor\npatient_data <- rstatix::convert_as_factor(patient_data, diabetes, status)\npatient_data\n\n# A tibble: 8 × 6\n  patientID   age weight diabetes status    dates     \n      <dbl> <dbl>  <dbl> <fct>    <fct>     <date>    \n1         1    25     94 Type 1   Poor      2020-10-09\n2         2    30     83 Type 2   Improved  2020-10-12\n3         3    28     71 Type 1   Excellent 2020-10-18\n4         4    22     87 Type 1   Poor      2020-10-27\n5         5    31     94 Type 2   Poor      2020-11-04\n6         6    45     73 Type 1   Excellent 2020-11-09\n7         7    37     89 Type 1   Improved  2020-11-22\n8         8    43     74 Type 2   Improved  2020-12-02\n\n\nNow, we can inspect the order of the levels for both factor variables using the levels() function:\n\nlevels(patient_data$diabetes) # show the levels of diabetes variable\n\n[1] \"Type 1\" \"Type 2\"\n\nlevels(patient_data$status) # show the levels of status variable\n\n[1] \"Excellent\" \"Improved\"  \"Poor\"     \n\n\nAdditionally, we may want to reorder the levels in the status variable using the fct_relevel() function from the forcats package. In this case, the argument rev in the function will reverse the order:\n\n# reverse the order of the levels\npatient_data$status <-  fct_relevel(patient_data$status, rev)\n\nlevels(patient_data$status)  # show the order of the levels\n\n[1] \"Poor\"      \"Improved\"  \"Excellent\"\n\n\nor using the fct_rev() from forcats package:\n\npatient_data$status <- fct_rev(patient_data$status)\n\nThe status variable has a natural ordering between its categories. If we want to compare the values, we have to pass this information to R.\n\npatient_data$status <-  factor(patient_data$status, ordered = TRUE)\n\npatient_data$status\n\n[1] Poor      Improved  Excellent Poor      Poor      Excellent Improved \n[8] Improved \nLevels: Poor < Improved < Excellent\n\n\nNow we can use, for example, the comparison operators > to check whether one element of the ordered vector is larger than the other.\n\npatient_data$status[2] > patient_data$status[6]\n\n[1] FALSE\n\n\nFactors are also useful when we know the set of possible values (based on theory or experimental design, not of the data) but they’re not all present in a given dataset. In contrast to a character vector, when we tabulate a factor (e.g. using the table() function) we will get counts of all categories, even unobserved ones:\n\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n\nsex_char\nm \n3 \n\ntable(sex_factor)\n\nsex_factor\nm f \n3 0"
  },
  {
    "objectID": "list.html#dates-in-r",
    "href": "list.html#dates-in-r",
    "title": "8  Data structures in R: lists and data frames",
    "section": "\n8.8 Dates in R",
    "text": "8.8 Dates in R\nThere are three types of date/time data that refer to an instant in time:\n\nA date. Tibbles print this as <date>.\nA time within a day. Tibbles print this as <time>.\nA date-time is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). Tibbles print this as <dttm>. Elsewhere in R these are called POSIXct.\n\nTo get the current date or date-time you can use Sys.Date() or now():\n\nSys.Date()\nnow()\n\nDate vectors are built on top of double vectors but they have the special class “Date”:\n\ntoday <- Sys.Date()\ntypeof(today)\n\n[1] \"double\"\n\nclass(today)\n\n[1] \"Date\"\n\n\nThe value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01:\n\nunclass(today)\n\n[1] 19258\n\n\nSo, in numeric form, Date counts the days since 1970-01-01. For example:\n\ndate1 <- as.Date('2020-06-28')\nas.numeric(date1)\n\n[1] 18441\n\n\nNow, we can use difftime() to find the amount of time in DAYS that has passed since we created date1.\n\ndifftime(Sys.time(), date1, units = 'days')\n\nTime difference of 817.1501 days\n\n\nPOSIXct stores a date and time. In numeric form, the number of seconds since 1970-01-01.\n\ndate2 <- as.POSIXct('2012-06-28 18:00')\nas.numeric(date2)\n\n[1] 1340895600\n\n\nWe’ve seen also one approach to parsing strings into dates variable in our data frame using the ymd() function from lubridate package. This is the most concise way to create a single date/time object, as we might need when filtering date/time data. The class of this object is:\n\nclass(patient_data$dates)\n\n[1] \"Date\""
  },
  {
    "objectID": "transformation.html",
    "href": "transformation.html",
    "title": "9  Data transformation",
    "section": "",
    "text": "When we have finished this chapter, we should be able to:"
  },
  {
    "objectID": "transformation.html#importing-data",
    "href": "transformation.html#importing-data",
    "title": "9  Data transformation",
    "section": "\n9.1 Importing data",
    "text": "9.1 Importing data\nUp to this point we have used data objects created with functions. Most of the time however, we work with data stored elsewhere and there are many ways to import such data into an R session.\nData are stored in spreadsheets which are often saved in one of the following two formats:\n\nA Comma Separated Values .csv file. We can think of a .csv file as a barebones spreadsheet where:\n\n\nEach line in the file corresponds to one row of data/one observation.\nValues for each line are separated with commas “,”. In other words, the values of different variables are separated by commas.\nThe first line is often, but not always, a header row indicating the names of the columns/variables.\n\n\nAn Excel .xlsx spreadsheet file. This format is based on Microsoft’s proprietary Excel software. As opposed to a bare-bones .csv file, an .xlsx Excel files contains a lot of meta-data, or in other words, data about data. Some examples of Excel spreadsheet meta-data include the use of bold and italic fonts, colored cells, different column widths, and formula macros.\n\nWe will use the dataset named arrhythmia which is a .csv file.\n\n\n\nFigure 9.1: Table with raw data of arrhythmia data set.\n\n\n\nThe meta-data (data about the data) for this dataset are as following:\n\nage: age (yrs)\nsex: sex (0=male, 1=female)\nheight: height (cm)\nweight: weight (kg)\nQRS: mean duration of QRS (ms) \n\nheart_rate: heart rate (beats/min)\n\nIf the data set is stored in our computer disc as a .csv file we can read it with the read_csv function from dplyr package:\nThe function read_csv() is used to read the arrhythmia.csv file as following:\n\nlibrary(readr)\narrhythmia <- read_csv(here(\"data\", \"arrhythmia.csv\"))\n\narrhythmia\n\n# A tibble: 452 × 6\n     age   sex height weight   QRS heart_rate\n   <dbl> <dbl>  <dbl>  <dbl> <dbl>      <dbl>\n 1    75     0    190     80    91         63\n 2    56     1    165     64    81         53\n 3    54     0    172     95   138         75\n 4    55     0    175     94   100         71\n 5    75     0    190     80    88         75\n 6    13     0    169     51   100         84\n 7    40     1    160     52    77         70\n 8    49     1    162     54    78         67\n 9    44     0    168     56    84         64\n10    50     1    167     67    89         63\n# … with 442 more rows\n\n\nThis data frame contains 452 observations and 6 variables. However, when we call the name of the object (arrhythmia), we can see in the console the first 10 rows, and all the columns that fit on screen. Note that by default the first row of the .csv file was used as the column names of the data frame.\nWe might also have noticed the row of three letter abbreviation dbl under the column names. These describe the type of each variable and may be:\n\ndbl stands for doubles, or real numbers.\nint stands for integers.\nchr stands for character vectors, or strings.\nlgl stands for logical, vectors that contain only TRUE or FALSE.\nfct stands for factors, which R uses to represent categorical variables with fixed possible values.\ndate stands for dates.\ndttm stands for date-times (a date + a time).\n\nAs we can see the categorical variable sex is coded as 0 for males and 1 for females, so it is recognized of double type.\nWe can use the factor() function:\n\narrhythmia$sex = factor(arrhythmia$sex, levels = c(0, 1), \n                       labels = c(\"male\", \"female\"))\n\nLet’s look at the data again with the glipmse() function:\n\nglimpse(arrhythmia)\n\nRows: 452\nColumns: 6\n$ age        <dbl> 75, 56, 54, 55, 75, 13, 40, 49, 44, 50, 62, 45, 54, 30, 44,…\n$ sex        <fct> male, female, male, male, male, male, female, female, male,…\n$ height     <dbl> 190, 165, 172, 175, 190, 169, 160, 162, 168, 167, 170, 165,…\n$ weight     <dbl> 80, 64, 95, 94, 80, 51, 52, 54, 56, 67, 72, 86, 58, 73, 88,…\n$ QRS        <dbl> 91, 81, 138, 100, 88, 100, 77, 78, 84, 89, 102, 77, 78, 91,…\n$ heart_rate <dbl> 63, 53, 75, 71, 75, 84, 70, 67, 64, 63, 70, 72, 73, 56, 72,…\n\n\nNow, the variable sex is a factor variable (fct) with two levels:\n\nlevels(arrhythmia$sex)\n\n[1] \"male\"   \"female\""
  },
  {
    "objectID": "lab1.html",
    "href": "lab1.html",
    "title": "10  LAB II: Descriptive Statistics",
    "section": "",
    "text": "\\(\\equiv\\)"
  }
]