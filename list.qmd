# Data structures in R: lists and data frames {#sec-list}

When we have finished this chapter, we should be able to:

::: {.callout-caution icon="false"}
## Learning objectives
:::

 


## Creating a list

A list in R allows us to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related to each other in any way.
We could say that a list is some kind super data type: we can store practically any piece of information in it!


We construct a list using the `list()` function. The list items (or components  of a list) can be matrices, vectors, other lists. For example:


```{r}
my_list <- list(1:5, c("apple", "orange"), TRUE)
my_list
```

This list consists of three components that are atomic vectors of different types of data (numeric, characters, and logical). 


We can assign names to the list items:

```{r}
my_list <- list(
              numbers = 1:5, 
              strings = c("apple", "orange"), 
              logicals = TRUE)
my_list
```


We can also confirm that the class of the object is `list`: 
```{r}
class(my_list)
```


 

## Subsetting a list


### Subset list and preserve output as a list

We can use the `[ ]` operator to extract one or more list items while preserving the output in list format:


```{r}
my_list[1]    # extract the first list item

class(my_list[1])
```

 


### Subset list and simplify the output

We can use the `[[ ]]` to extract one or more list items while simplifying the output:

```{r}
my_list[[1]]   # extract the first list item and simplify it to a vector

class(my_list[[1]])

my_list[["numbers"]]   # same as above but using the item's name
```


We can also access the content of the list by typing the name of the list followed by a dollar sign `$` folowed by the name of the list item:

```{r}
my_list$numbers  # extract the numbers and simplify to a vector
```

One thing that differentiates the `[[` operator from the `$` is that the `[[` operator can be used with computed indices and names. The `$` operator can only be used with names.




::: {.callout-important icon="false"}
## Simplifying Vs Preserving subsetting
It's important to understand the difference between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output. Preserving subsets keeps the structure of the output the same as the input.
:::
           
 

### Subset list to get individual elements out of a list item

To extract individual elements out of a specific list item combine the `[[` (or $) operator with the `[` operator:



```{r}
my_list[[2]][2]          # using the index

my_list[["strings"]][2]  # using the name of the list item

my_list$strings[2]       # using the $

```


 

## Recursive vectors and Nested Lists

A **recursive vector** is a list that contains other lists. The sublists of a recursive vector are known as **nested lists**. For example:

```{r}
my_list2 <- list(item1 = 3.14,
            item2 = list(item2a_num = 5:10,
                         item2b_char = c("a","b","c")))

my_list2
```

 


**Subsetting a nested list**

We can access list items of a nested list by using the combination of [[ ]] or $ operator and the [ ] operator. For example:

```{r}
# preserve the output as a list
my_list2[[2]][1]
class(my_list2[[2]][1])

# same as above but simplify the output
my_list2[[2]][[1]]
class(my_list2[[2]][[1]])

# same as above with names
my_list2[["item2"]][["item2a_num"]]


# same as above with $ operator
my_list2$item2$item2a_num

```

 

We can also **extract individual elements** from the list items of a nested list. For example:

```{r}
# extract individual element
my_list2[[2]][[2]][3]
class(my_list2[[2]][[2]][3])
```

 

## Unlist a list

We can turn a list into an atomic vector with `unlist()`:
```{r}
my_unlist <- unlist(my_list)
my_unlist
class(my_unlist)
```



